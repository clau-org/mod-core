
/**
 * Client
**/

import * as runtime from './runtime/data-proxy';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>


/**
 * Model Currency
 * 
 */
export type Currency = {
  amount: number
  currency: CurrencyType
}

/**
 * Model platforms
 * 
 */
export type platforms = {
  id: string
  uuid: string
  createdAt: Date | null
  updatedAt: Date | null
  key: string
  username: string | null
  name: string | null
  image_id: string | null
  provider_ids: string[]
  provider_key_ids: string[]
  user_ids: string[]
  organization_ids: string[]
}

/**
 * Model providers
 * 
 */
export type providers = {
  id: string
  createdAt: Date | null
  updatedAt: Date | null
  uuid: string
  key: string
  name: string | null
  image_id: string | null
  platform_ids: string[]
  provider_key_ids: string[]
}

/**
 * Model provider_keys
 * 
 */
export type provider_keys = {
  id: string
  createdAt: Date | null
  updatedAt: Date | null
  uuid: string
  public_key: string
  private_key: string
  secret: boolean
  description: string | null
  provider_id: string
  platform_ids: string[]
}

/**
 * Model users
 * 
 */
export type users = {
  id: string
  createdAt: Date | null
  updatedAt: Date | null
  uuid: string
  username: string | null
  email: string | null
  phone: string | null
  name: string | null
  birthDate: Date | null
  gender: GenderType | null
  image_id: string | null
  prefered_location_id: string | null
  location_ids: string[]
  platform_ids: string[]
  organization_ids: string[]
  store_ids: string[]
}

/**
 * Model organizations
 * 
 */
export type organizations = {
  id: string
  createdAt: Date | null
  updatedAt: Date | null
  uuid: string
  username: string | null
  name: string | null
  image_id: string | null
  platform_ids: string[]
  user_ids: string[]
  location_ids: string[]
}

/**
 * Model stores
 * 
 */
export type stores = {
  id: string
  createdAt: Date | null
  updatedAt: Date | null
  uuid: string
  username: string | null
  name: string | null
  image_id: string | null
  user_ids: string[]
  location_ids: string[]
  inventory_ids: string[]
}

/**
 * Model inventories
 * 
 */
export type inventories = {
  id: string
  createdAt: Date | null
  updatedAt: Date | null
  uuid: string
  name: string | null
  description: string | null
  item_iventory_ids: string[]
  store_ids: string[]
}

/**
 * Model item_inventories
 * 
 */
export type item_inventories = {
  id: string
  createdAt: Date | null
  updatedAt: Date | null
  uuid: string
  item_id: string
  type: ItemQualitativeType
  value: number
  iventory_ids: string[]
}

/**
 * Model oders
 * 
 */
export type oders = {
  id: string
  createdAt: Date | null
  updatedAt: Date | null
  uuid: string
  total: number
  item_order_ids: string[]
}

/**
 * Model item_orders
 * 
 */
export type item_orders = {
  id: string
  createdAt: Date | null
  updatedAt: Date | null
  uuid: string
  item_id: string
  type: ItemQualitativeType
  value: number
  order_ids: string[]
}

/**
 * Model PaymentType
 * 
 */
export type PaymentType = {
  id: string
  createdAt: Date | null
  updatedAt: Date | null
  uuid: string
  title: string | null
  description: string | null
}

/**
 * Model payment
 * 
 */
export type payment = {
  id: string
  createdAt: Date | null
  updatedAt: Date | null
  uuid: string
  title: string | null
  description: string | null
  payment_type_id: string
  user_creator_id: string
  user_confirm_id: string
  receiver_account_id: string
  sender_account_id: string
  amount: Currency
}

/**
 * Model PaymentAccount
 * 
 */
export type PaymentAccount = {
  id: string
  createdAt: Date | null
  updatedAt: Date | null
  uuid: string
  amount: Currency
}

/**
 * Model items
 * 
 */
export type items = {
  id: string
  createdAt: Date | null
  updatedAt: Date | null
  uuid: string
  name: string | null
  description: string | null
  tags: string[]
  image_ids: string[]
  prices: Currency[]
}

/**
 * Model locations
 * 
 */
export type locations = {
  id: string
  createdAt: Date | null
  updatedAt: Date | null
  uuid: string
  name: string | null
  latitude: number | null
  longitude: number | null
  user_ids: string[]
  organizations_ids: string[]
  store_ids: string[]
}

/**
 * Model sessions
 * 
 */
export type sessions = {
  id: string
  createdAt: Date | null
  updatedAt: Date | null
  uuid: string
  jwt: string
  user_uuid: string
  user_id: string
}

/**
 * Model images
 * 
 */
export type images = {
  id: string
  createdAt: Date | null
  updatedAt: Date | null
  uuid: string
  key: string
  url: string | null
  clipped_key: string | null
  clipped_url: string | null
  item_ids: string[]
}

/**
 * Model ClauTest
 * 
 */
export type ClauTest = {
  id: string
  createdAt: Date | null
  updatedAt: Date | null
  uuid: string
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const CurrencyType: {
  MXN: 'MXN',
  USD: 'USD',
  CLAU_CREDIT: 'CLAU_CREDIT'
};

export type CurrencyType = (typeof CurrencyType)[keyof typeof CurrencyType]


export const GenderType: {
  MALE: 'MALE',
  FEMALE: 'FEMALE'
};

export type GenderType = (typeof GenderType)[keyof typeof GenderType]


export const ItemQualitativeType: {
  UNITY: 'UNITY',
  GRAM: 'GRAM'
};

export type ItemQualitativeType = (typeof ItemQualitativeType)[keyof typeof ItemQualitativeType]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Platforms
 * const platforms = await prisma.platforms.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Platforms
   * const platforms = await prisma.platforms.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number }): Promise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

      /**
   * `prisma.platforms`: Exposes CRUD operations for the **platforms** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Platforms
    * const platforms = await prisma.platforms.findMany()
    * ```
    */
  get platforms(): Prisma.platformsDelegate<GlobalReject>;

  /**
   * `prisma.providers`: Exposes CRUD operations for the **providers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Providers
    * const providers = await prisma.providers.findMany()
    * ```
    */
  get providers(): Prisma.providersDelegate<GlobalReject>;

  /**
   * `prisma.provider_keys`: Exposes CRUD operations for the **provider_keys** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Provider_keys
    * const provider_keys = await prisma.provider_keys.findMany()
    * ```
    */
  get provider_keys(): Prisma.provider_keysDelegate<GlobalReject>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<GlobalReject>;

  /**
   * `prisma.organizations`: Exposes CRUD operations for the **organizations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organizations.findMany()
    * ```
    */
  get organizations(): Prisma.organizationsDelegate<GlobalReject>;

  /**
   * `prisma.stores`: Exposes CRUD operations for the **stores** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stores
    * const stores = await prisma.stores.findMany()
    * ```
    */
  get stores(): Prisma.storesDelegate<GlobalReject>;

  /**
   * `prisma.inventories`: Exposes CRUD operations for the **inventories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventories
    * const inventories = await prisma.inventories.findMany()
    * ```
    */
  get inventories(): Prisma.inventoriesDelegate<GlobalReject>;

  /**
   * `prisma.item_inventories`: Exposes CRUD operations for the **item_inventories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Item_inventories
    * const item_inventories = await prisma.item_inventories.findMany()
    * ```
    */
  get item_inventories(): Prisma.item_inventoriesDelegate<GlobalReject>;

  /**
   * `prisma.oders`: Exposes CRUD operations for the **oders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Oders
    * const oders = await prisma.oders.findMany()
    * ```
    */
  get oders(): Prisma.odersDelegate<GlobalReject>;

  /**
   * `prisma.item_orders`: Exposes CRUD operations for the **item_orders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Item_orders
    * const item_orders = await prisma.item_orders.findMany()
    * ```
    */
  get item_orders(): Prisma.item_ordersDelegate<GlobalReject>;

  /**
   * `prisma.paymentType`: Exposes CRUD operations for the **PaymentType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentTypes
    * const paymentTypes = await prisma.paymentType.findMany()
    * ```
    */
  get paymentType(): Prisma.PaymentTypeDelegate<GlobalReject>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.paymentDelegate<GlobalReject>;

  /**
   * `prisma.paymentAccount`: Exposes CRUD operations for the **PaymentAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentAccounts
    * const paymentAccounts = await prisma.paymentAccount.findMany()
    * ```
    */
  get paymentAccount(): Prisma.PaymentAccountDelegate<GlobalReject>;

  /**
   * `prisma.items`: Exposes CRUD operations for the **items** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.items.findMany()
    * ```
    */
  get items(): Prisma.itemsDelegate<GlobalReject>;

  /**
   * `prisma.locations`: Exposes CRUD operations for the **locations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.locations.findMany()
    * ```
    */
  get locations(): Prisma.locationsDelegate<GlobalReject>;

  /**
   * `prisma.sessions`: Exposes CRUD operations for the **sessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.sessions.findMany()
    * ```
    */
  get sessions(): Prisma.sessionsDelegate<GlobalReject>;

  /**
   * `prisma.images`: Exposes CRUD operations for the **images** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Images
    * const images = await prisma.images.findMany()
    * ```
    */
  get images(): Prisma.imagesDelegate<GlobalReject>;

  /**
   * `prisma.clauTest`: Exposes CRUD operations for the **ClauTest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClauTests
    * const clauTests = await prisma.clauTest.findMany()
    * ```
    */
  get clauTest(): Prisma.ClauTestDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.12.0
   * Query Engine version: 659ef412370fa3b41cd7bf6e94587c1dfb7f67e7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    platforms: 'platforms',
    providers: 'providers',
    provider_keys: 'provider_keys',
    users: 'users',
    organizations: 'organizations',
    stores: 'stores',
    inventories: 'inventories',
    item_inventories: 'item_inventories',
    oders: 'oders',
    item_orders: 'item_orders',
    PaymentType: 'PaymentType',
    payment: 'payment',
    PaymentAccount: 'PaymentAccount',
    items: 'items',
    locations: 'locations',
    sessions: 'sessions',
    images: 'images',
    ClauTest: 'ClauTest'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PlatformsCountOutputType
   */


  export type PlatformsCountOutputType = {
    providers: number
    provider_keys: number
    users: number
    organizations: number
  }

  export type PlatformsCountOutputTypeSelect = {
    providers?: boolean
    provider_keys?: boolean
    users?: boolean
    organizations?: boolean
  }

  export type PlatformsCountOutputTypeGetPayload<S extends boolean | null | undefined | PlatformsCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PlatformsCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PlatformsCountOutputTypeArgs)
    ? PlatformsCountOutputType 
    : S extends { select: any } & (PlatformsCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PlatformsCountOutputType ? PlatformsCountOutputType[P] : never
  } 
      : PlatformsCountOutputType




  // Custom InputTypes

  /**
   * PlatformsCountOutputType without action
   */
  export type PlatformsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PlatformsCountOutputType
     */
    select?: PlatformsCountOutputTypeSelect | null
  }



  /**
   * Count Type ProvidersCountOutputType
   */


  export type ProvidersCountOutputType = {
    platforms: number
    provider_keys: number
  }

  export type ProvidersCountOutputTypeSelect = {
    platforms?: boolean
    provider_keys?: boolean
  }

  export type ProvidersCountOutputTypeGetPayload<S extends boolean | null | undefined | ProvidersCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProvidersCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ProvidersCountOutputTypeArgs)
    ? ProvidersCountOutputType 
    : S extends { select: any } & (ProvidersCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ProvidersCountOutputType ? ProvidersCountOutputType[P] : never
  } 
      : ProvidersCountOutputType




  // Custom InputTypes

  /**
   * ProvidersCountOutputType without action
   */
  export type ProvidersCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProvidersCountOutputType
     */
    select?: ProvidersCountOutputTypeSelect | null
  }



  /**
   * Count Type Provider_keysCountOutputType
   */


  export type Provider_keysCountOutputType = {
    platforms: number
  }

  export type Provider_keysCountOutputTypeSelect = {
    platforms?: boolean
  }

  export type Provider_keysCountOutputTypeGetPayload<S extends boolean | null | undefined | Provider_keysCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Provider_keysCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Provider_keysCountOutputTypeArgs)
    ? Provider_keysCountOutputType 
    : S extends { select: any } & (Provider_keysCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Provider_keysCountOutputType ? Provider_keysCountOutputType[P] : never
  } 
      : Provider_keysCountOutputType




  // Custom InputTypes

  /**
   * Provider_keysCountOutputType without action
   */
  export type Provider_keysCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Provider_keysCountOutputType
     */
    select?: Provider_keysCountOutputTypeSelect | null
  }



  /**
   * Count Type UsersCountOutputType
   */


  export type UsersCountOutputType = {
    locations: number
    platforms: number
    organizations: number
    stores: number
    payments_created: number
    payments_confirmed: number
    session: number
  }

  export type UsersCountOutputTypeSelect = {
    locations?: boolean
    platforms?: boolean
    organizations?: boolean
    stores?: boolean
    payments_created?: boolean
    payments_confirmed?: boolean
    session?: boolean
  }

  export type UsersCountOutputTypeGetPayload<S extends boolean | null | undefined | UsersCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UsersCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UsersCountOutputTypeArgs)
    ? UsersCountOutputType 
    : S extends { select: any } & (UsersCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UsersCountOutputType ? UsersCountOutputType[P] : never
  } 
      : UsersCountOutputType




  // Custom InputTypes

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect | null
  }



  /**
   * Count Type OrganizationsCountOutputType
   */


  export type OrganizationsCountOutputType = {
    platforms: number
    users: number
    locations: number
  }

  export type OrganizationsCountOutputTypeSelect = {
    platforms?: boolean
    users?: boolean
    locations?: boolean
  }

  export type OrganizationsCountOutputTypeGetPayload<S extends boolean | null | undefined | OrganizationsCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OrganizationsCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (OrganizationsCountOutputTypeArgs)
    ? OrganizationsCountOutputType 
    : S extends { select: any } & (OrganizationsCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof OrganizationsCountOutputType ? OrganizationsCountOutputType[P] : never
  } 
      : OrganizationsCountOutputType




  // Custom InputTypes

  /**
   * OrganizationsCountOutputType without action
   */
  export type OrganizationsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OrganizationsCountOutputType
     */
    select?: OrganizationsCountOutputTypeSelect | null
  }



  /**
   * Count Type StoresCountOutputType
   */


  export type StoresCountOutputType = {
    users: number
    locations: number
    inventories: number
  }

  export type StoresCountOutputTypeSelect = {
    users?: boolean
    locations?: boolean
    inventories?: boolean
  }

  export type StoresCountOutputTypeGetPayload<S extends boolean | null | undefined | StoresCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? StoresCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (StoresCountOutputTypeArgs)
    ? StoresCountOutputType 
    : S extends { select: any } & (StoresCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof StoresCountOutputType ? StoresCountOutputType[P] : never
  } 
      : StoresCountOutputType




  // Custom InputTypes

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the StoresCountOutputType
     */
    select?: StoresCountOutputTypeSelect | null
  }



  /**
   * Count Type InventoriesCountOutputType
   */


  export type InventoriesCountOutputType = {
    item_inventories: number
    stores: number
  }

  export type InventoriesCountOutputTypeSelect = {
    item_inventories?: boolean
    stores?: boolean
  }

  export type InventoriesCountOutputTypeGetPayload<S extends boolean | null | undefined | InventoriesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? InventoriesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (InventoriesCountOutputTypeArgs)
    ? InventoriesCountOutputType 
    : S extends { select: any } & (InventoriesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof InventoriesCountOutputType ? InventoriesCountOutputType[P] : never
  } 
      : InventoriesCountOutputType




  // Custom InputTypes

  /**
   * InventoriesCountOutputType without action
   */
  export type InventoriesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the InventoriesCountOutputType
     */
    select?: InventoriesCountOutputTypeSelect | null
  }



  /**
   * Count Type Item_inventoriesCountOutputType
   */


  export type Item_inventoriesCountOutputType = {
    inventories: number
  }

  export type Item_inventoriesCountOutputTypeSelect = {
    inventories?: boolean
  }

  export type Item_inventoriesCountOutputTypeGetPayload<S extends boolean | null | undefined | Item_inventoriesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Item_inventoriesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Item_inventoriesCountOutputTypeArgs)
    ? Item_inventoriesCountOutputType 
    : S extends { select: any } & (Item_inventoriesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Item_inventoriesCountOutputType ? Item_inventoriesCountOutputType[P] : never
  } 
      : Item_inventoriesCountOutputType




  // Custom InputTypes

  /**
   * Item_inventoriesCountOutputType without action
   */
  export type Item_inventoriesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Item_inventoriesCountOutputType
     */
    select?: Item_inventoriesCountOutputTypeSelect | null
  }



  /**
   * Count Type OdersCountOutputType
   */


  export type OdersCountOutputType = {
    item_orders: number
  }

  export type OdersCountOutputTypeSelect = {
    item_orders?: boolean
  }

  export type OdersCountOutputTypeGetPayload<S extends boolean | null | undefined | OdersCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OdersCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (OdersCountOutputTypeArgs)
    ? OdersCountOutputType 
    : S extends { select: any } & (OdersCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof OdersCountOutputType ? OdersCountOutputType[P] : never
  } 
      : OdersCountOutputType




  // Custom InputTypes

  /**
   * OdersCountOutputType without action
   */
  export type OdersCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OdersCountOutputType
     */
    select?: OdersCountOutputTypeSelect | null
  }



  /**
   * Count Type Item_ordersCountOutputType
   */


  export type Item_ordersCountOutputType = {
    orders: number
  }

  export type Item_ordersCountOutputTypeSelect = {
    orders?: boolean
  }

  export type Item_ordersCountOutputTypeGetPayload<S extends boolean | null | undefined | Item_ordersCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Item_ordersCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Item_ordersCountOutputTypeArgs)
    ? Item_ordersCountOutputType 
    : S extends { select: any } & (Item_ordersCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Item_ordersCountOutputType ? Item_ordersCountOutputType[P] : never
  } 
      : Item_ordersCountOutputType




  // Custom InputTypes

  /**
   * Item_ordersCountOutputType without action
   */
  export type Item_ordersCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Item_ordersCountOutputType
     */
    select?: Item_ordersCountOutputTypeSelect | null
  }



  /**
   * Count Type PaymentTypeCountOutputType
   */


  export type PaymentTypeCountOutputType = {
    payments: number
  }

  export type PaymentTypeCountOutputTypeSelect = {
    payments?: boolean
  }

  export type PaymentTypeCountOutputTypeGetPayload<S extends boolean | null | undefined | PaymentTypeCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PaymentTypeCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PaymentTypeCountOutputTypeArgs)
    ? PaymentTypeCountOutputType 
    : S extends { select: any } & (PaymentTypeCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PaymentTypeCountOutputType ? PaymentTypeCountOutputType[P] : never
  } 
      : PaymentTypeCountOutputType




  // Custom InputTypes

  /**
   * PaymentTypeCountOutputType without action
   */
  export type PaymentTypeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PaymentTypeCountOutputType
     */
    select?: PaymentTypeCountOutputTypeSelect | null
  }



  /**
   * Count Type PaymentAccountCountOutputType
   */


  export type PaymentAccountCountOutputType = {
    payments_received: number
    payments_sended: number
  }

  export type PaymentAccountCountOutputTypeSelect = {
    payments_received?: boolean
    payments_sended?: boolean
  }

  export type PaymentAccountCountOutputTypeGetPayload<S extends boolean | null | undefined | PaymentAccountCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PaymentAccountCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PaymentAccountCountOutputTypeArgs)
    ? PaymentAccountCountOutputType 
    : S extends { select: any } & (PaymentAccountCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PaymentAccountCountOutputType ? PaymentAccountCountOutputType[P] : never
  } 
      : PaymentAccountCountOutputType




  // Custom InputTypes

  /**
   * PaymentAccountCountOutputType without action
   */
  export type PaymentAccountCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PaymentAccountCountOutputType
     */
    select?: PaymentAccountCountOutputTypeSelect | null
  }



  /**
   * Count Type ItemsCountOutputType
   */


  export type ItemsCountOutputType = {
    images: number
    item_inventories: number
    item_orders: number
  }

  export type ItemsCountOutputTypeSelect = {
    images?: boolean
    item_inventories?: boolean
    item_orders?: boolean
  }

  export type ItemsCountOutputTypeGetPayload<S extends boolean | null | undefined | ItemsCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ItemsCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ItemsCountOutputTypeArgs)
    ? ItemsCountOutputType 
    : S extends { select: any } & (ItemsCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ItemsCountOutputType ? ItemsCountOutputType[P] : never
  } 
      : ItemsCountOutputType




  // Custom InputTypes

  /**
   * ItemsCountOutputType without action
   */
  export type ItemsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ItemsCountOutputType
     */
    select?: ItemsCountOutputTypeSelect | null
  }



  /**
   * Count Type LocationsCountOutputType
   */


  export type LocationsCountOutputType = {
    users: number
    organizations: number
    stores: number
    users_prefered: number
  }

  export type LocationsCountOutputTypeSelect = {
    users?: boolean
    organizations?: boolean
    stores?: boolean
    users_prefered?: boolean
  }

  export type LocationsCountOutputTypeGetPayload<S extends boolean | null | undefined | LocationsCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LocationsCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (LocationsCountOutputTypeArgs)
    ? LocationsCountOutputType 
    : S extends { select: any } & (LocationsCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof LocationsCountOutputType ? LocationsCountOutputType[P] : never
  } 
      : LocationsCountOutputType




  // Custom InputTypes

  /**
   * LocationsCountOutputType without action
   */
  export type LocationsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LocationsCountOutputType
     */
    select?: LocationsCountOutputTypeSelect | null
  }



  /**
   * Count Type ImagesCountOutputType
   */


  export type ImagesCountOutputType = {
    platforms: number
    providers: number
    organizations: number
    stores: number
    users: number
    items: number
  }

  export type ImagesCountOutputTypeSelect = {
    platforms?: boolean
    providers?: boolean
    organizations?: boolean
    stores?: boolean
    users?: boolean
    items?: boolean
  }

  export type ImagesCountOutputTypeGetPayload<S extends boolean | null | undefined | ImagesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ImagesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ImagesCountOutputTypeArgs)
    ? ImagesCountOutputType 
    : S extends { select: any } & (ImagesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ImagesCountOutputType ? ImagesCountOutputType[P] : never
  } 
      : ImagesCountOutputType




  // Custom InputTypes

  /**
   * ImagesCountOutputType without action
   */
  export type ImagesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ImagesCountOutputType
     */
    select?: ImagesCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Currency
   */





  export type CurrencySelect = {
    amount?: boolean
    currency?: boolean
  }


  export type CurrencyGetPayload<S extends boolean | null | undefined | CurrencyArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Currency :
    S extends undefined ? never :
    S extends { include: any } & (CurrencyArgs)
    ? Currency 
    : S extends { select: any } & (CurrencyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Currency ? Currency[P] : never
  } 
      : Currency



  export interface CurrencyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Currency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CurrencyClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Currency without action
   */
  export type CurrencyArgs = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect | null
  }



  /**
   * Model platforms
   */


  export type AggregatePlatforms = {
    _count: PlatformsCountAggregateOutputType | null
    _min: PlatformsMinAggregateOutputType | null
    _max: PlatformsMaxAggregateOutputType | null
  }

  export type PlatformsMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    createdAt: Date | null
    updatedAt: Date | null
    key: string | null
    username: string | null
    name: string | null
    image_id: string | null
  }

  export type PlatformsMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    createdAt: Date | null
    updatedAt: Date | null
    key: string | null
    username: string | null
    name: string | null
    image_id: string | null
  }

  export type PlatformsCountAggregateOutputType = {
    id: number
    uuid: number
    createdAt: number
    updatedAt: number
    key: number
    username: number
    name: number
    image_id: number
    provider_ids: number
    provider_key_ids: number
    user_ids: number
    organization_ids: number
    _all: number
  }


  export type PlatformsMinAggregateInputType = {
    id?: true
    uuid?: true
    createdAt?: true
    updatedAt?: true
    key?: true
    username?: true
    name?: true
    image_id?: true
  }

  export type PlatformsMaxAggregateInputType = {
    id?: true
    uuid?: true
    createdAt?: true
    updatedAt?: true
    key?: true
    username?: true
    name?: true
    image_id?: true
  }

  export type PlatformsCountAggregateInputType = {
    id?: true
    uuid?: true
    createdAt?: true
    updatedAt?: true
    key?: true
    username?: true
    name?: true
    image_id?: true
    provider_ids?: true
    provider_key_ids?: true
    user_ids?: true
    organization_ids?: true
    _all?: true
  }

  export type PlatformsAggregateArgs = {
    /**
     * Filter which platforms to aggregate.
     */
    where?: platformsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of platforms to fetch.
     */
    orderBy?: Enumerable<platformsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: platformsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` platforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` platforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned platforms
    **/
    _count?: true | PlatformsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlatformsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlatformsMaxAggregateInputType
  }

  export type GetPlatformsAggregateType<T extends PlatformsAggregateArgs> = {
        [P in keyof T & keyof AggregatePlatforms]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlatforms[P]>
      : GetScalarType<T[P], AggregatePlatforms[P]>
  }




  export type PlatformsGroupByArgs = {
    where?: platformsWhereInput
    orderBy?: Enumerable<platformsOrderByWithAggregationInput>
    by: PlatformsScalarFieldEnum[]
    having?: platformsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlatformsCountAggregateInputType | true
    _min?: PlatformsMinAggregateInputType
    _max?: PlatformsMaxAggregateInputType
  }


  export type PlatformsGroupByOutputType = {
    id: string
    uuid: string
    createdAt: Date | null
    updatedAt: Date | null
    key: string
    username: string | null
    name: string | null
    image_id: string | null
    provider_ids: string[]
    provider_key_ids: string[]
    user_ids: string[]
    organization_ids: string[]
    _count: PlatformsCountAggregateOutputType | null
    _min: PlatformsMinAggregateOutputType | null
    _max: PlatformsMaxAggregateOutputType | null
  }

  type GetPlatformsGroupByPayload<T extends PlatformsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PlatformsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlatformsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlatformsGroupByOutputType[P]>
            : GetScalarType<T[P], PlatformsGroupByOutputType[P]>
        }
      >
    >


  export type platformsSelect = {
    id?: boolean
    uuid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    key?: boolean
    username?: boolean
    name?: boolean
    image_id?: boolean
    provider_ids?: boolean
    provider_key_ids?: boolean
    user_ids?: boolean
    organization_ids?: boolean
    image?: boolean | imagesArgs
    providers?: boolean | platforms$providersArgs
    provider_keys?: boolean | platforms$provider_keysArgs
    users?: boolean | platforms$usersArgs
    organizations?: boolean | platforms$organizationsArgs
    _count?: boolean | PlatformsCountOutputTypeArgs
  }


  export type platformsInclude = {
    image?: boolean | imagesArgs
    providers?: boolean | platforms$providersArgs
    provider_keys?: boolean | platforms$provider_keysArgs
    users?: boolean | platforms$usersArgs
    organizations?: boolean | platforms$organizationsArgs
    _count?: boolean | PlatformsCountOutputTypeArgs
  }

  export type platformsGetPayload<S extends boolean | null | undefined | platformsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? platforms :
    S extends undefined ? never :
    S extends { include: any } & (platformsArgs | platformsFindManyArgs)
    ? platforms  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'image' ? imagesGetPayload<S['include'][P]> | null :
        P extends 'providers' ? Array < providersGetPayload<S['include'][P]>>  :
        P extends 'provider_keys' ? Array < provider_keysGetPayload<S['include'][P]>>  :
        P extends 'users' ? Array < usersGetPayload<S['include'][P]>>  :
        P extends 'organizations' ? Array < organizationsGetPayload<S['include'][P]>>  :
        P extends '_count' ? PlatformsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (platformsArgs | platformsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'image' ? imagesGetPayload<S['select'][P]> | null :
        P extends 'providers' ? Array < providersGetPayload<S['select'][P]>>  :
        P extends 'provider_keys' ? Array < provider_keysGetPayload<S['select'][P]>>  :
        P extends 'users' ? Array < usersGetPayload<S['select'][P]>>  :
        P extends 'organizations' ? Array < organizationsGetPayload<S['select'][P]>>  :
        P extends '_count' ? PlatformsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof platforms ? platforms[P] : never
  } 
      : platforms


  type platformsCountArgs = 
    Omit<platformsFindManyArgs, 'select' | 'include'> & {
      select?: PlatformsCountAggregateInputType | true
    }

  export interface platformsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Platforms that matches the filter.
     * @param {platformsFindUniqueArgs} args - Arguments to find a Platforms
     * @example
     * // Get one Platforms
     * const platforms = await prisma.platforms.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends platformsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, platformsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'platforms'> extends True ? Prisma__platformsClient<platformsGetPayload<T>> : Prisma__platformsClient<platformsGetPayload<T> | null, null>

    /**
     * Find one Platforms that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {platformsFindUniqueOrThrowArgs} args - Arguments to find a Platforms
     * @example
     * // Get one Platforms
     * const platforms = await prisma.platforms.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends platformsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, platformsFindUniqueOrThrowArgs>
    ): Prisma__platformsClient<platformsGetPayload<T>>

    /**
     * Find the first Platforms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {platformsFindFirstArgs} args - Arguments to find a Platforms
     * @example
     * // Get one Platforms
     * const platforms = await prisma.platforms.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends platformsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, platformsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'platforms'> extends True ? Prisma__platformsClient<platformsGetPayload<T>> : Prisma__platformsClient<platformsGetPayload<T> | null, null>

    /**
     * Find the first Platforms that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {platformsFindFirstOrThrowArgs} args - Arguments to find a Platforms
     * @example
     * // Get one Platforms
     * const platforms = await prisma.platforms.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends platformsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, platformsFindFirstOrThrowArgs>
    ): Prisma__platformsClient<platformsGetPayload<T>>

    /**
     * Find zero or more Platforms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {platformsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Platforms
     * const platforms = await prisma.platforms.findMany()
     * 
     * // Get first 10 Platforms
     * const platforms = await prisma.platforms.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const platformsWithIdOnly = await prisma.platforms.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends platformsFindManyArgs>(
      args?: SelectSubset<T, platformsFindManyArgs>
    ): Prisma.PrismaPromise<Array<platformsGetPayload<T>>>

    /**
     * Create a Platforms.
     * @param {platformsCreateArgs} args - Arguments to create a Platforms.
     * @example
     * // Create one Platforms
     * const Platforms = await prisma.platforms.create({
     *   data: {
     *     // ... data to create a Platforms
     *   }
     * })
     * 
    **/
    create<T extends platformsCreateArgs>(
      args: SelectSubset<T, platformsCreateArgs>
    ): Prisma__platformsClient<platformsGetPayload<T>>

    /**
     * Create many Platforms.
     *     @param {platformsCreateManyArgs} args - Arguments to create many Platforms.
     *     @example
     *     // Create many Platforms
     *     const platforms = await prisma.platforms.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends platformsCreateManyArgs>(
      args?: SelectSubset<T, platformsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Platforms.
     * @param {platformsDeleteArgs} args - Arguments to delete one Platforms.
     * @example
     * // Delete one Platforms
     * const Platforms = await prisma.platforms.delete({
     *   where: {
     *     // ... filter to delete one Platforms
     *   }
     * })
     * 
    **/
    delete<T extends platformsDeleteArgs>(
      args: SelectSubset<T, platformsDeleteArgs>
    ): Prisma__platformsClient<platformsGetPayload<T>>

    /**
     * Update one Platforms.
     * @param {platformsUpdateArgs} args - Arguments to update one Platforms.
     * @example
     * // Update one Platforms
     * const platforms = await prisma.platforms.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends platformsUpdateArgs>(
      args: SelectSubset<T, platformsUpdateArgs>
    ): Prisma__platformsClient<platformsGetPayload<T>>

    /**
     * Delete zero or more Platforms.
     * @param {platformsDeleteManyArgs} args - Arguments to filter Platforms to delete.
     * @example
     * // Delete a few Platforms
     * const { count } = await prisma.platforms.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends platformsDeleteManyArgs>(
      args?: SelectSubset<T, platformsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Platforms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {platformsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Platforms
     * const platforms = await prisma.platforms.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends platformsUpdateManyArgs>(
      args: SelectSubset<T, platformsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Platforms.
     * @param {platformsUpsertArgs} args - Arguments to update or create a Platforms.
     * @example
     * // Update or create a Platforms
     * const platforms = await prisma.platforms.upsert({
     *   create: {
     *     // ... data to create a Platforms
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Platforms we want to update
     *   }
     * })
    **/
    upsert<T extends platformsUpsertArgs>(
      args: SelectSubset<T, platformsUpsertArgs>
    ): Prisma__platformsClient<platformsGetPayload<T>>

    /**
     * Find zero or more Platforms that matches the filter.
     * @param {platformsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const platforms = await prisma.platforms.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: platformsFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Platforms.
     * @param {platformsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const platforms = await prisma.platforms.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: platformsAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Platforms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {platformsCountArgs} args - Arguments to filter Platforms to count.
     * @example
     * // Count the number of Platforms
     * const count = await prisma.platforms.count({
     *   where: {
     *     // ... the filter for the Platforms we want to count
     *   }
     * })
    **/
    count<T extends platformsCountArgs>(
      args?: Subset<T, platformsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlatformsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Platforms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlatformsAggregateArgs>(args: Subset<T, PlatformsAggregateArgs>): Prisma.PrismaPromise<GetPlatformsAggregateType<T>>

    /**
     * Group by Platforms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlatformsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlatformsGroupByArgs['orderBy'] }
        : { orderBy?: PlatformsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlatformsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlatformsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for platforms.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__platformsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    image<T extends imagesArgs= {}>(args?: Subset<T, imagesArgs>): Prisma__imagesClient<imagesGetPayload<T> | Null>;

    providers<T extends platforms$providersArgs= {}>(args?: Subset<T, platforms$providersArgs>): Prisma.PrismaPromise<Array<providersGetPayload<T>>| Null>;

    provider_keys<T extends platforms$provider_keysArgs= {}>(args?: Subset<T, platforms$provider_keysArgs>): Prisma.PrismaPromise<Array<provider_keysGetPayload<T>>| Null>;

    users<T extends platforms$usersArgs= {}>(args?: Subset<T, platforms$usersArgs>): Prisma.PrismaPromise<Array<usersGetPayload<T>>| Null>;

    organizations<T extends platforms$organizationsArgs= {}>(args?: Subset<T, platforms$organizationsArgs>): Prisma.PrismaPromise<Array<organizationsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * platforms base type for findUnique actions
   */
  export type platformsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the platforms
     */
    select?: platformsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: platformsInclude | null
    /**
     * Filter, which platforms to fetch.
     */
    where: platformsWhereUniqueInput
  }

  /**
   * platforms findUnique
   */
  export interface platformsFindUniqueArgs extends platformsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * platforms findUniqueOrThrow
   */
  export type platformsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the platforms
     */
    select?: platformsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: platformsInclude | null
    /**
     * Filter, which platforms to fetch.
     */
    where: platformsWhereUniqueInput
  }


  /**
   * platforms base type for findFirst actions
   */
  export type platformsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the platforms
     */
    select?: platformsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: platformsInclude | null
    /**
     * Filter, which platforms to fetch.
     */
    where?: platformsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of platforms to fetch.
     */
    orderBy?: Enumerable<platformsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for platforms.
     */
    cursor?: platformsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` platforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` platforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of platforms.
     */
    distinct?: Enumerable<PlatformsScalarFieldEnum>
  }

  /**
   * platforms findFirst
   */
  export interface platformsFindFirstArgs extends platformsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * platforms findFirstOrThrow
   */
  export type platformsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the platforms
     */
    select?: platformsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: platformsInclude | null
    /**
     * Filter, which platforms to fetch.
     */
    where?: platformsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of platforms to fetch.
     */
    orderBy?: Enumerable<platformsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for platforms.
     */
    cursor?: platformsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` platforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` platforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of platforms.
     */
    distinct?: Enumerable<PlatformsScalarFieldEnum>
  }


  /**
   * platforms findMany
   */
  export type platformsFindManyArgs = {
    /**
     * Select specific fields to fetch from the platforms
     */
    select?: platformsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: platformsInclude | null
    /**
     * Filter, which platforms to fetch.
     */
    where?: platformsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of platforms to fetch.
     */
    orderBy?: Enumerable<platformsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing platforms.
     */
    cursor?: platformsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` platforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` platforms.
     */
    skip?: number
    distinct?: Enumerable<PlatformsScalarFieldEnum>
  }


  /**
   * platforms create
   */
  export type platformsCreateArgs = {
    /**
     * Select specific fields to fetch from the platforms
     */
    select?: platformsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: platformsInclude | null
    /**
     * The data needed to create a platforms.
     */
    data: XOR<platformsCreateInput, platformsUncheckedCreateInput>
  }


  /**
   * platforms createMany
   */
  export type platformsCreateManyArgs = {
    /**
     * The data used to create many platforms.
     */
    data: Enumerable<platformsCreateManyInput>
  }


  /**
   * platforms update
   */
  export type platformsUpdateArgs = {
    /**
     * Select specific fields to fetch from the platforms
     */
    select?: platformsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: platformsInclude | null
    /**
     * The data needed to update a platforms.
     */
    data: XOR<platformsUpdateInput, platformsUncheckedUpdateInput>
    /**
     * Choose, which platforms to update.
     */
    where: platformsWhereUniqueInput
  }


  /**
   * platforms updateMany
   */
  export type platformsUpdateManyArgs = {
    /**
     * The data used to update platforms.
     */
    data: XOR<platformsUpdateManyMutationInput, platformsUncheckedUpdateManyInput>
    /**
     * Filter which platforms to update
     */
    where?: platformsWhereInput
  }


  /**
   * platforms upsert
   */
  export type platformsUpsertArgs = {
    /**
     * Select specific fields to fetch from the platforms
     */
    select?: platformsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: platformsInclude | null
    /**
     * The filter to search for the platforms to update in case it exists.
     */
    where: platformsWhereUniqueInput
    /**
     * In case the platforms found by the `where` argument doesn't exist, create a new platforms with this data.
     */
    create: XOR<platformsCreateInput, platformsUncheckedCreateInput>
    /**
     * In case the platforms was found with the provided `where` argument, update it with this data.
     */
    update: XOR<platformsUpdateInput, platformsUncheckedUpdateInput>
  }


  /**
   * platforms delete
   */
  export type platformsDeleteArgs = {
    /**
     * Select specific fields to fetch from the platforms
     */
    select?: platformsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: platformsInclude | null
    /**
     * Filter which platforms to delete.
     */
    where: platformsWhereUniqueInput
  }


  /**
   * platforms deleteMany
   */
  export type platformsDeleteManyArgs = {
    /**
     * Filter which platforms to delete
     */
    where?: platformsWhereInput
  }


  /**
   * platforms findRaw
   */
  export type platformsFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * platforms aggregateRaw
   */
  export type platformsAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * platforms.providers
   */
  export type platforms$providersArgs = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: providersInclude | null
    where?: providersWhereInput
    orderBy?: Enumerable<providersOrderByWithRelationInput>
    cursor?: providersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProvidersScalarFieldEnum>
  }


  /**
   * platforms.provider_keys
   */
  export type platforms$provider_keysArgs = {
    /**
     * Select specific fields to fetch from the provider_keys
     */
    select?: provider_keysSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: provider_keysInclude | null
    where?: provider_keysWhereInput
    orderBy?: Enumerable<provider_keysOrderByWithRelationInput>
    cursor?: provider_keysWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Provider_keysScalarFieldEnum>
  }


  /**
   * platforms.users
   */
  export type platforms$usersArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    where?: usersWhereInput
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * platforms.organizations
   */
  export type platforms$organizationsArgs = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude | null
    where?: organizationsWhereInput
    orderBy?: Enumerable<organizationsOrderByWithRelationInput>
    cursor?: organizationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OrganizationsScalarFieldEnum>
  }


  /**
   * platforms without action
   */
  export type platformsArgs = {
    /**
     * Select specific fields to fetch from the platforms
     */
    select?: platformsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: platformsInclude | null
  }



  /**
   * Model providers
   */


  export type AggregateProviders = {
    _count: ProvidersCountAggregateOutputType | null
    _min: ProvidersMinAggregateOutputType | null
    _max: ProvidersMaxAggregateOutputType | null
  }

  export type ProvidersMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
    key: string | null
    name: string | null
    image_id: string | null
  }

  export type ProvidersMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
    key: string | null
    name: string | null
    image_id: string | null
  }

  export type ProvidersCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    uuid: number
    key: number
    name: number
    image_id: number
    platform_ids: number
    provider_key_ids: number
    _all: number
  }


  export type ProvidersMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    key?: true
    name?: true
    image_id?: true
  }

  export type ProvidersMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    key?: true
    name?: true
    image_id?: true
  }

  export type ProvidersCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    key?: true
    name?: true
    image_id?: true
    platform_ids?: true
    provider_key_ids?: true
    _all?: true
  }

  export type ProvidersAggregateArgs = {
    /**
     * Filter which providers to aggregate.
     */
    where?: providersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of providers to fetch.
     */
    orderBy?: Enumerable<providersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: providersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned providers
    **/
    _count?: true | ProvidersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProvidersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProvidersMaxAggregateInputType
  }

  export type GetProvidersAggregateType<T extends ProvidersAggregateArgs> = {
        [P in keyof T & keyof AggregateProviders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProviders[P]>
      : GetScalarType<T[P], AggregateProviders[P]>
  }




  export type ProvidersGroupByArgs = {
    where?: providersWhereInput
    orderBy?: Enumerable<providersOrderByWithAggregationInput>
    by: ProvidersScalarFieldEnum[]
    having?: providersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProvidersCountAggregateInputType | true
    _min?: ProvidersMinAggregateInputType
    _max?: ProvidersMaxAggregateInputType
  }


  export type ProvidersGroupByOutputType = {
    id: string
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string
    key: string
    name: string | null
    image_id: string | null
    platform_ids: string[]
    provider_key_ids: string[]
    _count: ProvidersCountAggregateOutputType | null
    _min: ProvidersMinAggregateOutputType | null
    _max: ProvidersMaxAggregateOutputType | null
  }

  type GetProvidersGroupByPayload<T extends ProvidersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProvidersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProvidersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProvidersGroupByOutputType[P]>
            : GetScalarType<T[P], ProvidersGroupByOutputType[P]>
        }
      >
    >


  export type providersSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uuid?: boolean
    key?: boolean
    name?: boolean
    image_id?: boolean
    platform_ids?: boolean
    provider_key_ids?: boolean
    image?: boolean | imagesArgs
    platforms?: boolean | providers$platformsArgs
    provider_keys?: boolean | providers$provider_keysArgs
    _count?: boolean | ProvidersCountOutputTypeArgs
  }


  export type providersInclude = {
    image?: boolean | imagesArgs
    platforms?: boolean | providers$platformsArgs
    provider_keys?: boolean | providers$provider_keysArgs
    _count?: boolean | ProvidersCountOutputTypeArgs
  }

  export type providersGetPayload<S extends boolean | null | undefined | providersArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? providers :
    S extends undefined ? never :
    S extends { include: any } & (providersArgs | providersFindManyArgs)
    ? providers  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'image' ? imagesGetPayload<S['include'][P]> | null :
        P extends 'platforms' ? Array < platformsGetPayload<S['include'][P]>>  :
        P extends 'provider_keys' ? Array < provider_keysGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProvidersCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (providersArgs | providersFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'image' ? imagesGetPayload<S['select'][P]> | null :
        P extends 'platforms' ? Array < platformsGetPayload<S['select'][P]>>  :
        P extends 'provider_keys' ? Array < provider_keysGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProvidersCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof providers ? providers[P] : never
  } 
      : providers


  type providersCountArgs = 
    Omit<providersFindManyArgs, 'select' | 'include'> & {
      select?: ProvidersCountAggregateInputType | true
    }

  export interface providersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Providers that matches the filter.
     * @param {providersFindUniqueArgs} args - Arguments to find a Providers
     * @example
     * // Get one Providers
     * const providers = await prisma.providers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends providersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, providersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'providers'> extends True ? Prisma__providersClient<providersGetPayload<T>> : Prisma__providersClient<providersGetPayload<T> | null, null>

    /**
     * Find one Providers that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {providersFindUniqueOrThrowArgs} args - Arguments to find a Providers
     * @example
     * // Get one Providers
     * const providers = await prisma.providers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends providersFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, providersFindUniqueOrThrowArgs>
    ): Prisma__providersClient<providersGetPayload<T>>

    /**
     * Find the first Providers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {providersFindFirstArgs} args - Arguments to find a Providers
     * @example
     * // Get one Providers
     * const providers = await prisma.providers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends providersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, providersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'providers'> extends True ? Prisma__providersClient<providersGetPayload<T>> : Prisma__providersClient<providersGetPayload<T> | null, null>

    /**
     * Find the first Providers that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {providersFindFirstOrThrowArgs} args - Arguments to find a Providers
     * @example
     * // Get one Providers
     * const providers = await prisma.providers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends providersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, providersFindFirstOrThrowArgs>
    ): Prisma__providersClient<providersGetPayload<T>>

    /**
     * Find zero or more Providers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {providersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Providers
     * const providers = await prisma.providers.findMany()
     * 
     * // Get first 10 Providers
     * const providers = await prisma.providers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const providersWithIdOnly = await prisma.providers.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends providersFindManyArgs>(
      args?: SelectSubset<T, providersFindManyArgs>
    ): Prisma.PrismaPromise<Array<providersGetPayload<T>>>

    /**
     * Create a Providers.
     * @param {providersCreateArgs} args - Arguments to create a Providers.
     * @example
     * // Create one Providers
     * const Providers = await prisma.providers.create({
     *   data: {
     *     // ... data to create a Providers
     *   }
     * })
     * 
    **/
    create<T extends providersCreateArgs>(
      args: SelectSubset<T, providersCreateArgs>
    ): Prisma__providersClient<providersGetPayload<T>>

    /**
     * Create many Providers.
     *     @param {providersCreateManyArgs} args - Arguments to create many Providers.
     *     @example
     *     // Create many Providers
     *     const providers = await prisma.providers.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends providersCreateManyArgs>(
      args?: SelectSubset<T, providersCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Providers.
     * @param {providersDeleteArgs} args - Arguments to delete one Providers.
     * @example
     * // Delete one Providers
     * const Providers = await prisma.providers.delete({
     *   where: {
     *     // ... filter to delete one Providers
     *   }
     * })
     * 
    **/
    delete<T extends providersDeleteArgs>(
      args: SelectSubset<T, providersDeleteArgs>
    ): Prisma__providersClient<providersGetPayload<T>>

    /**
     * Update one Providers.
     * @param {providersUpdateArgs} args - Arguments to update one Providers.
     * @example
     * // Update one Providers
     * const providers = await prisma.providers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends providersUpdateArgs>(
      args: SelectSubset<T, providersUpdateArgs>
    ): Prisma__providersClient<providersGetPayload<T>>

    /**
     * Delete zero or more Providers.
     * @param {providersDeleteManyArgs} args - Arguments to filter Providers to delete.
     * @example
     * // Delete a few Providers
     * const { count } = await prisma.providers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends providersDeleteManyArgs>(
      args?: SelectSubset<T, providersDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {providersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Providers
     * const providers = await prisma.providers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends providersUpdateManyArgs>(
      args: SelectSubset<T, providersUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Providers.
     * @param {providersUpsertArgs} args - Arguments to update or create a Providers.
     * @example
     * // Update or create a Providers
     * const providers = await prisma.providers.upsert({
     *   create: {
     *     // ... data to create a Providers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Providers we want to update
     *   }
     * })
    **/
    upsert<T extends providersUpsertArgs>(
      args: SelectSubset<T, providersUpsertArgs>
    ): Prisma__providersClient<providersGetPayload<T>>

    /**
     * Find zero or more Providers that matches the filter.
     * @param {providersFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const providers = await prisma.providers.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: providersFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Providers.
     * @param {providersAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const providers = await prisma.providers.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: providersAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {providersCountArgs} args - Arguments to filter Providers to count.
     * @example
     * // Count the number of Providers
     * const count = await prisma.providers.count({
     *   where: {
     *     // ... the filter for the Providers we want to count
     *   }
     * })
    **/
    count<T extends providersCountArgs>(
      args?: Subset<T, providersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProvidersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvidersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProvidersAggregateArgs>(args: Subset<T, ProvidersAggregateArgs>): Prisma.PrismaPromise<GetProvidersAggregateType<T>>

    /**
     * Group by Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvidersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProvidersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProvidersGroupByArgs['orderBy'] }
        : { orderBy?: ProvidersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProvidersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProvidersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for providers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__providersClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    image<T extends imagesArgs= {}>(args?: Subset<T, imagesArgs>): Prisma__imagesClient<imagesGetPayload<T> | Null>;

    platforms<T extends providers$platformsArgs= {}>(args?: Subset<T, providers$platformsArgs>): Prisma.PrismaPromise<Array<platformsGetPayload<T>>| Null>;

    provider_keys<T extends providers$provider_keysArgs= {}>(args?: Subset<T, providers$provider_keysArgs>): Prisma.PrismaPromise<Array<provider_keysGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * providers base type for findUnique actions
   */
  export type providersFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: providersInclude | null
    /**
     * Filter, which providers to fetch.
     */
    where: providersWhereUniqueInput
  }

  /**
   * providers findUnique
   */
  export interface providersFindUniqueArgs extends providersFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * providers findUniqueOrThrow
   */
  export type providersFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: providersInclude | null
    /**
     * Filter, which providers to fetch.
     */
    where: providersWhereUniqueInput
  }


  /**
   * providers base type for findFirst actions
   */
  export type providersFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: providersInclude | null
    /**
     * Filter, which providers to fetch.
     */
    where?: providersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of providers to fetch.
     */
    orderBy?: Enumerable<providersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for providers.
     */
    cursor?: providersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of providers.
     */
    distinct?: Enumerable<ProvidersScalarFieldEnum>
  }

  /**
   * providers findFirst
   */
  export interface providersFindFirstArgs extends providersFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * providers findFirstOrThrow
   */
  export type providersFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: providersInclude | null
    /**
     * Filter, which providers to fetch.
     */
    where?: providersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of providers to fetch.
     */
    orderBy?: Enumerable<providersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for providers.
     */
    cursor?: providersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of providers.
     */
    distinct?: Enumerable<ProvidersScalarFieldEnum>
  }


  /**
   * providers findMany
   */
  export type providersFindManyArgs = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: providersInclude | null
    /**
     * Filter, which providers to fetch.
     */
    where?: providersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of providers to fetch.
     */
    orderBy?: Enumerable<providersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing providers.
     */
    cursor?: providersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` providers.
     */
    skip?: number
    distinct?: Enumerable<ProvidersScalarFieldEnum>
  }


  /**
   * providers create
   */
  export type providersCreateArgs = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: providersInclude | null
    /**
     * The data needed to create a providers.
     */
    data: XOR<providersCreateInput, providersUncheckedCreateInput>
  }


  /**
   * providers createMany
   */
  export type providersCreateManyArgs = {
    /**
     * The data used to create many providers.
     */
    data: Enumerable<providersCreateManyInput>
  }


  /**
   * providers update
   */
  export type providersUpdateArgs = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: providersInclude | null
    /**
     * The data needed to update a providers.
     */
    data: XOR<providersUpdateInput, providersUncheckedUpdateInput>
    /**
     * Choose, which providers to update.
     */
    where: providersWhereUniqueInput
  }


  /**
   * providers updateMany
   */
  export type providersUpdateManyArgs = {
    /**
     * The data used to update providers.
     */
    data: XOR<providersUpdateManyMutationInput, providersUncheckedUpdateManyInput>
    /**
     * Filter which providers to update
     */
    where?: providersWhereInput
  }


  /**
   * providers upsert
   */
  export type providersUpsertArgs = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: providersInclude | null
    /**
     * The filter to search for the providers to update in case it exists.
     */
    where: providersWhereUniqueInput
    /**
     * In case the providers found by the `where` argument doesn't exist, create a new providers with this data.
     */
    create: XOR<providersCreateInput, providersUncheckedCreateInput>
    /**
     * In case the providers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<providersUpdateInput, providersUncheckedUpdateInput>
  }


  /**
   * providers delete
   */
  export type providersDeleteArgs = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: providersInclude | null
    /**
     * Filter which providers to delete.
     */
    where: providersWhereUniqueInput
  }


  /**
   * providers deleteMany
   */
  export type providersDeleteManyArgs = {
    /**
     * Filter which providers to delete
     */
    where?: providersWhereInput
  }


  /**
   * providers findRaw
   */
  export type providersFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * providers aggregateRaw
   */
  export type providersAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * providers.platforms
   */
  export type providers$platformsArgs = {
    /**
     * Select specific fields to fetch from the platforms
     */
    select?: platformsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: platformsInclude | null
    where?: platformsWhereInput
    orderBy?: Enumerable<platformsOrderByWithRelationInput>
    cursor?: platformsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PlatformsScalarFieldEnum>
  }


  /**
   * providers.provider_keys
   */
  export type providers$provider_keysArgs = {
    /**
     * Select specific fields to fetch from the provider_keys
     */
    select?: provider_keysSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: provider_keysInclude | null
    where?: provider_keysWhereInput
    orderBy?: Enumerable<provider_keysOrderByWithRelationInput>
    cursor?: provider_keysWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Provider_keysScalarFieldEnum>
  }


  /**
   * providers without action
   */
  export type providersArgs = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: providersInclude | null
  }



  /**
   * Model provider_keys
   */


  export type AggregateProvider_keys = {
    _count: Provider_keysCountAggregateOutputType | null
    _min: Provider_keysMinAggregateOutputType | null
    _max: Provider_keysMaxAggregateOutputType | null
  }

  export type Provider_keysMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
    public_key: string | null
    private_key: string | null
    secret: boolean | null
    description: string | null
    provider_id: string | null
  }

  export type Provider_keysMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
    public_key: string | null
    private_key: string | null
    secret: boolean | null
    description: string | null
    provider_id: string | null
  }

  export type Provider_keysCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    uuid: number
    public_key: number
    private_key: number
    secret: number
    description: number
    provider_id: number
    platform_ids: number
    _all: number
  }


  export type Provider_keysMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    public_key?: true
    private_key?: true
    secret?: true
    description?: true
    provider_id?: true
  }

  export type Provider_keysMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    public_key?: true
    private_key?: true
    secret?: true
    description?: true
    provider_id?: true
  }

  export type Provider_keysCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    public_key?: true
    private_key?: true
    secret?: true
    description?: true
    provider_id?: true
    platform_ids?: true
    _all?: true
  }

  export type Provider_keysAggregateArgs = {
    /**
     * Filter which provider_keys to aggregate.
     */
    where?: provider_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provider_keys to fetch.
     */
    orderBy?: Enumerable<provider_keysOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: provider_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provider_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provider_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned provider_keys
    **/
    _count?: true | Provider_keysCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Provider_keysMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Provider_keysMaxAggregateInputType
  }

  export type GetProvider_keysAggregateType<T extends Provider_keysAggregateArgs> = {
        [P in keyof T & keyof AggregateProvider_keys]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvider_keys[P]>
      : GetScalarType<T[P], AggregateProvider_keys[P]>
  }




  export type Provider_keysGroupByArgs = {
    where?: provider_keysWhereInput
    orderBy?: Enumerable<provider_keysOrderByWithAggregationInput>
    by: Provider_keysScalarFieldEnum[]
    having?: provider_keysScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Provider_keysCountAggregateInputType | true
    _min?: Provider_keysMinAggregateInputType
    _max?: Provider_keysMaxAggregateInputType
  }


  export type Provider_keysGroupByOutputType = {
    id: string
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string
    public_key: string
    private_key: string
    secret: boolean
    description: string | null
    provider_id: string
    platform_ids: string[]
    _count: Provider_keysCountAggregateOutputType | null
    _min: Provider_keysMinAggregateOutputType | null
    _max: Provider_keysMaxAggregateOutputType | null
  }

  type GetProvider_keysGroupByPayload<T extends Provider_keysGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Provider_keysGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Provider_keysGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Provider_keysGroupByOutputType[P]>
            : GetScalarType<T[P], Provider_keysGroupByOutputType[P]>
        }
      >
    >


  export type provider_keysSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uuid?: boolean
    public_key?: boolean
    private_key?: boolean
    secret?: boolean
    description?: boolean
    provider_id?: boolean
    platform_ids?: boolean
    provider?: boolean | providersArgs
    platforms?: boolean | provider_keys$platformsArgs
    _count?: boolean | Provider_keysCountOutputTypeArgs
  }


  export type provider_keysInclude = {
    provider?: boolean | providersArgs
    platforms?: boolean | provider_keys$platformsArgs
    _count?: boolean | Provider_keysCountOutputTypeArgs
  }

  export type provider_keysGetPayload<S extends boolean | null | undefined | provider_keysArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? provider_keys :
    S extends undefined ? never :
    S extends { include: any } & (provider_keysArgs | provider_keysFindManyArgs)
    ? provider_keys  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'provider' ? providersGetPayload<S['include'][P]> :
        P extends 'platforms' ? Array < platformsGetPayload<S['include'][P]>>  :
        P extends '_count' ? Provider_keysCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (provider_keysArgs | provider_keysFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'provider' ? providersGetPayload<S['select'][P]> :
        P extends 'platforms' ? Array < platformsGetPayload<S['select'][P]>>  :
        P extends '_count' ? Provider_keysCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof provider_keys ? provider_keys[P] : never
  } 
      : provider_keys


  type provider_keysCountArgs = 
    Omit<provider_keysFindManyArgs, 'select' | 'include'> & {
      select?: Provider_keysCountAggregateInputType | true
    }

  export interface provider_keysDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Provider_keys that matches the filter.
     * @param {provider_keysFindUniqueArgs} args - Arguments to find a Provider_keys
     * @example
     * // Get one Provider_keys
     * const provider_keys = await prisma.provider_keys.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends provider_keysFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, provider_keysFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'provider_keys'> extends True ? Prisma__provider_keysClient<provider_keysGetPayload<T>> : Prisma__provider_keysClient<provider_keysGetPayload<T> | null, null>

    /**
     * Find one Provider_keys that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {provider_keysFindUniqueOrThrowArgs} args - Arguments to find a Provider_keys
     * @example
     * // Get one Provider_keys
     * const provider_keys = await prisma.provider_keys.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends provider_keysFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, provider_keysFindUniqueOrThrowArgs>
    ): Prisma__provider_keysClient<provider_keysGetPayload<T>>

    /**
     * Find the first Provider_keys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_keysFindFirstArgs} args - Arguments to find a Provider_keys
     * @example
     * // Get one Provider_keys
     * const provider_keys = await prisma.provider_keys.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends provider_keysFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, provider_keysFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'provider_keys'> extends True ? Prisma__provider_keysClient<provider_keysGetPayload<T>> : Prisma__provider_keysClient<provider_keysGetPayload<T> | null, null>

    /**
     * Find the first Provider_keys that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_keysFindFirstOrThrowArgs} args - Arguments to find a Provider_keys
     * @example
     * // Get one Provider_keys
     * const provider_keys = await prisma.provider_keys.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends provider_keysFindFirstOrThrowArgs>(
      args?: SelectSubset<T, provider_keysFindFirstOrThrowArgs>
    ): Prisma__provider_keysClient<provider_keysGetPayload<T>>

    /**
     * Find zero or more Provider_keys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_keysFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Provider_keys
     * const provider_keys = await prisma.provider_keys.findMany()
     * 
     * // Get first 10 Provider_keys
     * const provider_keys = await prisma.provider_keys.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const provider_keysWithIdOnly = await prisma.provider_keys.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends provider_keysFindManyArgs>(
      args?: SelectSubset<T, provider_keysFindManyArgs>
    ): Prisma.PrismaPromise<Array<provider_keysGetPayload<T>>>

    /**
     * Create a Provider_keys.
     * @param {provider_keysCreateArgs} args - Arguments to create a Provider_keys.
     * @example
     * // Create one Provider_keys
     * const Provider_keys = await prisma.provider_keys.create({
     *   data: {
     *     // ... data to create a Provider_keys
     *   }
     * })
     * 
    **/
    create<T extends provider_keysCreateArgs>(
      args: SelectSubset<T, provider_keysCreateArgs>
    ): Prisma__provider_keysClient<provider_keysGetPayload<T>>

    /**
     * Create many Provider_keys.
     *     @param {provider_keysCreateManyArgs} args - Arguments to create many Provider_keys.
     *     @example
     *     // Create many Provider_keys
     *     const provider_keys = await prisma.provider_keys.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends provider_keysCreateManyArgs>(
      args?: SelectSubset<T, provider_keysCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Provider_keys.
     * @param {provider_keysDeleteArgs} args - Arguments to delete one Provider_keys.
     * @example
     * // Delete one Provider_keys
     * const Provider_keys = await prisma.provider_keys.delete({
     *   where: {
     *     // ... filter to delete one Provider_keys
     *   }
     * })
     * 
    **/
    delete<T extends provider_keysDeleteArgs>(
      args: SelectSubset<T, provider_keysDeleteArgs>
    ): Prisma__provider_keysClient<provider_keysGetPayload<T>>

    /**
     * Update one Provider_keys.
     * @param {provider_keysUpdateArgs} args - Arguments to update one Provider_keys.
     * @example
     * // Update one Provider_keys
     * const provider_keys = await prisma.provider_keys.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends provider_keysUpdateArgs>(
      args: SelectSubset<T, provider_keysUpdateArgs>
    ): Prisma__provider_keysClient<provider_keysGetPayload<T>>

    /**
     * Delete zero or more Provider_keys.
     * @param {provider_keysDeleteManyArgs} args - Arguments to filter Provider_keys to delete.
     * @example
     * // Delete a few Provider_keys
     * const { count } = await prisma.provider_keys.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends provider_keysDeleteManyArgs>(
      args?: SelectSubset<T, provider_keysDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Provider_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_keysUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Provider_keys
     * const provider_keys = await prisma.provider_keys.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends provider_keysUpdateManyArgs>(
      args: SelectSubset<T, provider_keysUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Provider_keys.
     * @param {provider_keysUpsertArgs} args - Arguments to update or create a Provider_keys.
     * @example
     * // Update or create a Provider_keys
     * const provider_keys = await prisma.provider_keys.upsert({
     *   create: {
     *     // ... data to create a Provider_keys
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Provider_keys we want to update
     *   }
     * })
    **/
    upsert<T extends provider_keysUpsertArgs>(
      args: SelectSubset<T, provider_keysUpsertArgs>
    ): Prisma__provider_keysClient<provider_keysGetPayload<T>>

    /**
     * Find zero or more Provider_keys that matches the filter.
     * @param {provider_keysFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const provider_keys = await prisma.provider_keys.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: provider_keysFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Provider_keys.
     * @param {provider_keysAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const provider_keys = await prisma.provider_keys.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: provider_keysAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Provider_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_keysCountArgs} args - Arguments to filter Provider_keys to count.
     * @example
     * // Count the number of Provider_keys
     * const count = await prisma.provider_keys.count({
     *   where: {
     *     // ... the filter for the Provider_keys we want to count
     *   }
     * })
    **/
    count<T extends provider_keysCountArgs>(
      args?: Subset<T, provider_keysCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Provider_keysCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Provider_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Provider_keysAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Provider_keysAggregateArgs>(args: Subset<T, Provider_keysAggregateArgs>): Prisma.PrismaPromise<GetProvider_keysAggregateType<T>>

    /**
     * Group by Provider_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Provider_keysGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Provider_keysGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Provider_keysGroupByArgs['orderBy'] }
        : { orderBy?: Provider_keysGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Provider_keysGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProvider_keysGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for provider_keys.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__provider_keysClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    provider<T extends providersArgs= {}>(args?: Subset<T, providersArgs>): Prisma__providersClient<providersGetPayload<T> | Null>;

    platforms<T extends provider_keys$platformsArgs= {}>(args?: Subset<T, provider_keys$platformsArgs>): Prisma.PrismaPromise<Array<platformsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * provider_keys base type for findUnique actions
   */
  export type provider_keysFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the provider_keys
     */
    select?: provider_keysSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: provider_keysInclude | null
    /**
     * Filter, which provider_keys to fetch.
     */
    where: provider_keysWhereUniqueInput
  }

  /**
   * provider_keys findUnique
   */
  export interface provider_keysFindUniqueArgs extends provider_keysFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * provider_keys findUniqueOrThrow
   */
  export type provider_keysFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the provider_keys
     */
    select?: provider_keysSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: provider_keysInclude | null
    /**
     * Filter, which provider_keys to fetch.
     */
    where: provider_keysWhereUniqueInput
  }


  /**
   * provider_keys base type for findFirst actions
   */
  export type provider_keysFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the provider_keys
     */
    select?: provider_keysSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: provider_keysInclude | null
    /**
     * Filter, which provider_keys to fetch.
     */
    where?: provider_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provider_keys to fetch.
     */
    orderBy?: Enumerable<provider_keysOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for provider_keys.
     */
    cursor?: provider_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provider_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provider_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of provider_keys.
     */
    distinct?: Enumerable<Provider_keysScalarFieldEnum>
  }

  /**
   * provider_keys findFirst
   */
  export interface provider_keysFindFirstArgs extends provider_keysFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * provider_keys findFirstOrThrow
   */
  export type provider_keysFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the provider_keys
     */
    select?: provider_keysSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: provider_keysInclude | null
    /**
     * Filter, which provider_keys to fetch.
     */
    where?: provider_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provider_keys to fetch.
     */
    orderBy?: Enumerable<provider_keysOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for provider_keys.
     */
    cursor?: provider_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provider_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provider_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of provider_keys.
     */
    distinct?: Enumerable<Provider_keysScalarFieldEnum>
  }


  /**
   * provider_keys findMany
   */
  export type provider_keysFindManyArgs = {
    /**
     * Select specific fields to fetch from the provider_keys
     */
    select?: provider_keysSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: provider_keysInclude | null
    /**
     * Filter, which provider_keys to fetch.
     */
    where?: provider_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provider_keys to fetch.
     */
    orderBy?: Enumerable<provider_keysOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing provider_keys.
     */
    cursor?: provider_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provider_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provider_keys.
     */
    skip?: number
    distinct?: Enumerable<Provider_keysScalarFieldEnum>
  }


  /**
   * provider_keys create
   */
  export type provider_keysCreateArgs = {
    /**
     * Select specific fields to fetch from the provider_keys
     */
    select?: provider_keysSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: provider_keysInclude | null
    /**
     * The data needed to create a provider_keys.
     */
    data: XOR<provider_keysCreateInput, provider_keysUncheckedCreateInput>
  }


  /**
   * provider_keys createMany
   */
  export type provider_keysCreateManyArgs = {
    /**
     * The data used to create many provider_keys.
     */
    data: Enumerable<provider_keysCreateManyInput>
  }


  /**
   * provider_keys update
   */
  export type provider_keysUpdateArgs = {
    /**
     * Select specific fields to fetch from the provider_keys
     */
    select?: provider_keysSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: provider_keysInclude | null
    /**
     * The data needed to update a provider_keys.
     */
    data: XOR<provider_keysUpdateInput, provider_keysUncheckedUpdateInput>
    /**
     * Choose, which provider_keys to update.
     */
    where: provider_keysWhereUniqueInput
  }


  /**
   * provider_keys updateMany
   */
  export type provider_keysUpdateManyArgs = {
    /**
     * The data used to update provider_keys.
     */
    data: XOR<provider_keysUpdateManyMutationInput, provider_keysUncheckedUpdateManyInput>
    /**
     * Filter which provider_keys to update
     */
    where?: provider_keysWhereInput
  }


  /**
   * provider_keys upsert
   */
  export type provider_keysUpsertArgs = {
    /**
     * Select specific fields to fetch from the provider_keys
     */
    select?: provider_keysSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: provider_keysInclude | null
    /**
     * The filter to search for the provider_keys to update in case it exists.
     */
    where: provider_keysWhereUniqueInput
    /**
     * In case the provider_keys found by the `where` argument doesn't exist, create a new provider_keys with this data.
     */
    create: XOR<provider_keysCreateInput, provider_keysUncheckedCreateInput>
    /**
     * In case the provider_keys was found with the provided `where` argument, update it with this data.
     */
    update: XOR<provider_keysUpdateInput, provider_keysUncheckedUpdateInput>
  }


  /**
   * provider_keys delete
   */
  export type provider_keysDeleteArgs = {
    /**
     * Select specific fields to fetch from the provider_keys
     */
    select?: provider_keysSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: provider_keysInclude | null
    /**
     * Filter which provider_keys to delete.
     */
    where: provider_keysWhereUniqueInput
  }


  /**
   * provider_keys deleteMany
   */
  export type provider_keysDeleteManyArgs = {
    /**
     * Filter which provider_keys to delete
     */
    where?: provider_keysWhereInput
  }


  /**
   * provider_keys findRaw
   */
  export type provider_keysFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * provider_keys aggregateRaw
   */
  export type provider_keysAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * provider_keys.platforms
   */
  export type provider_keys$platformsArgs = {
    /**
     * Select specific fields to fetch from the platforms
     */
    select?: platformsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: platformsInclude | null
    where?: platformsWhereInput
    orderBy?: Enumerable<platformsOrderByWithRelationInput>
    cursor?: platformsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PlatformsScalarFieldEnum>
  }


  /**
   * provider_keys without action
   */
  export type provider_keysArgs = {
    /**
     * Select specific fields to fetch from the provider_keys
     */
    select?: provider_keysSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: provider_keysInclude | null
  }



  /**
   * Model users
   */


  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
    username: string | null
    email: string | null
    phone: string | null
    name: string | null
    birthDate: Date | null
    gender: GenderType | null
    image_id: string | null
    prefered_location_id: string | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
    username: string | null
    email: string | null
    phone: string | null
    name: string | null
    birthDate: Date | null
    gender: GenderType | null
    image_id: string | null
    prefered_location_id: string | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    uuid: number
    username: number
    email: number
    phone: number
    name: number
    birthDate: number
    gender: number
    image_id: number
    prefered_location_id: number
    location_ids: number
    platform_ids: number
    organization_ids: number
    store_ids: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    username?: true
    email?: true
    phone?: true
    name?: true
    birthDate?: true
    gender?: true
    image_id?: true
    prefered_location_id?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    username?: true
    email?: true
    phone?: true
    name?: true
    birthDate?: true
    gender?: true
    image_id?: true
    prefered_location_id?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    username?: true
    email?: true
    phone?: true
    name?: true
    birthDate?: true
    gender?: true
    image_id?: true
    prefered_location_id?: true
    location_ids?: true
    platform_ids?: true
    organization_ids?: true
    store_ids?: true
    _all?: true
  }

  export type UsersAggregateArgs = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs = {
    where?: usersWhereInput
    orderBy?: Enumerable<usersOrderByWithAggregationInput>
    by: UsersScalarFieldEnum[]
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }


  export type UsersGroupByOutputType = {
    id: string
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string
    username: string | null
    email: string | null
    phone: string | null
    name: string | null
    birthDate: Date | null
    gender: GenderType | null
    image_id: string | null
    prefered_location_id: string | null
    location_ids: string[]
    platform_ids: string[]
    organization_ids: string[]
    store_ids: string[]
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uuid?: boolean
    username?: boolean
    email?: boolean
    phone?: boolean
    name?: boolean
    birthDate?: boolean
    gender?: boolean
    image_id?: boolean
    prefered_location_id?: boolean
    location_ids?: boolean
    platform_ids?: boolean
    organization_ids?: boolean
    store_ids?: boolean
    image?: boolean | imagesArgs
    prefered_location?: boolean | locationsArgs
    locations?: boolean | users$locationsArgs
    platforms?: boolean | users$platformsArgs
    organizations?: boolean | users$organizationsArgs
    stores?: boolean | users$storesArgs
    payments_created?: boolean | users$payments_createdArgs
    payments_confirmed?: boolean | users$payments_confirmedArgs
    session?: boolean | users$sessionArgs
    _count?: boolean | UsersCountOutputTypeArgs
  }


  export type usersInclude = {
    image?: boolean | imagesArgs
    prefered_location?: boolean | locationsArgs
    locations?: boolean | users$locationsArgs
    platforms?: boolean | users$platformsArgs
    organizations?: boolean | users$organizationsArgs
    stores?: boolean | users$storesArgs
    payments_created?: boolean | users$payments_createdArgs
    payments_confirmed?: boolean | users$payments_confirmedArgs
    session?: boolean | users$sessionArgs
    _count?: boolean | UsersCountOutputTypeArgs
  }

  export type usersGetPayload<S extends boolean | null | undefined | usersArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? users :
    S extends undefined ? never :
    S extends { include: any } & (usersArgs | usersFindManyArgs)
    ? users  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'image' ? imagesGetPayload<S['include'][P]> | null :
        P extends 'prefered_location' ? locationsGetPayload<S['include'][P]> | null :
        P extends 'locations' ? Array < locationsGetPayload<S['include'][P]>>  :
        P extends 'platforms' ? Array < platformsGetPayload<S['include'][P]>>  :
        P extends 'organizations' ? Array < organizationsGetPayload<S['include'][P]>>  :
        P extends 'stores' ? Array < storesGetPayload<S['include'][P]>>  :
        P extends 'payments_created' ? Array < paymentGetPayload<S['include'][P]>>  :
        P extends 'payments_confirmed' ? Array < paymentGetPayload<S['include'][P]>>  :
        P extends 'session' ? Array < sessionsGetPayload<S['include'][P]>>  :
        P extends '_count' ? UsersCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (usersArgs | usersFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'image' ? imagesGetPayload<S['select'][P]> | null :
        P extends 'prefered_location' ? locationsGetPayload<S['select'][P]> | null :
        P extends 'locations' ? Array < locationsGetPayload<S['select'][P]>>  :
        P extends 'platforms' ? Array < platformsGetPayload<S['select'][P]>>  :
        P extends 'organizations' ? Array < organizationsGetPayload<S['select'][P]>>  :
        P extends 'stores' ? Array < storesGetPayload<S['select'][P]>>  :
        P extends 'payments_created' ? Array < paymentGetPayload<S['select'][P]>>  :
        P extends 'payments_confirmed' ? Array < paymentGetPayload<S['select'][P]>>  :
        P extends 'session' ? Array < sessionsGetPayload<S['select'][P]>>  :
        P extends '_count' ? UsersCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof users ? users[P] : never
  } 
      : users


  type usersCountArgs = 
    Omit<usersFindManyArgs, 'select' | 'include'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, usersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'users'> extends True ? Prisma__usersClient<usersGetPayload<T>> : Prisma__usersClient<usersGetPayload<T> | null, null>

    /**
     * Find one Users that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, usersFindUniqueOrThrowArgs>
    ): Prisma__usersClient<usersGetPayload<T>>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, usersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'users'> extends True ? Prisma__usersClient<usersGetPayload<T>> : Prisma__usersClient<usersGetPayload<T> | null, null>

    /**
     * Find the first Users that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, usersFindFirstOrThrowArgs>
    ): Prisma__usersClient<usersGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends usersFindManyArgs>(
      args?: SelectSubset<T, usersFindManyArgs>
    ): Prisma.PrismaPromise<Array<usersGetPayload<T>>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
    **/
    create<T extends usersCreateArgs>(
      args: SelectSubset<T, usersCreateArgs>
    ): Prisma__usersClient<usersGetPayload<T>>

    /**
     * Create many Users.
     *     @param {usersCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const users = await prisma.users.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends usersCreateManyArgs>(
      args?: SelectSubset<T, usersCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
    **/
    delete<T extends usersDeleteArgs>(
      args: SelectSubset<T, usersDeleteArgs>
    ): Prisma__usersClient<usersGetPayload<T>>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usersUpdateArgs>(
      args: SelectSubset<T, usersUpdateArgs>
    ): Prisma__usersClient<usersGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usersDeleteManyArgs>(
      args?: SelectSubset<T, usersDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usersUpdateManyArgs>(
      args: SelectSubset<T, usersUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
    **/
    upsert<T extends usersUpsertArgs>(
      args: SelectSubset<T, usersUpsertArgs>
    ): Prisma__usersClient<usersGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * @param {usersFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const users = await prisma.users.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: usersFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Users.
     * @param {usersAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const users = await prisma.users.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: usersAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__usersClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    image<T extends imagesArgs= {}>(args?: Subset<T, imagesArgs>): Prisma__imagesClient<imagesGetPayload<T> | Null>;

    prefered_location<T extends locationsArgs= {}>(args?: Subset<T, locationsArgs>): Prisma__locationsClient<locationsGetPayload<T> | Null>;

    locations<T extends users$locationsArgs= {}>(args?: Subset<T, users$locationsArgs>): Prisma.PrismaPromise<Array<locationsGetPayload<T>>| Null>;

    platforms<T extends users$platformsArgs= {}>(args?: Subset<T, users$platformsArgs>): Prisma.PrismaPromise<Array<platformsGetPayload<T>>| Null>;

    organizations<T extends users$organizationsArgs= {}>(args?: Subset<T, users$organizationsArgs>): Prisma.PrismaPromise<Array<organizationsGetPayload<T>>| Null>;

    stores<T extends users$storesArgs= {}>(args?: Subset<T, users$storesArgs>): Prisma.PrismaPromise<Array<storesGetPayload<T>>| Null>;

    payments_created<T extends users$payments_createdArgs= {}>(args?: Subset<T, users$payments_createdArgs>): Prisma.PrismaPromise<Array<paymentGetPayload<T>>| Null>;

    payments_confirmed<T extends users$payments_confirmedArgs= {}>(args?: Subset<T, users$payments_confirmedArgs>): Prisma.PrismaPromise<Array<paymentGetPayload<T>>| Null>;

    session<T extends users$sessionArgs= {}>(args?: Subset<T, users$sessionArgs>): Prisma.PrismaPromise<Array<sessionsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * users base type for findUnique actions
   */
  export type usersFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUnique
   */
  export interface usersFindUniqueArgs extends usersFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users base type for findFirst actions
   */
  export type usersFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: Enumerable<UsersScalarFieldEnum>
  }

  /**
   * users findFirst
   */
  export interface usersFindFirstArgs extends usersFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * users findMany
   */
  export type usersFindManyArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * users create
   */
  export type usersCreateArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }


  /**
   * users createMany
   */
  export type usersCreateManyArgs = {
    /**
     * The data used to create many users.
     */
    data: Enumerable<usersCreateManyInput>
  }


  /**
   * users update
   */
  export type usersUpdateArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users updateMany
   */
  export type usersUpdateManyArgs = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
  }


  /**
   * users upsert
   */
  export type usersUpsertArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }


  /**
   * users delete
   */
  export type usersDeleteArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
  }


  /**
   * users findRaw
   */
  export type usersFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * users aggregateRaw
   */
  export type usersAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * users.locations
   */
  export type users$locationsArgs = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: locationsInclude | null
    where?: locationsWhereInput
    orderBy?: Enumerable<locationsOrderByWithRelationInput>
    cursor?: locationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LocationsScalarFieldEnum>
  }


  /**
   * users.platforms
   */
  export type users$platformsArgs = {
    /**
     * Select specific fields to fetch from the platforms
     */
    select?: platformsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: platformsInclude | null
    where?: platformsWhereInput
    orderBy?: Enumerable<platformsOrderByWithRelationInput>
    cursor?: platformsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PlatformsScalarFieldEnum>
  }


  /**
   * users.organizations
   */
  export type users$organizationsArgs = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude | null
    where?: organizationsWhereInput
    orderBy?: Enumerable<organizationsOrderByWithRelationInput>
    cursor?: organizationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OrganizationsScalarFieldEnum>
  }


  /**
   * users.stores
   */
  export type users$storesArgs = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: storesInclude | null
    where?: storesWhereInput
    orderBy?: Enumerable<storesOrderByWithRelationInput>
    cursor?: storesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<StoresScalarFieldEnum>
  }


  /**
   * users.payments_created
   */
  export type users$payments_createdArgs = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: paymentInclude | null
    where?: paymentWhereInput
    orderBy?: Enumerable<paymentOrderByWithRelationInput>
    cursor?: paymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * users.payments_confirmed
   */
  export type users$payments_confirmedArgs = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: paymentInclude | null
    where?: paymentWhereInput
    orderBy?: Enumerable<paymentOrderByWithRelationInput>
    cursor?: paymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * users.session
   */
  export type users$sessionArgs = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sessionsInclude | null
    where?: sessionsWhereInput
    orderBy?: Enumerable<sessionsOrderByWithRelationInput>
    cursor?: sessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SessionsScalarFieldEnum>
  }


  /**
   * users without action
   */
  export type usersArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
  }



  /**
   * Model organizations
   */


  export type AggregateOrganizations = {
    _count: OrganizationsCountAggregateOutputType | null
    _min: OrganizationsMinAggregateOutputType | null
    _max: OrganizationsMaxAggregateOutputType | null
  }

  export type OrganizationsMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
    username: string | null
    name: string | null
    image_id: string | null
  }

  export type OrganizationsMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
    username: string | null
    name: string | null
    image_id: string | null
  }

  export type OrganizationsCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    uuid: number
    username: number
    name: number
    image_id: number
    platform_ids: number
    user_ids: number
    location_ids: number
    _all: number
  }


  export type OrganizationsMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    username?: true
    name?: true
    image_id?: true
  }

  export type OrganizationsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    username?: true
    name?: true
    image_id?: true
  }

  export type OrganizationsCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    username?: true
    name?: true
    image_id?: true
    platform_ids?: true
    user_ids?: true
    location_ids?: true
    _all?: true
  }

  export type OrganizationsAggregateArgs = {
    /**
     * Filter which organizations to aggregate.
     */
    where?: organizationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizations to fetch.
     */
    orderBy?: Enumerable<organizationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: organizationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned organizations
    **/
    _count?: true | OrganizationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationsMaxAggregateInputType
  }

  export type GetOrganizationsAggregateType<T extends OrganizationsAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizations[P]>
      : GetScalarType<T[P], AggregateOrganizations[P]>
  }




  export type OrganizationsGroupByArgs = {
    where?: organizationsWhereInput
    orderBy?: Enumerable<organizationsOrderByWithAggregationInput>
    by: OrganizationsScalarFieldEnum[]
    having?: organizationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationsCountAggregateInputType | true
    _min?: OrganizationsMinAggregateInputType
    _max?: OrganizationsMaxAggregateInputType
  }


  export type OrganizationsGroupByOutputType = {
    id: string
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string
    username: string | null
    name: string | null
    image_id: string | null
    platform_ids: string[]
    user_ids: string[]
    location_ids: string[]
    _count: OrganizationsCountAggregateOutputType | null
    _min: OrganizationsMinAggregateOutputType | null
    _max: OrganizationsMaxAggregateOutputType | null
  }

  type GetOrganizationsGroupByPayload<T extends OrganizationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OrganizationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationsGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationsGroupByOutputType[P]>
        }
      >
    >


  export type organizationsSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uuid?: boolean
    username?: boolean
    name?: boolean
    image_id?: boolean
    platform_ids?: boolean
    user_ids?: boolean
    location_ids?: boolean
    image?: boolean | imagesArgs
    platforms?: boolean | organizations$platformsArgs
    users?: boolean | organizations$usersArgs
    locations?: boolean | organizations$locationsArgs
    _count?: boolean | OrganizationsCountOutputTypeArgs
  }


  export type organizationsInclude = {
    image?: boolean | imagesArgs
    platforms?: boolean | organizations$platformsArgs
    users?: boolean | organizations$usersArgs
    locations?: boolean | organizations$locationsArgs
    _count?: boolean | OrganizationsCountOutputTypeArgs
  }

  export type organizationsGetPayload<S extends boolean | null | undefined | organizationsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? organizations :
    S extends undefined ? never :
    S extends { include: any } & (organizationsArgs | organizationsFindManyArgs)
    ? organizations  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'image' ? imagesGetPayload<S['include'][P]> | null :
        P extends 'platforms' ? Array < platformsGetPayload<S['include'][P]>>  :
        P extends 'users' ? Array < usersGetPayload<S['include'][P]>>  :
        P extends 'locations' ? Array < locationsGetPayload<S['include'][P]>>  :
        P extends '_count' ? OrganizationsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (organizationsArgs | organizationsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'image' ? imagesGetPayload<S['select'][P]> | null :
        P extends 'platforms' ? Array < platformsGetPayload<S['select'][P]>>  :
        P extends 'users' ? Array < usersGetPayload<S['select'][P]>>  :
        P extends 'locations' ? Array < locationsGetPayload<S['select'][P]>>  :
        P extends '_count' ? OrganizationsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof organizations ? organizations[P] : never
  } 
      : organizations


  type organizationsCountArgs = 
    Omit<organizationsFindManyArgs, 'select' | 'include'> & {
      select?: OrganizationsCountAggregateInputType | true
    }

  export interface organizationsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Organizations that matches the filter.
     * @param {organizationsFindUniqueArgs} args - Arguments to find a Organizations
     * @example
     * // Get one Organizations
     * const organizations = await prisma.organizations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends organizationsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, organizationsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'organizations'> extends True ? Prisma__organizationsClient<organizationsGetPayload<T>> : Prisma__organizationsClient<organizationsGetPayload<T> | null, null>

    /**
     * Find one Organizations that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {organizationsFindUniqueOrThrowArgs} args - Arguments to find a Organizations
     * @example
     * // Get one Organizations
     * const organizations = await prisma.organizations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends organizationsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, organizationsFindUniqueOrThrowArgs>
    ): Prisma__organizationsClient<organizationsGetPayload<T>>

    /**
     * Find the first Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationsFindFirstArgs} args - Arguments to find a Organizations
     * @example
     * // Get one Organizations
     * const organizations = await prisma.organizations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends organizationsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, organizationsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'organizations'> extends True ? Prisma__organizationsClient<organizationsGetPayload<T>> : Prisma__organizationsClient<organizationsGetPayload<T> | null, null>

    /**
     * Find the first Organizations that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationsFindFirstOrThrowArgs} args - Arguments to find a Organizations
     * @example
     * // Get one Organizations
     * const organizations = await prisma.organizations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends organizationsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, organizationsFindFirstOrThrowArgs>
    ): Prisma__organizationsClient<organizationsGetPayload<T>>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organizations.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organizations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationsWithIdOnly = await prisma.organizations.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends organizationsFindManyArgs>(
      args?: SelectSubset<T, organizationsFindManyArgs>
    ): Prisma.PrismaPromise<Array<organizationsGetPayload<T>>>

    /**
     * Create a Organizations.
     * @param {organizationsCreateArgs} args - Arguments to create a Organizations.
     * @example
     * // Create one Organizations
     * const Organizations = await prisma.organizations.create({
     *   data: {
     *     // ... data to create a Organizations
     *   }
     * })
     * 
    **/
    create<T extends organizationsCreateArgs>(
      args: SelectSubset<T, organizationsCreateArgs>
    ): Prisma__organizationsClient<organizationsGetPayload<T>>

    /**
     * Create many Organizations.
     *     @param {organizationsCreateManyArgs} args - Arguments to create many Organizations.
     *     @example
     *     // Create many Organizations
     *     const organizations = await prisma.organizations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends organizationsCreateManyArgs>(
      args?: SelectSubset<T, organizationsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Organizations.
     * @param {organizationsDeleteArgs} args - Arguments to delete one Organizations.
     * @example
     * // Delete one Organizations
     * const Organizations = await prisma.organizations.delete({
     *   where: {
     *     // ... filter to delete one Organizations
     *   }
     * })
     * 
    **/
    delete<T extends organizationsDeleteArgs>(
      args: SelectSubset<T, organizationsDeleteArgs>
    ): Prisma__organizationsClient<organizationsGetPayload<T>>

    /**
     * Update one Organizations.
     * @param {organizationsUpdateArgs} args - Arguments to update one Organizations.
     * @example
     * // Update one Organizations
     * const organizations = await prisma.organizations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends organizationsUpdateArgs>(
      args: SelectSubset<T, organizationsUpdateArgs>
    ): Prisma__organizationsClient<organizationsGetPayload<T>>

    /**
     * Delete zero or more Organizations.
     * @param {organizationsDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organizations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends organizationsDeleteManyArgs>(
      args?: SelectSubset<T, organizationsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organizations = await prisma.organizations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends organizationsUpdateManyArgs>(
      args: SelectSubset<T, organizationsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Organizations.
     * @param {organizationsUpsertArgs} args - Arguments to update or create a Organizations.
     * @example
     * // Update or create a Organizations
     * const organizations = await prisma.organizations.upsert({
     *   create: {
     *     // ... data to create a Organizations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organizations we want to update
     *   }
     * })
    **/
    upsert<T extends organizationsUpsertArgs>(
      args: SelectSubset<T, organizationsUpsertArgs>
    ): Prisma__organizationsClient<organizationsGetPayload<T>>

    /**
     * Find zero or more Organizations that matches the filter.
     * @param {organizationsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const organizations = await prisma.organizations.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: organizationsFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Organizations.
     * @param {organizationsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const organizations = await prisma.organizations.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: organizationsAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationsCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organizations.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends organizationsCountArgs>(
      args?: Subset<T, organizationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationsAggregateArgs>(args: Subset<T, OrganizationsAggregateArgs>): Prisma.PrismaPromise<GetOrganizationsAggregateType<T>>

    /**
     * Group by Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationsGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for organizations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__organizationsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    image<T extends imagesArgs= {}>(args?: Subset<T, imagesArgs>): Prisma__imagesClient<imagesGetPayload<T> | Null>;

    platforms<T extends organizations$platformsArgs= {}>(args?: Subset<T, organizations$platformsArgs>): Prisma.PrismaPromise<Array<platformsGetPayload<T>>| Null>;

    users<T extends organizations$usersArgs= {}>(args?: Subset<T, organizations$usersArgs>): Prisma.PrismaPromise<Array<usersGetPayload<T>>| Null>;

    locations<T extends organizations$locationsArgs= {}>(args?: Subset<T, organizations$locationsArgs>): Prisma.PrismaPromise<Array<locationsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * organizations base type for findUnique actions
   */
  export type organizationsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude | null
    /**
     * Filter, which organizations to fetch.
     */
    where: organizationsWhereUniqueInput
  }

  /**
   * organizations findUnique
   */
  export interface organizationsFindUniqueArgs extends organizationsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * organizations findUniqueOrThrow
   */
  export type organizationsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude | null
    /**
     * Filter, which organizations to fetch.
     */
    where: organizationsWhereUniqueInput
  }


  /**
   * organizations base type for findFirst actions
   */
  export type organizationsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude | null
    /**
     * Filter, which organizations to fetch.
     */
    where?: organizationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizations to fetch.
     */
    orderBy?: Enumerable<organizationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for organizations.
     */
    cursor?: organizationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of organizations.
     */
    distinct?: Enumerable<OrganizationsScalarFieldEnum>
  }

  /**
   * organizations findFirst
   */
  export interface organizationsFindFirstArgs extends organizationsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * organizations findFirstOrThrow
   */
  export type organizationsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude | null
    /**
     * Filter, which organizations to fetch.
     */
    where?: organizationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizations to fetch.
     */
    orderBy?: Enumerable<organizationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for organizations.
     */
    cursor?: organizationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of organizations.
     */
    distinct?: Enumerable<OrganizationsScalarFieldEnum>
  }


  /**
   * organizations findMany
   */
  export type organizationsFindManyArgs = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude | null
    /**
     * Filter, which organizations to fetch.
     */
    where?: organizationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizations to fetch.
     */
    orderBy?: Enumerable<organizationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing organizations.
     */
    cursor?: organizationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizations.
     */
    skip?: number
    distinct?: Enumerable<OrganizationsScalarFieldEnum>
  }


  /**
   * organizations create
   */
  export type organizationsCreateArgs = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude | null
    /**
     * The data needed to create a organizations.
     */
    data: XOR<organizationsCreateInput, organizationsUncheckedCreateInput>
  }


  /**
   * organizations createMany
   */
  export type organizationsCreateManyArgs = {
    /**
     * The data used to create many organizations.
     */
    data: Enumerable<organizationsCreateManyInput>
  }


  /**
   * organizations update
   */
  export type organizationsUpdateArgs = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude | null
    /**
     * The data needed to update a organizations.
     */
    data: XOR<organizationsUpdateInput, organizationsUncheckedUpdateInput>
    /**
     * Choose, which organizations to update.
     */
    where: organizationsWhereUniqueInput
  }


  /**
   * organizations updateMany
   */
  export type organizationsUpdateManyArgs = {
    /**
     * The data used to update organizations.
     */
    data: XOR<organizationsUpdateManyMutationInput, organizationsUncheckedUpdateManyInput>
    /**
     * Filter which organizations to update
     */
    where?: organizationsWhereInput
  }


  /**
   * organizations upsert
   */
  export type organizationsUpsertArgs = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude | null
    /**
     * The filter to search for the organizations to update in case it exists.
     */
    where: organizationsWhereUniqueInput
    /**
     * In case the organizations found by the `where` argument doesn't exist, create a new organizations with this data.
     */
    create: XOR<organizationsCreateInput, organizationsUncheckedCreateInput>
    /**
     * In case the organizations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<organizationsUpdateInput, organizationsUncheckedUpdateInput>
  }


  /**
   * organizations delete
   */
  export type organizationsDeleteArgs = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude | null
    /**
     * Filter which organizations to delete.
     */
    where: organizationsWhereUniqueInput
  }


  /**
   * organizations deleteMany
   */
  export type organizationsDeleteManyArgs = {
    /**
     * Filter which organizations to delete
     */
    where?: organizationsWhereInput
  }


  /**
   * organizations findRaw
   */
  export type organizationsFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * organizations aggregateRaw
   */
  export type organizationsAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * organizations.platforms
   */
  export type organizations$platformsArgs = {
    /**
     * Select specific fields to fetch from the platforms
     */
    select?: platformsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: platformsInclude | null
    where?: platformsWhereInput
    orderBy?: Enumerable<platformsOrderByWithRelationInput>
    cursor?: platformsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PlatformsScalarFieldEnum>
  }


  /**
   * organizations.users
   */
  export type organizations$usersArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    where?: usersWhereInput
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * organizations.locations
   */
  export type organizations$locationsArgs = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: locationsInclude | null
    where?: locationsWhereInput
    orderBy?: Enumerable<locationsOrderByWithRelationInput>
    cursor?: locationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LocationsScalarFieldEnum>
  }


  /**
   * organizations without action
   */
  export type organizationsArgs = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude | null
  }



  /**
   * Model stores
   */


  export type AggregateStores = {
    _count: StoresCountAggregateOutputType | null
    _min: StoresMinAggregateOutputType | null
    _max: StoresMaxAggregateOutputType | null
  }

  export type StoresMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
    username: string | null
    name: string | null
    image_id: string | null
  }

  export type StoresMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
    username: string | null
    name: string | null
    image_id: string | null
  }

  export type StoresCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    uuid: number
    username: number
    name: number
    image_id: number
    user_ids: number
    location_ids: number
    inventory_ids: number
    _all: number
  }


  export type StoresMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    username?: true
    name?: true
    image_id?: true
  }

  export type StoresMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    username?: true
    name?: true
    image_id?: true
  }

  export type StoresCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    username?: true
    name?: true
    image_id?: true
    user_ids?: true
    location_ids?: true
    inventory_ids?: true
    _all?: true
  }

  export type StoresAggregateArgs = {
    /**
     * Filter which stores to aggregate.
     */
    where?: storesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stores to fetch.
     */
    orderBy?: Enumerable<storesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: storesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned stores
    **/
    _count?: true | StoresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoresMaxAggregateInputType
  }

  export type GetStoresAggregateType<T extends StoresAggregateArgs> = {
        [P in keyof T & keyof AggregateStores]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStores[P]>
      : GetScalarType<T[P], AggregateStores[P]>
  }




  export type StoresGroupByArgs = {
    where?: storesWhereInput
    orderBy?: Enumerable<storesOrderByWithAggregationInput>
    by: StoresScalarFieldEnum[]
    having?: storesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoresCountAggregateInputType | true
    _min?: StoresMinAggregateInputType
    _max?: StoresMaxAggregateInputType
  }


  export type StoresGroupByOutputType = {
    id: string
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string
    username: string | null
    name: string | null
    image_id: string | null
    user_ids: string[]
    location_ids: string[]
    inventory_ids: string[]
    _count: StoresCountAggregateOutputType | null
    _min: StoresMinAggregateOutputType | null
    _max: StoresMaxAggregateOutputType | null
  }

  type GetStoresGroupByPayload<T extends StoresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<StoresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoresGroupByOutputType[P]>
            : GetScalarType<T[P], StoresGroupByOutputType[P]>
        }
      >
    >


  export type storesSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uuid?: boolean
    username?: boolean
    name?: boolean
    image_id?: boolean
    user_ids?: boolean
    location_ids?: boolean
    inventory_ids?: boolean
    image?: boolean | imagesArgs
    users?: boolean | stores$usersArgs
    locations?: boolean | stores$locationsArgs
    inventories?: boolean | stores$inventoriesArgs
    _count?: boolean | StoresCountOutputTypeArgs
  }


  export type storesInclude = {
    image?: boolean | imagesArgs
    users?: boolean | stores$usersArgs
    locations?: boolean | stores$locationsArgs
    inventories?: boolean | stores$inventoriesArgs
    _count?: boolean | StoresCountOutputTypeArgs
  }

  export type storesGetPayload<S extends boolean | null | undefined | storesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? stores :
    S extends undefined ? never :
    S extends { include: any } & (storesArgs | storesFindManyArgs)
    ? stores  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'image' ? imagesGetPayload<S['include'][P]> | null :
        P extends 'users' ? Array < usersGetPayload<S['include'][P]>>  :
        P extends 'locations' ? Array < locationsGetPayload<S['include'][P]>>  :
        P extends 'inventories' ? Array < inventoriesGetPayload<S['include'][P]>>  :
        P extends '_count' ? StoresCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (storesArgs | storesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'image' ? imagesGetPayload<S['select'][P]> | null :
        P extends 'users' ? Array < usersGetPayload<S['select'][P]>>  :
        P extends 'locations' ? Array < locationsGetPayload<S['select'][P]>>  :
        P extends 'inventories' ? Array < inventoriesGetPayload<S['select'][P]>>  :
        P extends '_count' ? StoresCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof stores ? stores[P] : never
  } 
      : stores


  type storesCountArgs = 
    Omit<storesFindManyArgs, 'select' | 'include'> & {
      select?: StoresCountAggregateInputType | true
    }

  export interface storesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Stores that matches the filter.
     * @param {storesFindUniqueArgs} args - Arguments to find a Stores
     * @example
     * // Get one Stores
     * const stores = await prisma.stores.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends storesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, storesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'stores'> extends True ? Prisma__storesClient<storesGetPayload<T>> : Prisma__storesClient<storesGetPayload<T> | null, null>

    /**
     * Find one Stores that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {storesFindUniqueOrThrowArgs} args - Arguments to find a Stores
     * @example
     * // Get one Stores
     * const stores = await prisma.stores.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends storesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, storesFindUniqueOrThrowArgs>
    ): Prisma__storesClient<storesGetPayload<T>>

    /**
     * Find the first Stores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storesFindFirstArgs} args - Arguments to find a Stores
     * @example
     * // Get one Stores
     * const stores = await prisma.stores.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends storesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, storesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'stores'> extends True ? Prisma__storesClient<storesGetPayload<T>> : Prisma__storesClient<storesGetPayload<T> | null, null>

    /**
     * Find the first Stores that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storesFindFirstOrThrowArgs} args - Arguments to find a Stores
     * @example
     * // Get one Stores
     * const stores = await prisma.stores.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends storesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, storesFindFirstOrThrowArgs>
    ): Prisma__storesClient<storesGetPayload<T>>

    /**
     * Find zero or more Stores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stores
     * const stores = await prisma.stores.findMany()
     * 
     * // Get first 10 Stores
     * const stores = await prisma.stores.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storesWithIdOnly = await prisma.stores.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends storesFindManyArgs>(
      args?: SelectSubset<T, storesFindManyArgs>
    ): Prisma.PrismaPromise<Array<storesGetPayload<T>>>

    /**
     * Create a Stores.
     * @param {storesCreateArgs} args - Arguments to create a Stores.
     * @example
     * // Create one Stores
     * const Stores = await prisma.stores.create({
     *   data: {
     *     // ... data to create a Stores
     *   }
     * })
     * 
    **/
    create<T extends storesCreateArgs>(
      args: SelectSubset<T, storesCreateArgs>
    ): Prisma__storesClient<storesGetPayload<T>>

    /**
     * Create many Stores.
     *     @param {storesCreateManyArgs} args - Arguments to create many Stores.
     *     @example
     *     // Create many Stores
     *     const stores = await prisma.stores.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends storesCreateManyArgs>(
      args?: SelectSubset<T, storesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Stores.
     * @param {storesDeleteArgs} args - Arguments to delete one Stores.
     * @example
     * // Delete one Stores
     * const Stores = await prisma.stores.delete({
     *   where: {
     *     // ... filter to delete one Stores
     *   }
     * })
     * 
    **/
    delete<T extends storesDeleteArgs>(
      args: SelectSubset<T, storesDeleteArgs>
    ): Prisma__storesClient<storesGetPayload<T>>

    /**
     * Update one Stores.
     * @param {storesUpdateArgs} args - Arguments to update one Stores.
     * @example
     * // Update one Stores
     * const stores = await prisma.stores.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends storesUpdateArgs>(
      args: SelectSubset<T, storesUpdateArgs>
    ): Prisma__storesClient<storesGetPayload<T>>

    /**
     * Delete zero or more Stores.
     * @param {storesDeleteManyArgs} args - Arguments to filter Stores to delete.
     * @example
     * // Delete a few Stores
     * const { count } = await prisma.stores.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends storesDeleteManyArgs>(
      args?: SelectSubset<T, storesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stores
     * const stores = await prisma.stores.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends storesUpdateManyArgs>(
      args: SelectSubset<T, storesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Stores.
     * @param {storesUpsertArgs} args - Arguments to update or create a Stores.
     * @example
     * // Update or create a Stores
     * const stores = await prisma.stores.upsert({
     *   create: {
     *     // ... data to create a Stores
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stores we want to update
     *   }
     * })
    **/
    upsert<T extends storesUpsertArgs>(
      args: SelectSubset<T, storesUpsertArgs>
    ): Prisma__storesClient<storesGetPayload<T>>

    /**
     * Find zero or more Stores that matches the filter.
     * @param {storesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const stores = await prisma.stores.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: storesFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Stores.
     * @param {storesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const stores = await prisma.stores.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: storesAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storesCountArgs} args - Arguments to filter Stores to count.
     * @example
     * // Count the number of Stores
     * const count = await prisma.stores.count({
     *   where: {
     *     // ... the filter for the Stores we want to count
     *   }
     * })
    **/
    count<T extends storesCountArgs>(
      args?: Subset<T, storesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoresAggregateArgs>(args: Subset<T, StoresAggregateArgs>): Prisma.PrismaPromise<GetStoresAggregateType<T>>

    /**
     * Group by Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoresGroupByArgs['orderBy'] }
        : { orderBy?: StoresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for stores.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__storesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    image<T extends imagesArgs= {}>(args?: Subset<T, imagesArgs>): Prisma__imagesClient<imagesGetPayload<T> | Null>;

    users<T extends stores$usersArgs= {}>(args?: Subset<T, stores$usersArgs>): Prisma.PrismaPromise<Array<usersGetPayload<T>>| Null>;

    locations<T extends stores$locationsArgs= {}>(args?: Subset<T, stores$locationsArgs>): Prisma.PrismaPromise<Array<locationsGetPayload<T>>| Null>;

    inventories<T extends stores$inventoriesArgs= {}>(args?: Subset<T, stores$inventoriesArgs>): Prisma.PrismaPromise<Array<inventoriesGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * stores base type for findUnique actions
   */
  export type storesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: storesInclude | null
    /**
     * Filter, which stores to fetch.
     */
    where: storesWhereUniqueInput
  }

  /**
   * stores findUnique
   */
  export interface storesFindUniqueArgs extends storesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * stores findUniqueOrThrow
   */
  export type storesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: storesInclude | null
    /**
     * Filter, which stores to fetch.
     */
    where: storesWhereUniqueInput
  }


  /**
   * stores base type for findFirst actions
   */
  export type storesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: storesInclude | null
    /**
     * Filter, which stores to fetch.
     */
    where?: storesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stores to fetch.
     */
    orderBy?: Enumerable<storesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stores.
     */
    cursor?: storesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stores.
     */
    distinct?: Enumerable<StoresScalarFieldEnum>
  }

  /**
   * stores findFirst
   */
  export interface storesFindFirstArgs extends storesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * stores findFirstOrThrow
   */
  export type storesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: storesInclude | null
    /**
     * Filter, which stores to fetch.
     */
    where?: storesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stores to fetch.
     */
    orderBy?: Enumerable<storesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stores.
     */
    cursor?: storesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stores.
     */
    distinct?: Enumerable<StoresScalarFieldEnum>
  }


  /**
   * stores findMany
   */
  export type storesFindManyArgs = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: storesInclude | null
    /**
     * Filter, which stores to fetch.
     */
    where?: storesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stores to fetch.
     */
    orderBy?: Enumerable<storesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing stores.
     */
    cursor?: storesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stores.
     */
    skip?: number
    distinct?: Enumerable<StoresScalarFieldEnum>
  }


  /**
   * stores create
   */
  export type storesCreateArgs = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: storesInclude | null
    /**
     * The data needed to create a stores.
     */
    data: XOR<storesCreateInput, storesUncheckedCreateInput>
  }


  /**
   * stores createMany
   */
  export type storesCreateManyArgs = {
    /**
     * The data used to create many stores.
     */
    data: Enumerable<storesCreateManyInput>
  }


  /**
   * stores update
   */
  export type storesUpdateArgs = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: storesInclude | null
    /**
     * The data needed to update a stores.
     */
    data: XOR<storesUpdateInput, storesUncheckedUpdateInput>
    /**
     * Choose, which stores to update.
     */
    where: storesWhereUniqueInput
  }


  /**
   * stores updateMany
   */
  export type storesUpdateManyArgs = {
    /**
     * The data used to update stores.
     */
    data: XOR<storesUpdateManyMutationInput, storesUncheckedUpdateManyInput>
    /**
     * Filter which stores to update
     */
    where?: storesWhereInput
  }


  /**
   * stores upsert
   */
  export type storesUpsertArgs = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: storesInclude | null
    /**
     * The filter to search for the stores to update in case it exists.
     */
    where: storesWhereUniqueInput
    /**
     * In case the stores found by the `where` argument doesn't exist, create a new stores with this data.
     */
    create: XOR<storesCreateInput, storesUncheckedCreateInput>
    /**
     * In case the stores was found with the provided `where` argument, update it with this data.
     */
    update: XOR<storesUpdateInput, storesUncheckedUpdateInput>
  }


  /**
   * stores delete
   */
  export type storesDeleteArgs = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: storesInclude | null
    /**
     * Filter which stores to delete.
     */
    where: storesWhereUniqueInput
  }


  /**
   * stores deleteMany
   */
  export type storesDeleteManyArgs = {
    /**
     * Filter which stores to delete
     */
    where?: storesWhereInput
  }


  /**
   * stores findRaw
   */
  export type storesFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * stores aggregateRaw
   */
  export type storesAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * stores.users
   */
  export type stores$usersArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    where?: usersWhereInput
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * stores.locations
   */
  export type stores$locationsArgs = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: locationsInclude | null
    where?: locationsWhereInput
    orderBy?: Enumerable<locationsOrderByWithRelationInput>
    cursor?: locationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LocationsScalarFieldEnum>
  }


  /**
   * stores.inventories
   */
  export type stores$inventoriesArgs = {
    /**
     * Select specific fields to fetch from the inventories
     */
    select?: inventoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inventoriesInclude | null
    where?: inventoriesWhereInput
    orderBy?: Enumerable<inventoriesOrderByWithRelationInput>
    cursor?: inventoriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InventoriesScalarFieldEnum>
  }


  /**
   * stores without action
   */
  export type storesArgs = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: storesInclude | null
  }



  /**
   * Model inventories
   */


  export type AggregateInventories = {
    _count: InventoriesCountAggregateOutputType | null
    _min: InventoriesMinAggregateOutputType | null
    _max: InventoriesMaxAggregateOutputType | null
  }

  export type InventoriesMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
    name: string | null
    description: string | null
  }

  export type InventoriesMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
    name: string | null
    description: string | null
  }

  export type InventoriesCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    uuid: number
    name: number
    description: number
    item_iventory_ids: number
    store_ids: number
    _all: number
  }


  export type InventoriesMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    name?: true
    description?: true
  }

  export type InventoriesMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    name?: true
    description?: true
  }

  export type InventoriesCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    name?: true
    description?: true
    item_iventory_ids?: true
    store_ids?: true
    _all?: true
  }

  export type InventoriesAggregateArgs = {
    /**
     * Filter which inventories to aggregate.
     */
    where?: inventoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventories to fetch.
     */
    orderBy?: Enumerable<inventoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inventoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inventories
    **/
    _count?: true | InventoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoriesMaxAggregateInputType
  }

  export type GetInventoriesAggregateType<T extends InventoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateInventories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventories[P]>
      : GetScalarType<T[P], AggregateInventories[P]>
  }




  export type InventoriesGroupByArgs = {
    where?: inventoriesWhereInput
    orderBy?: Enumerable<inventoriesOrderByWithAggregationInput>
    by: InventoriesScalarFieldEnum[]
    having?: inventoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoriesCountAggregateInputType | true
    _min?: InventoriesMinAggregateInputType
    _max?: InventoriesMaxAggregateInputType
  }


  export type InventoriesGroupByOutputType = {
    id: string
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string
    name: string | null
    description: string | null
    item_iventory_ids: string[]
    store_ids: string[]
    _count: InventoriesCountAggregateOutputType | null
    _min: InventoriesMinAggregateOutputType | null
    _max: InventoriesMaxAggregateOutputType | null
  }

  type GetInventoriesGroupByPayload<T extends InventoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<InventoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoriesGroupByOutputType[P]>
            : GetScalarType<T[P], InventoriesGroupByOutputType[P]>
        }
      >
    >


  export type inventoriesSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    item_iventory_ids?: boolean
    store_ids?: boolean
    item_inventories?: boolean | inventories$item_inventoriesArgs
    stores?: boolean | inventories$storesArgs
    _count?: boolean | InventoriesCountOutputTypeArgs
  }


  export type inventoriesInclude = {
    item_inventories?: boolean | inventories$item_inventoriesArgs
    stores?: boolean | inventories$storesArgs
    _count?: boolean | InventoriesCountOutputTypeArgs
  }

  export type inventoriesGetPayload<S extends boolean | null | undefined | inventoriesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? inventories :
    S extends undefined ? never :
    S extends { include: any } & (inventoriesArgs | inventoriesFindManyArgs)
    ? inventories  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'item_inventories' ? Array < item_inventoriesGetPayload<S['include'][P]>>  :
        P extends 'stores' ? Array < storesGetPayload<S['include'][P]>>  :
        P extends '_count' ? InventoriesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (inventoriesArgs | inventoriesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'item_inventories' ? Array < item_inventoriesGetPayload<S['select'][P]>>  :
        P extends 'stores' ? Array < storesGetPayload<S['select'][P]>>  :
        P extends '_count' ? InventoriesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof inventories ? inventories[P] : never
  } 
      : inventories


  type inventoriesCountArgs = 
    Omit<inventoriesFindManyArgs, 'select' | 'include'> & {
      select?: InventoriesCountAggregateInputType | true
    }

  export interface inventoriesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Inventories that matches the filter.
     * @param {inventoriesFindUniqueArgs} args - Arguments to find a Inventories
     * @example
     * // Get one Inventories
     * const inventories = await prisma.inventories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inventoriesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, inventoriesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'inventories'> extends True ? Prisma__inventoriesClient<inventoriesGetPayload<T>> : Prisma__inventoriesClient<inventoriesGetPayload<T> | null, null>

    /**
     * Find one Inventories that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {inventoriesFindUniqueOrThrowArgs} args - Arguments to find a Inventories
     * @example
     * // Get one Inventories
     * const inventories = await prisma.inventories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inventoriesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, inventoriesFindUniqueOrThrowArgs>
    ): Prisma__inventoriesClient<inventoriesGetPayload<T>>

    /**
     * Find the first Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoriesFindFirstArgs} args - Arguments to find a Inventories
     * @example
     * // Get one Inventories
     * const inventories = await prisma.inventories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inventoriesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, inventoriesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'inventories'> extends True ? Prisma__inventoriesClient<inventoriesGetPayload<T>> : Prisma__inventoriesClient<inventoriesGetPayload<T> | null, null>

    /**
     * Find the first Inventories that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoriesFindFirstOrThrowArgs} args - Arguments to find a Inventories
     * @example
     * // Get one Inventories
     * const inventories = await prisma.inventories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inventoriesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, inventoriesFindFirstOrThrowArgs>
    ): Prisma__inventoriesClient<inventoriesGetPayload<T>>

    /**
     * Find zero or more Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventories
     * const inventories = await prisma.inventories.findMany()
     * 
     * // Get first 10 Inventories
     * const inventories = await prisma.inventories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoriesWithIdOnly = await prisma.inventories.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends inventoriesFindManyArgs>(
      args?: SelectSubset<T, inventoriesFindManyArgs>
    ): Prisma.PrismaPromise<Array<inventoriesGetPayload<T>>>

    /**
     * Create a Inventories.
     * @param {inventoriesCreateArgs} args - Arguments to create a Inventories.
     * @example
     * // Create one Inventories
     * const Inventories = await prisma.inventories.create({
     *   data: {
     *     // ... data to create a Inventories
     *   }
     * })
     * 
    **/
    create<T extends inventoriesCreateArgs>(
      args: SelectSubset<T, inventoriesCreateArgs>
    ): Prisma__inventoriesClient<inventoriesGetPayload<T>>

    /**
     * Create many Inventories.
     *     @param {inventoriesCreateManyArgs} args - Arguments to create many Inventories.
     *     @example
     *     // Create many Inventories
     *     const inventories = await prisma.inventories.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inventoriesCreateManyArgs>(
      args?: SelectSubset<T, inventoriesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inventories.
     * @param {inventoriesDeleteArgs} args - Arguments to delete one Inventories.
     * @example
     * // Delete one Inventories
     * const Inventories = await prisma.inventories.delete({
     *   where: {
     *     // ... filter to delete one Inventories
     *   }
     * })
     * 
    **/
    delete<T extends inventoriesDeleteArgs>(
      args: SelectSubset<T, inventoriesDeleteArgs>
    ): Prisma__inventoriesClient<inventoriesGetPayload<T>>

    /**
     * Update one Inventories.
     * @param {inventoriesUpdateArgs} args - Arguments to update one Inventories.
     * @example
     * // Update one Inventories
     * const inventories = await prisma.inventories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inventoriesUpdateArgs>(
      args: SelectSubset<T, inventoriesUpdateArgs>
    ): Prisma__inventoriesClient<inventoriesGetPayload<T>>

    /**
     * Delete zero or more Inventories.
     * @param {inventoriesDeleteManyArgs} args - Arguments to filter Inventories to delete.
     * @example
     * // Delete a few Inventories
     * const { count } = await prisma.inventories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inventoriesDeleteManyArgs>(
      args?: SelectSubset<T, inventoriesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventories
     * const inventories = await prisma.inventories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inventoriesUpdateManyArgs>(
      args: SelectSubset<T, inventoriesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inventories.
     * @param {inventoriesUpsertArgs} args - Arguments to update or create a Inventories.
     * @example
     * // Update or create a Inventories
     * const inventories = await prisma.inventories.upsert({
     *   create: {
     *     // ... data to create a Inventories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventories we want to update
     *   }
     * })
    **/
    upsert<T extends inventoriesUpsertArgs>(
      args: SelectSubset<T, inventoriesUpsertArgs>
    ): Prisma__inventoriesClient<inventoriesGetPayload<T>>

    /**
     * Find zero or more Inventories that matches the filter.
     * @param {inventoriesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const inventories = await prisma.inventories.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: inventoriesFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Inventories.
     * @param {inventoriesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const inventories = await prisma.inventories.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: inventoriesAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoriesCountArgs} args - Arguments to filter Inventories to count.
     * @example
     * // Count the number of Inventories
     * const count = await prisma.inventories.count({
     *   where: {
     *     // ... the filter for the Inventories we want to count
     *   }
     * })
    **/
    count<T extends inventoriesCountArgs>(
      args?: Subset<T, inventoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoriesAggregateArgs>(args: Subset<T, InventoriesAggregateArgs>): Prisma.PrismaPromise<GetInventoriesAggregateType<T>>

    /**
     * Group by Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoriesGroupByArgs['orderBy'] }
        : { orderBy?: InventoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for inventories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__inventoriesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    item_inventories<T extends inventories$item_inventoriesArgs= {}>(args?: Subset<T, inventories$item_inventoriesArgs>): Prisma.PrismaPromise<Array<item_inventoriesGetPayload<T>>| Null>;

    stores<T extends inventories$storesArgs= {}>(args?: Subset<T, inventories$storesArgs>): Prisma.PrismaPromise<Array<storesGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * inventories base type for findUnique actions
   */
  export type inventoriesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the inventories
     */
    select?: inventoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inventoriesInclude | null
    /**
     * Filter, which inventories to fetch.
     */
    where: inventoriesWhereUniqueInput
  }

  /**
   * inventories findUnique
   */
  export interface inventoriesFindUniqueArgs extends inventoriesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * inventories findUniqueOrThrow
   */
  export type inventoriesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the inventories
     */
    select?: inventoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inventoriesInclude | null
    /**
     * Filter, which inventories to fetch.
     */
    where: inventoriesWhereUniqueInput
  }


  /**
   * inventories base type for findFirst actions
   */
  export type inventoriesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the inventories
     */
    select?: inventoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inventoriesInclude | null
    /**
     * Filter, which inventories to fetch.
     */
    where?: inventoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventories to fetch.
     */
    orderBy?: Enumerable<inventoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inventories.
     */
    cursor?: inventoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inventories.
     */
    distinct?: Enumerable<InventoriesScalarFieldEnum>
  }

  /**
   * inventories findFirst
   */
  export interface inventoriesFindFirstArgs extends inventoriesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * inventories findFirstOrThrow
   */
  export type inventoriesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the inventories
     */
    select?: inventoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inventoriesInclude | null
    /**
     * Filter, which inventories to fetch.
     */
    where?: inventoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventories to fetch.
     */
    orderBy?: Enumerable<inventoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inventories.
     */
    cursor?: inventoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inventories.
     */
    distinct?: Enumerable<InventoriesScalarFieldEnum>
  }


  /**
   * inventories findMany
   */
  export type inventoriesFindManyArgs = {
    /**
     * Select specific fields to fetch from the inventories
     */
    select?: inventoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inventoriesInclude | null
    /**
     * Filter, which inventories to fetch.
     */
    where?: inventoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventories to fetch.
     */
    orderBy?: Enumerable<inventoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inventories.
     */
    cursor?: inventoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventories.
     */
    skip?: number
    distinct?: Enumerable<InventoriesScalarFieldEnum>
  }


  /**
   * inventories create
   */
  export type inventoriesCreateArgs = {
    /**
     * Select specific fields to fetch from the inventories
     */
    select?: inventoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inventoriesInclude | null
    /**
     * The data needed to create a inventories.
     */
    data: XOR<inventoriesCreateInput, inventoriesUncheckedCreateInput>
  }


  /**
   * inventories createMany
   */
  export type inventoriesCreateManyArgs = {
    /**
     * The data used to create many inventories.
     */
    data: Enumerable<inventoriesCreateManyInput>
  }


  /**
   * inventories update
   */
  export type inventoriesUpdateArgs = {
    /**
     * Select specific fields to fetch from the inventories
     */
    select?: inventoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inventoriesInclude | null
    /**
     * The data needed to update a inventories.
     */
    data: XOR<inventoriesUpdateInput, inventoriesUncheckedUpdateInput>
    /**
     * Choose, which inventories to update.
     */
    where: inventoriesWhereUniqueInput
  }


  /**
   * inventories updateMany
   */
  export type inventoriesUpdateManyArgs = {
    /**
     * The data used to update inventories.
     */
    data: XOR<inventoriesUpdateManyMutationInput, inventoriesUncheckedUpdateManyInput>
    /**
     * Filter which inventories to update
     */
    where?: inventoriesWhereInput
  }


  /**
   * inventories upsert
   */
  export type inventoriesUpsertArgs = {
    /**
     * Select specific fields to fetch from the inventories
     */
    select?: inventoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inventoriesInclude | null
    /**
     * The filter to search for the inventories to update in case it exists.
     */
    where: inventoriesWhereUniqueInput
    /**
     * In case the inventories found by the `where` argument doesn't exist, create a new inventories with this data.
     */
    create: XOR<inventoriesCreateInput, inventoriesUncheckedCreateInput>
    /**
     * In case the inventories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inventoriesUpdateInput, inventoriesUncheckedUpdateInput>
  }


  /**
   * inventories delete
   */
  export type inventoriesDeleteArgs = {
    /**
     * Select specific fields to fetch from the inventories
     */
    select?: inventoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inventoriesInclude | null
    /**
     * Filter which inventories to delete.
     */
    where: inventoriesWhereUniqueInput
  }


  /**
   * inventories deleteMany
   */
  export type inventoriesDeleteManyArgs = {
    /**
     * Filter which inventories to delete
     */
    where?: inventoriesWhereInput
  }


  /**
   * inventories findRaw
   */
  export type inventoriesFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * inventories aggregateRaw
   */
  export type inventoriesAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * inventories.item_inventories
   */
  export type inventories$item_inventoriesArgs = {
    /**
     * Select specific fields to fetch from the item_inventories
     */
    select?: item_inventoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: item_inventoriesInclude | null
    where?: item_inventoriesWhereInput
    orderBy?: Enumerable<item_inventoriesOrderByWithRelationInput>
    cursor?: item_inventoriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Item_inventoriesScalarFieldEnum>
  }


  /**
   * inventories.stores
   */
  export type inventories$storesArgs = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: storesInclude | null
    where?: storesWhereInput
    orderBy?: Enumerable<storesOrderByWithRelationInput>
    cursor?: storesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<StoresScalarFieldEnum>
  }


  /**
   * inventories without action
   */
  export type inventoriesArgs = {
    /**
     * Select specific fields to fetch from the inventories
     */
    select?: inventoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inventoriesInclude | null
  }



  /**
   * Model item_inventories
   */


  export type AggregateItem_inventories = {
    _count: Item_inventoriesCountAggregateOutputType | null
    _avg: Item_inventoriesAvgAggregateOutputType | null
    _sum: Item_inventoriesSumAggregateOutputType | null
    _min: Item_inventoriesMinAggregateOutputType | null
    _max: Item_inventoriesMaxAggregateOutputType | null
  }

  export type Item_inventoriesAvgAggregateOutputType = {
    value: number | null
  }

  export type Item_inventoriesSumAggregateOutputType = {
    value: number | null
  }

  export type Item_inventoriesMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
    item_id: string | null
    type: ItemQualitativeType | null
    value: number | null
  }

  export type Item_inventoriesMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
    item_id: string | null
    type: ItemQualitativeType | null
    value: number | null
  }

  export type Item_inventoriesCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    uuid: number
    item_id: number
    type: number
    value: number
    iventory_ids: number
    _all: number
  }


  export type Item_inventoriesAvgAggregateInputType = {
    value?: true
  }

  export type Item_inventoriesSumAggregateInputType = {
    value?: true
  }

  export type Item_inventoriesMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    item_id?: true
    type?: true
    value?: true
  }

  export type Item_inventoriesMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    item_id?: true
    type?: true
    value?: true
  }

  export type Item_inventoriesCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    item_id?: true
    type?: true
    value?: true
    iventory_ids?: true
    _all?: true
  }

  export type Item_inventoriesAggregateArgs = {
    /**
     * Filter which item_inventories to aggregate.
     */
    where?: item_inventoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of item_inventories to fetch.
     */
    orderBy?: Enumerable<item_inventoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: item_inventoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` item_inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` item_inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned item_inventories
    **/
    _count?: true | Item_inventoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Item_inventoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Item_inventoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Item_inventoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Item_inventoriesMaxAggregateInputType
  }

  export type GetItem_inventoriesAggregateType<T extends Item_inventoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateItem_inventories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem_inventories[P]>
      : GetScalarType<T[P], AggregateItem_inventories[P]>
  }




  export type Item_inventoriesGroupByArgs = {
    where?: item_inventoriesWhereInput
    orderBy?: Enumerable<item_inventoriesOrderByWithAggregationInput>
    by: Item_inventoriesScalarFieldEnum[]
    having?: item_inventoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Item_inventoriesCountAggregateInputType | true
    _avg?: Item_inventoriesAvgAggregateInputType
    _sum?: Item_inventoriesSumAggregateInputType
    _min?: Item_inventoriesMinAggregateInputType
    _max?: Item_inventoriesMaxAggregateInputType
  }


  export type Item_inventoriesGroupByOutputType = {
    id: string
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string
    item_id: string
    type: ItemQualitativeType
    value: number
    iventory_ids: string[]
    _count: Item_inventoriesCountAggregateOutputType | null
    _avg: Item_inventoriesAvgAggregateOutputType | null
    _sum: Item_inventoriesSumAggregateOutputType | null
    _min: Item_inventoriesMinAggregateOutputType | null
    _max: Item_inventoriesMaxAggregateOutputType | null
  }

  type GetItem_inventoriesGroupByPayload<T extends Item_inventoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Item_inventoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Item_inventoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Item_inventoriesGroupByOutputType[P]>
            : GetScalarType<T[P], Item_inventoriesGroupByOutputType[P]>
        }
      >
    >


  export type item_inventoriesSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uuid?: boolean
    item_id?: boolean
    type?: boolean
    value?: boolean
    iventory_ids?: boolean
    item?: boolean | itemsArgs
    inventories?: boolean | item_inventories$inventoriesArgs
    _count?: boolean | Item_inventoriesCountOutputTypeArgs
  }


  export type item_inventoriesInclude = {
    item?: boolean | itemsArgs
    inventories?: boolean | item_inventories$inventoriesArgs
    _count?: boolean | Item_inventoriesCountOutputTypeArgs
  }

  export type item_inventoriesGetPayload<S extends boolean | null | undefined | item_inventoriesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? item_inventories :
    S extends undefined ? never :
    S extends { include: any } & (item_inventoriesArgs | item_inventoriesFindManyArgs)
    ? item_inventories  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'item' ? itemsGetPayload<S['include'][P]> :
        P extends 'inventories' ? Array < inventoriesGetPayload<S['include'][P]>>  :
        P extends '_count' ? Item_inventoriesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (item_inventoriesArgs | item_inventoriesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'item' ? itemsGetPayload<S['select'][P]> :
        P extends 'inventories' ? Array < inventoriesGetPayload<S['select'][P]>>  :
        P extends '_count' ? Item_inventoriesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof item_inventories ? item_inventories[P] : never
  } 
      : item_inventories


  type item_inventoriesCountArgs = 
    Omit<item_inventoriesFindManyArgs, 'select' | 'include'> & {
      select?: Item_inventoriesCountAggregateInputType | true
    }

  export interface item_inventoriesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Item_inventories that matches the filter.
     * @param {item_inventoriesFindUniqueArgs} args - Arguments to find a Item_inventories
     * @example
     * // Get one Item_inventories
     * const item_inventories = await prisma.item_inventories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends item_inventoriesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, item_inventoriesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'item_inventories'> extends True ? Prisma__item_inventoriesClient<item_inventoriesGetPayload<T>> : Prisma__item_inventoriesClient<item_inventoriesGetPayload<T> | null, null>

    /**
     * Find one Item_inventories that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {item_inventoriesFindUniqueOrThrowArgs} args - Arguments to find a Item_inventories
     * @example
     * // Get one Item_inventories
     * const item_inventories = await prisma.item_inventories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends item_inventoriesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, item_inventoriesFindUniqueOrThrowArgs>
    ): Prisma__item_inventoriesClient<item_inventoriesGetPayload<T>>

    /**
     * Find the first Item_inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_inventoriesFindFirstArgs} args - Arguments to find a Item_inventories
     * @example
     * // Get one Item_inventories
     * const item_inventories = await prisma.item_inventories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends item_inventoriesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, item_inventoriesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'item_inventories'> extends True ? Prisma__item_inventoriesClient<item_inventoriesGetPayload<T>> : Prisma__item_inventoriesClient<item_inventoriesGetPayload<T> | null, null>

    /**
     * Find the first Item_inventories that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_inventoriesFindFirstOrThrowArgs} args - Arguments to find a Item_inventories
     * @example
     * // Get one Item_inventories
     * const item_inventories = await prisma.item_inventories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends item_inventoriesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, item_inventoriesFindFirstOrThrowArgs>
    ): Prisma__item_inventoriesClient<item_inventoriesGetPayload<T>>

    /**
     * Find zero or more Item_inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_inventoriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Item_inventories
     * const item_inventories = await prisma.item_inventories.findMany()
     * 
     * // Get first 10 Item_inventories
     * const item_inventories = await prisma.item_inventories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const item_inventoriesWithIdOnly = await prisma.item_inventories.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends item_inventoriesFindManyArgs>(
      args?: SelectSubset<T, item_inventoriesFindManyArgs>
    ): Prisma.PrismaPromise<Array<item_inventoriesGetPayload<T>>>

    /**
     * Create a Item_inventories.
     * @param {item_inventoriesCreateArgs} args - Arguments to create a Item_inventories.
     * @example
     * // Create one Item_inventories
     * const Item_inventories = await prisma.item_inventories.create({
     *   data: {
     *     // ... data to create a Item_inventories
     *   }
     * })
     * 
    **/
    create<T extends item_inventoriesCreateArgs>(
      args: SelectSubset<T, item_inventoriesCreateArgs>
    ): Prisma__item_inventoriesClient<item_inventoriesGetPayload<T>>

    /**
     * Create many Item_inventories.
     *     @param {item_inventoriesCreateManyArgs} args - Arguments to create many Item_inventories.
     *     @example
     *     // Create many Item_inventories
     *     const item_inventories = await prisma.item_inventories.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends item_inventoriesCreateManyArgs>(
      args?: SelectSubset<T, item_inventoriesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Item_inventories.
     * @param {item_inventoriesDeleteArgs} args - Arguments to delete one Item_inventories.
     * @example
     * // Delete one Item_inventories
     * const Item_inventories = await prisma.item_inventories.delete({
     *   where: {
     *     // ... filter to delete one Item_inventories
     *   }
     * })
     * 
    **/
    delete<T extends item_inventoriesDeleteArgs>(
      args: SelectSubset<T, item_inventoriesDeleteArgs>
    ): Prisma__item_inventoriesClient<item_inventoriesGetPayload<T>>

    /**
     * Update one Item_inventories.
     * @param {item_inventoriesUpdateArgs} args - Arguments to update one Item_inventories.
     * @example
     * // Update one Item_inventories
     * const item_inventories = await prisma.item_inventories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends item_inventoriesUpdateArgs>(
      args: SelectSubset<T, item_inventoriesUpdateArgs>
    ): Prisma__item_inventoriesClient<item_inventoriesGetPayload<T>>

    /**
     * Delete zero or more Item_inventories.
     * @param {item_inventoriesDeleteManyArgs} args - Arguments to filter Item_inventories to delete.
     * @example
     * // Delete a few Item_inventories
     * const { count } = await prisma.item_inventories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends item_inventoriesDeleteManyArgs>(
      args?: SelectSubset<T, item_inventoriesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Item_inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_inventoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Item_inventories
     * const item_inventories = await prisma.item_inventories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends item_inventoriesUpdateManyArgs>(
      args: SelectSubset<T, item_inventoriesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Item_inventories.
     * @param {item_inventoriesUpsertArgs} args - Arguments to update or create a Item_inventories.
     * @example
     * // Update or create a Item_inventories
     * const item_inventories = await prisma.item_inventories.upsert({
     *   create: {
     *     // ... data to create a Item_inventories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item_inventories we want to update
     *   }
     * })
    **/
    upsert<T extends item_inventoriesUpsertArgs>(
      args: SelectSubset<T, item_inventoriesUpsertArgs>
    ): Prisma__item_inventoriesClient<item_inventoriesGetPayload<T>>

    /**
     * Find zero or more Item_inventories that matches the filter.
     * @param {item_inventoriesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const item_inventories = await prisma.item_inventories.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: item_inventoriesFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Item_inventories.
     * @param {item_inventoriesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const item_inventories = await prisma.item_inventories.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: item_inventoriesAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Item_inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_inventoriesCountArgs} args - Arguments to filter Item_inventories to count.
     * @example
     * // Count the number of Item_inventories
     * const count = await prisma.item_inventories.count({
     *   where: {
     *     // ... the filter for the Item_inventories we want to count
     *   }
     * })
    **/
    count<T extends item_inventoriesCountArgs>(
      args?: Subset<T, item_inventoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Item_inventoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item_inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Item_inventoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Item_inventoriesAggregateArgs>(args: Subset<T, Item_inventoriesAggregateArgs>): Prisma.PrismaPromise<GetItem_inventoriesAggregateType<T>>

    /**
     * Group by Item_inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Item_inventoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Item_inventoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Item_inventoriesGroupByArgs['orderBy'] }
        : { orderBy?: Item_inventoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Item_inventoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItem_inventoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for item_inventories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__item_inventoriesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    item<T extends itemsArgs= {}>(args?: Subset<T, itemsArgs>): Prisma__itemsClient<itemsGetPayload<T> | Null>;

    inventories<T extends item_inventories$inventoriesArgs= {}>(args?: Subset<T, item_inventories$inventoriesArgs>): Prisma.PrismaPromise<Array<inventoriesGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * item_inventories base type for findUnique actions
   */
  export type item_inventoriesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the item_inventories
     */
    select?: item_inventoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: item_inventoriesInclude | null
    /**
     * Filter, which item_inventories to fetch.
     */
    where: item_inventoriesWhereUniqueInput
  }

  /**
   * item_inventories findUnique
   */
  export interface item_inventoriesFindUniqueArgs extends item_inventoriesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * item_inventories findUniqueOrThrow
   */
  export type item_inventoriesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the item_inventories
     */
    select?: item_inventoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: item_inventoriesInclude | null
    /**
     * Filter, which item_inventories to fetch.
     */
    where: item_inventoriesWhereUniqueInput
  }


  /**
   * item_inventories base type for findFirst actions
   */
  export type item_inventoriesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the item_inventories
     */
    select?: item_inventoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: item_inventoriesInclude | null
    /**
     * Filter, which item_inventories to fetch.
     */
    where?: item_inventoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of item_inventories to fetch.
     */
    orderBy?: Enumerable<item_inventoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for item_inventories.
     */
    cursor?: item_inventoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` item_inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` item_inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of item_inventories.
     */
    distinct?: Enumerable<Item_inventoriesScalarFieldEnum>
  }

  /**
   * item_inventories findFirst
   */
  export interface item_inventoriesFindFirstArgs extends item_inventoriesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * item_inventories findFirstOrThrow
   */
  export type item_inventoriesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the item_inventories
     */
    select?: item_inventoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: item_inventoriesInclude | null
    /**
     * Filter, which item_inventories to fetch.
     */
    where?: item_inventoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of item_inventories to fetch.
     */
    orderBy?: Enumerable<item_inventoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for item_inventories.
     */
    cursor?: item_inventoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` item_inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` item_inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of item_inventories.
     */
    distinct?: Enumerable<Item_inventoriesScalarFieldEnum>
  }


  /**
   * item_inventories findMany
   */
  export type item_inventoriesFindManyArgs = {
    /**
     * Select specific fields to fetch from the item_inventories
     */
    select?: item_inventoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: item_inventoriesInclude | null
    /**
     * Filter, which item_inventories to fetch.
     */
    where?: item_inventoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of item_inventories to fetch.
     */
    orderBy?: Enumerable<item_inventoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing item_inventories.
     */
    cursor?: item_inventoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` item_inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` item_inventories.
     */
    skip?: number
    distinct?: Enumerable<Item_inventoriesScalarFieldEnum>
  }


  /**
   * item_inventories create
   */
  export type item_inventoriesCreateArgs = {
    /**
     * Select specific fields to fetch from the item_inventories
     */
    select?: item_inventoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: item_inventoriesInclude | null
    /**
     * The data needed to create a item_inventories.
     */
    data: XOR<item_inventoriesCreateInput, item_inventoriesUncheckedCreateInput>
  }


  /**
   * item_inventories createMany
   */
  export type item_inventoriesCreateManyArgs = {
    /**
     * The data used to create many item_inventories.
     */
    data: Enumerable<item_inventoriesCreateManyInput>
  }


  /**
   * item_inventories update
   */
  export type item_inventoriesUpdateArgs = {
    /**
     * Select specific fields to fetch from the item_inventories
     */
    select?: item_inventoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: item_inventoriesInclude | null
    /**
     * The data needed to update a item_inventories.
     */
    data: XOR<item_inventoriesUpdateInput, item_inventoriesUncheckedUpdateInput>
    /**
     * Choose, which item_inventories to update.
     */
    where: item_inventoriesWhereUniqueInput
  }


  /**
   * item_inventories updateMany
   */
  export type item_inventoriesUpdateManyArgs = {
    /**
     * The data used to update item_inventories.
     */
    data: XOR<item_inventoriesUpdateManyMutationInput, item_inventoriesUncheckedUpdateManyInput>
    /**
     * Filter which item_inventories to update
     */
    where?: item_inventoriesWhereInput
  }


  /**
   * item_inventories upsert
   */
  export type item_inventoriesUpsertArgs = {
    /**
     * Select specific fields to fetch from the item_inventories
     */
    select?: item_inventoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: item_inventoriesInclude | null
    /**
     * The filter to search for the item_inventories to update in case it exists.
     */
    where: item_inventoriesWhereUniqueInput
    /**
     * In case the item_inventories found by the `where` argument doesn't exist, create a new item_inventories with this data.
     */
    create: XOR<item_inventoriesCreateInput, item_inventoriesUncheckedCreateInput>
    /**
     * In case the item_inventories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<item_inventoriesUpdateInput, item_inventoriesUncheckedUpdateInput>
  }


  /**
   * item_inventories delete
   */
  export type item_inventoriesDeleteArgs = {
    /**
     * Select specific fields to fetch from the item_inventories
     */
    select?: item_inventoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: item_inventoriesInclude | null
    /**
     * Filter which item_inventories to delete.
     */
    where: item_inventoriesWhereUniqueInput
  }


  /**
   * item_inventories deleteMany
   */
  export type item_inventoriesDeleteManyArgs = {
    /**
     * Filter which item_inventories to delete
     */
    where?: item_inventoriesWhereInput
  }


  /**
   * item_inventories findRaw
   */
  export type item_inventoriesFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * item_inventories aggregateRaw
   */
  export type item_inventoriesAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * item_inventories.inventories
   */
  export type item_inventories$inventoriesArgs = {
    /**
     * Select specific fields to fetch from the inventories
     */
    select?: inventoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: inventoriesInclude | null
    where?: inventoriesWhereInput
    orderBy?: Enumerable<inventoriesOrderByWithRelationInput>
    cursor?: inventoriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InventoriesScalarFieldEnum>
  }


  /**
   * item_inventories without action
   */
  export type item_inventoriesArgs = {
    /**
     * Select specific fields to fetch from the item_inventories
     */
    select?: item_inventoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: item_inventoriesInclude | null
  }



  /**
   * Model oders
   */


  export type AggregateOders = {
    _count: OdersCountAggregateOutputType | null
    _avg: OdersAvgAggregateOutputType | null
    _sum: OdersSumAggregateOutputType | null
    _min: OdersMinAggregateOutputType | null
    _max: OdersMaxAggregateOutputType | null
  }

  export type OdersAvgAggregateOutputType = {
    total: number | null
  }

  export type OdersSumAggregateOutputType = {
    total: number | null
  }

  export type OdersMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
    total: number | null
  }

  export type OdersMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
    total: number | null
  }

  export type OdersCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    uuid: number
    total: number
    item_order_ids: number
    _all: number
  }


  export type OdersAvgAggregateInputType = {
    total?: true
  }

  export type OdersSumAggregateInputType = {
    total?: true
  }

  export type OdersMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    total?: true
  }

  export type OdersMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    total?: true
  }

  export type OdersCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    total?: true
    item_order_ids?: true
    _all?: true
  }

  export type OdersAggregateArgs = {
    /**
     * Filter which oders to aggregate.
     */
    where?: odersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of oders to fetch.
     */
    orderBy?: Enumerable<odersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: odersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` oders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` oders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned oders
    **/
    _count?: true | OdersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OdersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OdersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OdersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OdersMaxAggregateInputType
  }

  export type GetOdersAggregateType<T extends OdersAggregateArgs> = {
        [P in keyof T & keyof AggregateOders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOders[P]>
      : GetScalarType<T[P], AggregateOders[P]>
  }




  export type OdersGroupByArgs = {
    where?: odersWhereInput
    orderBy?: Enumerable<odersOrderByWithAggregationInput>
    by: OdersScalarFieldEnum[]
    having?: odersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OdersCountAggregateInputType | true
    _avg?: OdersAvgAggregateInputType
    _sum?: OdersSumAggregateInputType
    _min?: OdersMinAggregateInputType
    _max?: OdersMaxAggregateInputType
  }


  export type OdersGroupByOutputType = {
    id: string
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string
    total: number
    item_order_ids: string[]
    _count: OdersCountAggregateOutputType | null
    _avg: OdersAvgAggregateOutputType | null
    _sum: OdersSumAggregateOutputType | null
    _min: OdersMinAggregateOutputType | null
    _max: OdersMaxAggregateOutputType | null
  }

  type GetOdersGroupByPayload<T extends OdersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OdersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OdersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OdersGroupByOutputType[P]>
            : GetScalarType<T[P], OdersGroupByOutputType[P]>
        }
      >
    >


  export type odersSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uuid?: boolean
    total?: boolean
    item_order_ids?: boolean
    item_orders?: boolean | oders$item_ordersArgs
    _count?: boolean | OdersCountOutputTypeArgs
  }


  export type odersInclude = {
    item_orders?: boolean | oders$item_ordersArgs
    _count?: boolean | OdersCountOutputTypeArgs
  }

  export type odersGetPayload<S extends boolean | null | undefined | odersArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? oders :
    S extends undefined ? never :
    S extends { include: any } & (odersArgs | odersFindManyArgs)
    ? oders  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'item_orders' ? Array < item_ordersGetPayload<S['include'][P]>>  :
        P extends '_count' ? OdersCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (odersArgs | odersFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'item_orders' ? Array < item_ordersGetPayload<S['select'][P]>>  :
        P extends '_count' ? OdersCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof oders ? oders[P] : never
  } 
      : oders


  type odersCountArgs = 
    Omit<odersFindManyArgs, 'select' | 'include'> & {
      select?: OdersCountAggregateInputType | true
    }

  export interface odersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Oders that matches the filter.
     * @param {odersFindUniqueArgs} args - Arguments to find a Oders
     * @example
     * // Get one Oders
     * const oders = await prisma.oders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends odersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, odersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'oders'> extends True ? Prisma__odersClient<odersGetPayload<T>> : Prisma__odersClient<odersGetPayload<T> | null, null>

    /**
     * Find one Oders that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {odersFindUniqueOrThrowArgs} args - Arguments to find a Oders
     * @example
     * // Get one Oders
     * const oders = await prisma.oders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends odersFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, odersFindUniqueOrThrowArgs>
    ): Prisma__odersClient<odersGetPayload<T>>

    /**
     * Find the first Oders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {odersFindFirstArgs} args - Arguments to find a Oders
     * @example
     * // Get one Oders
     * const oders = await prisma.oders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends odersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, odersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'oders'> extends True ? Prisma__odersClient<odersGetPayload<T>> : Prisma__odersClient<odersGetPayload<T> | null, null>

    /**
     * Find the first Oders that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {odersFindFirstOrThrowArgs} args - Arguments to find a Oders
     * @example
     * // Get one Oders
     * const oders = await prisma.oders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends odersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, odersFindFirstOrThrowArgs>
    ): Prisma__odersClient<odersGetPayload<T>>

    /**
     * Find zero or more Oders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {odersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Oders
     * const oders = await prisma.oders.findMany()
     * 
     * // Get first 10 Oders
     * const oders = await prisma.oders.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const odersWithIdOnly = await prisma.oders.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends odersFindManyArgs>(
      args?: SelectSubset<T, odersFindManyArgs>
    ): Prisma.PrismaPromise<Array<odersGetPayload<T>>>

    /**
     * Create a Oders.
     * @param {odersCreateArgs} args - Arguments to create a Oders.
     * @example
     * // Create one Oders
     * const Oders = await prisma.oders.create({
     *   data: {
     *     // ... data to create a Oders
     *   }
     * })
     * 
    **/
    create<T extends odersCreateArgs>(
      args: SelectSubset<T, odersCreateArgs>
    ): Prisma__odersClient<odersGetPayload<T>>

    /**
     * Create many Oders.
     *     @param {odersCreateManyArgs} args - Arguments to create many Oders.
     *     @example
     *     // Create many Oders
     *     const oders = await prisma.oders.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends odersCreateManyArgs>(
      args?: SelectSubset<T, odersCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Oders.
     * @param {odersDeleteArgs} args - Arguments to delete one Oders.
     * @example
     * // Delete one Oders
     * const Oders = await prisma.oders.delete({
     *   where: {
     *     // ... filter to delete one Oders
     *   }
     * })
     * 
    **/
    delete<T extends odersDeleteArgs>(
      args: SelectSubset<T, odersDeleteArgs>
    ): Prisma__odersClient<odersGetPayload<T>>

    /**
     * Update one Oders.
     * @param {odersUpdateArgs} args - Arguments to update one Oders.
     * @example
     * // Update one Oders
     * const oders = await prisma.oders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends odersUpdateArgs>(
      args: SelectSubset<T, odersUpdateArgs>
    ): Prisma__odersClient<odersGetPayload<T>>

    /**
     * Delete zero or more Oders.
     * @param {odersDeleteManyArgs} args - Arguments to filter Oders to delete.
     * @example
     * // Delete a few Oders
     * const { count } = await prisma.oders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends odersDeleteManyArgs>(
      args?: SelectSubset<T, odersDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Oders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {odersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Oders
     * const oders = await prisma.oders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends odersUpdateManyArgs>(
      args: SelectSubset<T, odersUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Oders.
     * @param {odersUpsertArgs} args - Arguments to update or create a Oders.
     * @example
     * // Update or create a Oders
     * const oders = await prisma.oders.upsert({
     *   create: {
     *     // ... data to create a Oders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Oders we want to update
     *   }
     * })
    **/
    upsert<T extends odersUpsertArgs>(
      args: SelectSubset<T, odersUpsertArgs>
    ): Prisma__odersClient<odersGetPayload<T>>

    /**
     * Find zero or more Oders that matches the filter.
     * @param {odersFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const oders = await prisma.oders.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: odersFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Oders.
     * @param {odersAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const oders = await prisma.oders.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: odersAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Oders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {odersCountArgs} args - Arguments to filter Oders to count.
     * @example
     * // Count the number of Oders
     * const count = await prisma.oders.count({
     *   where: {
     *     // ... the filter for the Oders we want to count
     *   }
     * })
    **/
    count<T extends odersCountArgs>(
      args?: Subset<T, odersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OdersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Oders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OdersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OdersAggregateArgs>(args: Subset<T, OdersAggregateArgs>): Prisma.PrismaPromise<GetOdersAggregateType<T>>

    /**
     * Group by Oders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OdersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OdersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OdersGroupByArgs['orderBy'] }
        : { orderBy?: OdersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OdersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOdersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for oders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__odersClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    item_orders<T extends oders$item_ordersArgs= {}>(args?: Subset<T, oders$item_ordersArgs>): Prisma.PrismaPromise<Array<item_ordersGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * oders base type for findUnique actions
   */
  export type odersFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the oders
     */
    select?: odersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: odersInclude | null
    /**
     * Filter, which oders to fetch.
     */
    where: odersWhereUniqueInput
  }

  /**
   * oders findUnique
   */
  export interface odersFindUniqueArgs extends odersFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * oders findUniqueOrThrow
   */
  export type odersFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the oders
     */
    select?: odersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: odersInclude | null
    /**
     * Filter, which oders to fetch.
     */
    where: odersWhereUniqueInput
  }


  /**
   * oders base type for findFirst actions
   */
  export type odersFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the oders
     */
    select?: odersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: odersInclude | null
    /**
     * Filter, which oders to fetch.
     */
    where?: odersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of oders to fetch.
     */
    orderBy?: Enumerable<odersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for oders.
     */
    cursor?: odersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` oders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` oders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of oders.
     */
    distinct?: Enumerable<OdersScalarFieldEnum>
  }

  /**
   * oders findFirst
   */
  export interface odersFindFirstArgs extends odersFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * oders findFirstOrThrow
   */
  export type odersFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the oders
     */
    select?: odersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: odersInclude | null
    /**
     * Filter, which oders to fetch.
     */
    where?: odersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of oders to fetch.
     */
    orderBy?: Enumerable<odersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for oders.
     */
    cursor?: odersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` oders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` oders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of oders.
     */
    distinct?: Enumerable<OdersScalarFieldEnum>
  }


  /**
   * oders findMany
   */
  export type odersFindManyArgs = {
    /**
     * Select specific fields to fetch from the oders
     */
    select?: odersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: odersInclude | null
    /**
     * Filter, which oders to fetch.
     */
    where?: odersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of oders to fetch.
     */
    orderBy?: Enumerable<odersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing oders.
     */
    cursor?: odersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` oders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` oders.
     */
    skip?: number
    distinct?: Enumerable<OdersScalarFieldEnum>
  }


  /**
   * oders create
   */
  export type odersCreateArgs = {
    /**
     * Select specific fields to fetch from the oders
     */
    select?: odersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: odersInclude | null
    /**
     * The data needed to create a oders.
     */
    data: XOR<odersCreateInput, odersUncheckedCreateInput>
  }


  /**
   * oders createMany
   */
  export type odersCreateManyArgs = {
    /**
     * The data used to create many oders.
     */
    data: Enumerable<odersCreateManyInput>
  }


  /**
   * oders update
   */
  export type odersUpdateArgs = {
    /**
     * Select specific fields to fetch from the oders
     */
    select?: odersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: odersInclude | null
    /**
     * The data needed to update a oders.
     */
    data: XOR<odersUpdateInput, odersUncheckedUpdateInput>
    /**
     * Choose, which oders to update.
     */
    where: odersWhereUniqueInput
  }


  /**
   * oders updateMany
   */
  export type odersUpdateManyArgs = {
    /**
     * The data used to update oders.
     */
    data: XOR<odersUpdateManyMutationInput, odersUncheckedUpdateManyInput>
    /**
     * Filter which oders to update
     */
    where?: odersWhereInput
  }


  /**
   * oders upsert
   */
  export type odersUpsertArgs = {
    /**
     * Select specific fields to fetch from the oders
     */
    select?: odersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: odersInclude | null
    /**
     * The filter to search for the oders to update in case it exists.
     */
    where: odersWhereUniqueInput
    /**
     * In case the oders found by the `where` argument doesn't exist, create a new oders with this data.
     */
    create: XOR<odersCreateInput, odersUncheckedCreateInput>
    /**
     * In case the oders was found with the provided `where` argument, update it with this data.
     */
    update: XOR<odersUpdateInput, odersUncheckedUpdateInput>
  }


  /**
   * oders delete
   */
  export type odersDeleteArgs = {
    /**
     * Select specific fields to fetch from the oders
     */
    select?: odersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: odersInclude | null
    /**
     * Filter which oders to delete.
     */
    where: odersWhereUniqueInput
  }


  /**
   * oders deleteMany
   */
  export type odersDeleteManyArgs = {
    /**
     * Filter which oders to delete
     */
    where?: odersWhereInput
  }


  /**
   * oders findRaw
   */
  export type odersFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * oders aggregateRaw
   */
  export type odersAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * oders.item_orders
   */
  export type oders$item_ordersArgs = {
    /**
     * Select specific fields to fetch from the item_orders
     */
    select?: item_ordersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: item_ordersInclude | null
    where?: item_ordersWhereInput
    orderBy?: Enumerable<item_ordersOrderByWithRelationInput>
    cursor?: item_ordersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Item_ordersScalarFieldEnum>
  }


  /**
   * oders without action
   */
  export type odersArgs = {
    /**
     * Select specific fields to fetch from the oders
     */
    select?: odersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: odersInclude | null
  }



  /**
   * Model item_orders
   */


  export type AggregateItem_orders = {
    _count: Item_ordersCountAggregateOutputType | null
    _avg: Item_ordersAvgAggregateOutputType | null
    _sum: Item_ordersSumAggregateOutputType | null
    _min: Item_ordersMinAggregateOutputType | null
    _max: Item_ordersMaxAggregateOutputType | null
  }

  export type Item_ordersAvgAggregateOutputType = {
    value: number | null
  }

  export type Item_ordersSumAggregateOutputType = {
    value: number | null
  }

  export type Item_ordersMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
    item_id: string | null
    type: ItemQualitativeType | null
    value: number | null
  }

  export type Item_ordersMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
    item_id: string | null
    type: ItemQualitativeType | null
    value: number | null
  }

  export type Item_ordersCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    uuid: number
    item_id: number
    type: number
    value: number
    order_ids: number
    _all: number
  }


  export type Item_ordersAvgAggregateInputType = {
    value?: true
  }

  export type Item_ordersSumAggregateInputType = {
    value?: true
  }

  export type Item_ordersMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    item_id?: true
    type?: true
    value?: true
  }

  export type Item_ordersMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    item_id?: true
    type?: true
    value?: true
  }

  export type Item_ordersCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    item_id?: true
    type?: true
    value?: true
    order_ids?: true
    _all?: true
  }

  export type Item_ordersAggregateArgs = {
    /**
     * Filter which item_orders to aggregate.
     */
    where?: item_ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of item_orders to fetch.
     */
    orderBy?: Enumerable<item_ordersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: item_ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` item_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` item_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned item_orders
    **/
    _count?: true | Item_ordersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Item_ordersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Item_ordersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Item_ordersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Item_ordersMaxAggregateInputType
  }

  export type GetItem_ordersAggregateType<T extends Item_ordersAggregateArgs> = {
        [P in keyof T & keyof AggregateItem_orders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem_orders[P]>
      : GetScalarType<T[P], AggregateItem_orders[P]>
  }




  export type Item_ordersGroupByArgs = {
    where?: item_ordersWhereInput
    orderBy?: Enumerable<item_ordersOrderByWithAggregationInput>
    by: Item_ordersScalarFieldEnum[]
    having?: item_ordersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Item_ordersCountAggregateInputType | true
    _avg?: Item_ordersAvgAggregateInputType
    _sum?: Item_ordersSumAggregateInputType
    _min?: Item_ordersMinAggregateInputType
    _max?: Item_ordersMaxAggregateInputType
  }


  export type Item_ordersGroupByOutputType = {
    id: string
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string
    item_id: string
    type: ItemQualitativeType
    value: number
    order_ids: string[]
    _count: Item_ordersCountAggregateOutputType | null
    _avg: Item_ordersAvgAggregateOutputType | null
    _sum: Item_ordersSumAggregateOutputType | null
    _min: Item_ordersMinAggregateOutputType | null
    _max: Item_ordersMaxAggregateOutputType | null
  }

  type GetItem_ordersGroupByPayload<T extends Item_ordersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Item_ordersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Item_ordersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Item_ordersGroupByOutputType[P]>
            : GetScalarType<T[P], Item_ordersGroupByOutputType[P]>
        }
      >
    >


  export type item_ordersSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uuid?: boolean
    item_id?: boolean
    type?: boolean
    value?: boolean
    order_ids?: boolean
    item?: boolean | itemsArgs
    orders?: boolean | item_orders$ordersArgs
    _count?: boolean | Item_ordersCountOutputTypeArgs
  }


  export type item_ordersInclude = {
    item?: boolean | itemsArgs
    orders?: boolean | item_orders$ordersArgs
    _count?: boolean | Item_ordersCountOutputTypeArgs
  }

  export type item_ordersGetPayload<S extends boolean | null | undefined | item_ordersArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? item_orders :
    S extends undefined ? never :
    S extends { include: any } & (item_ordersArgs | item_ordersFindManyArgs)
    ? item_orders  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'item' ? itemsGetPayload<S['include'][P]> :
        P extends 'orders' ? Array < odersGetPayload<S['include'][P]>>  :
        P extends '_count' ? Item_ordersCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (item_ordersArgs | item_ordersFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'item' ? itemsGetPayload<S['select'][P]> :
        P extends 'orders' ? Array < odersGetPayload<S['select'][P]>>  :
        P extends '_count' ? Item_ordersCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof item_orders ? item_orders[P] : never
  } 
      : item_orders


  type item_ordersCountArgs = 
    Omit<item_ordersFindManyArgs, 'select' | 'include'> & {
      select?: Item_ordersCountAggregateInputType | true
    }

  export interface item_ordersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Item_orders that matches the filter.
     * @param {item_ordersFindUniqueArgs} args - Arguments to find a Item_orders
     * @example
     * // Get one Item_orders
     * const item_orders = await prisma.item_orders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends item_ordersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, item_ordersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'item_orders'> extends True ? Prisma__item_ordersClient<item_ordersGetPayload<T>> : Prisma__item_ordersClient<item_ordersGetPayload<T> | null, null>

    /**
     * Find one Item_orders that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {item_ordersFindUniqueOrThrowArgs} args - Arguments to find a Item_orders
     * @example
     * // Get one Item_orders
     * const item_orders = await prisma.item_orders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends item_ordersFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, item_ordersFindUniqueOrThrowArgs>
    ): Prisma__item_ordersClient<item_ordersGetPayload<T>>

    /**
     * Find the first Item_orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_ordersFindFirstArgs} args - Arguments to find a Item_orders
     * @example
     * // Get one Item_orders
     * const item_orders = await prisma.item_orders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends item_ordersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, item_ordersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'item_orders'> extends True ? Prisma__item_ordersClient<item_ordersGetPayload<T>> : Prisma__item_ordersClient<item_ordersGetPayload<T> | null, null>

    /**
     * Find the first Item_orders that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_ordersFindFirstOrThrowArgs} args - Arguments to find a Item_orders
     * @example
     * // Get one Item_orders
     * const item_orders = await prisma.item_orders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends item_ordersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, item_ordersFindFirstOrThrowArgs>
    ): Prisma__item_ordersClient<item_ordersGetPayload<T>>

    /**
     * Find zero or more Item_orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_ordersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Item_orders
     * const item_orders = await prisma.item_orders.findMany()
     * 
     * // Get first 10 Item_orders
     * const item_orders = await prisma.item_orders.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const item_ordersWithIdOnly = await prisma.item_orders.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends item_ordersFindManyArgs>(
      args?: SelectSubset<T, item_ordersFindManyArgs>
    ): Prisma.PrismaPromise<Array<item_ordersGetPayload<T>>>

    /**
     * Create a Item_orders.
     * @param {item_ordersCreateArgs} args - Arguments to create a Item_orders.
     * @example
     * // Create one Item_orders
     * const Item_orders = await prisma.item_orders.create({
     *   data: {
     *     // ... data to create a Item_orders
     *   }
     * })
     * 
    **/
    create<T extends item_ordersCreateArgs>(
      args: SelectSubset<T, item_ordersCreateArgs>
    ): Prisma__item_ordersClient<item_ordersGetPayload<T>>

    /**
     * Create many Item_orders.
     *     @param {item_ordersCreateManyArgs} args - Arguments to create many Item_orders.
     *     @example
     *     // Create many Item_orders
     *     const item_orders = await prisma.item_orders.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends item_ordersCreateManyArgs>(
      args?: SelectSubset<T, item_ordersCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Item_orders.
     * @param {item_ordersDeleteArgs} args - Arguments to delete one Item_orders.
     * @example
     * // Delete one Item_orders
     * const Item_orders = await prisma.item_orders.delete({
     *   where: {
     *     // ... filter to delete one Item_orders
     *   }
     * })
     * 
    **/
    delete<T extends item_ordersDeleteArgs>(
      args: SelectSubset<T, item_ordersDeleteArgs>
    ): Prisma__item_ordersClient<item_ordersGetPayload<T>>

    /**
     * Update one Item_orders.
     * @param {item_ordersUpdateArgs} args - Arguments to update one Item_orders.
     * @example
     * // Update one Item_orders
     * const item_orders = await prisma.item_orders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends item_ordersUpdateArgs>(
      args: SelectSubset<T, item_ordersUpdateArgs>
    ): Prisma__item_ordersClient<item_ordersGetPayload<T>>

    /**
     * Delete zero or more Item_orders.
     * @param {item_ordersDeleteManyArgs} args - Arguments to filter Item_orders to delete.
     * @example
     * // Delete a few Item_orders
     * const { count } = await prisma.item_orders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends item_ordersDeleteManyArgs>(
      args?: SelectSubset<T, item_ordersDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Item_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_ordersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Item_orders
     * const item_orders = await prisma.item_orders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends item_ordersUpdateManyArgs>(
      args: SelectSubset<T, item_ordersUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Item_orders.
     * @param {item_ordersUpsertArgs} args - Arguments to update or create a Item_orders.
     * @example
     * // Update or create a Item_orders
     * const item_orders = await prisma.item_orders.upsert({
     *   create: {
     *     // ... data to create a Item_orders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item_orders we want to update
     *   }
     * })
    **/
    upsert<T extends item_ordersUpsertArgs>(
      args: SelectSubset<T, item_ordersUpsertArgs>
    ): Prisma__item_ordersClient<item_ordersGetPayload<T>>

    /**
     * Find zero or more Item_orders that matches the filter.
     * @param {item_ordersFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const item_orders = await prisma.item_orders.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: item_ordersFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Item_orders.
     * @param {item_ordersAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const item_orders = await prisma.item_orders.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: item_ordersAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Item_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_ordersCountArgs} args - Arguments to filter Item_orders to count.
     * @example
     * // Count the number of Item_orders
     * const count = await prisma.item_orders.count({
     *   where: {
     *     // ... the filter for the Item_orders we want to count
     *   }
     * })
    **/
    count<T extends item_ordersCountArgs>(
      args?: Subset<T, item_ordersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Item_ordersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Item_ordersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Item_ordersAggregateArgs>(args: Subset<T, Item_ordersAggregateArgs>): Prisma.PrismaPromise<GetItem_ordersAggregateType<T>>

    /**
     * Group by Item_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Item_ordersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Item_ordersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Item_ordersGroupByArgs['orderBy'] }
        : { orderBy?: Item_ordersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Item_ordersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItem_ordersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for item_orders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__item_ordersClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    item<T extends itemsArgs= {}>(args?: Subset<T, itemsArgs>): Prisma__itemsClient<itemsGetPayload<T> | Null>;

    orders<T extends item_orders$ordersArgs= {}>(args?: Subset<T, item_orders$ordersArgs>): Prisma.PrismaPromise<Array<odersGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * item_orders base type for findUnique actions
   */
  export type item_ordersFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the item_orders
     */
    select?: item_ordersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: item_ordersInclude | null
    /**
     * Filter, which item_orders to fetch.
     */
    where: item_ordersWhereUniqueInput
  }

  /**
   * item_orders findUnique
   */
  export interface item_ordersFindUniqueArgs extends item_ordersFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * item_orders findUniqueOrThrow
   */
  export type item_ordersFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the item_orders
     */
    select?: item_ordersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: item_ordersInclude | null
    /**
     * Filter, which item_orders to fetch.
     */
    where: item_ordersWhereUniqueInput
  }


  /**
   * item_orders base type for findFirst actions
   */
  export type item_ordersFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the item_orders
     */
    select?: item_ordersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: item_ordersInclude | null
    /**
     * Filter, which item_orders to fetch.
     */
    where?: item_ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of item_orders to fetch.
     */
    orderBy?: Enumerable<item_ordersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for item_orders.
     */
    cursor?: item_ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` item_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` item_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of item_orders.
     */
    distinct?: Enumerable<Item_ordersScalarFieldEnum>
  }

  /**
   * item_orders findFirst
   */
  export interface item_ordersFindFirstArgs extends item_ordersFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * item_orders findFirstOrThrow
   */
  export type item_ordersFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the item_orders
     */
    select?: item_ordersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: item_ordersInclude | null
    /**
     * Filter, which item_orders to fetch.
     */
    where?: item_ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of item_orders to fetch.
     */
    orderBy?: Enumerable<item_ordersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for item_orders.
     */
    cursor?: item_ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` item_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` item_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of item_orders.
     */
    distinct?: Enumerable<Item_ordersScalarFieldEnum>
  }


  /**
   * item_orders findMany
   */
  export type item_ordersFindManyArgs = {
    /**
     * Select specific fields to fetch from the item_orders
     */
    select?: item_ordersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: item_ordersInclude | null
    /**
     * Filter, which item_orders to fetch.
     */
    where?: item_ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of item_orders to fetch.
     */
    orderBy?: Enumerable<item_ordersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing item_orders.
     */
    cursor?: item_ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` item_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` item_orders.
     */
    skip?: number
    distinct?: Enumerable<Item_ordersScalarFieldEnum>
  }


  /**
   * item_orders create
   */
  export type item_ordersCreateArgs = {
    /**
     * Select specific fields to fetch from the item_orders
     */
    select?: item_ordersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: item_ordersInclude | null
    /**
     * The data needed to create a item_orders.
     */
    data: XOR<item_ordersCreateInput, item_ordersUncheckedCreateInput>
  }


  /**
   * item_orders createMany
   */
  export type item_ordersCreateManyArgs = {
    /**
     * The data used to create many item_orders.
     */
    data: Enumerable<item_ordersCreateManyInput>
  }


  /**
   * item_orders update
   */
  export type item_ordersUpdateArgs = {
    /**
     * Select specific fields to fetch from the item_orders
     */
    select?: item_ordersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: item_ordersInclude | null
    /**
     * The data needed to update a item_orders.
     */
    data: XOR<item_ordersUpdateInput, item_ordersUncheckedUpdateInput>
    /**
     * Choose, which item_orders to update.
     */
    where: item_ordersWhereUniqueInput
  }


  /**
   * item_orders updateMany
   */
  export type item_ordersUpdateManyArgs = {
    /**
     * The data used to update item_orders.
     */
    data: XOR<item_ordersUpdateManyMutationInput, item_ordersUncheckedUpdateManyInput>
    /**
     * Filter which item_orders to update
     */
    where?: item_ordersWhereInput
  }


  /**
   * item_orders upsert
   */
  export type item_ordersUpsertArgs = {
    /**
     * Select specific fields to fetch from the item_orders
     */
    select?: item_ordersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: item_ordersInclude | null
    /**
     * The filter to search for the item_orders to update in case it exists.
     */
    where: item_ordersWhereUniqueInput
    /**
     * In case the item_orders found by the `where` argument doesn't exist, create a new item_orders with this data.
     */
    create: XOR<item_ordersCreateInput, item_ordersUncheckedCreateInput>
    /**
     * In case the item_orders was found with the provided `where` argument, update it with this data.
     */
    update: XOR<item_ordersUpdateInput, item_ordersUncheckedUpdateInput>
  }


  /**
   * item_orders delete
   */
  export type item_ordersDeleteArgs = {
    /**
     * Select specific fields to fetch from the item_orders
     */
    select?: item_ordersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: item_ordersInclude | null
    /**
     * Filter which item_orders to delete.
     */
    where: item_ordersWhereUniqueInput
  }


  /**
   * item_orders deleteMany
   */
  export type item_ordersDeleteManyArgs = {
    /**
     * Filter which item_orders to delete
     */
    where?: item_ordersWhereInput
  }


  /**
   * item_orders findRaw
   */
  export type item_ordersFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * item_orders aggregateRaw
   */
  export type item_ordersAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * item_orders.orders
   */
  export type item_orders$ordersArgs = {
    /**
     * Select specific fields to fetch from the oders
     */
    select?: odersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: odersInclude | null
    where?: odersWhereInput
    orderBy?: Enumerable<odersOrderByWithRelationInput>
    cursor?: odersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OdersScalarFieldEnum>
  }


  /**
   * item_orders without action
   */
  export type item_ordersArgs = {
    /**
     * Select specific fields to fetch from the item_orders
     */
    select?: item_ordersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: item_ordersInclude | null
  }



  /**
   * Model PaymentType
   */


  export type AggregatePaymentType = {
    _count: PaymentTypeCountAggregateOutputType | null
    _min: PaymentTypeMinAggregateOutputType | null
    _max: PaymentTypeMaxAggregateOutputType | null
  }

  export type PaymentTypeMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
    title: string | null
    description: string | null
  }

  export type PaymentTypeMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
    title: string | null
    description: string | null
  }

  export type PaymentTypeCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    uuid: number
    title: number
    description: number
    _all: number
  }


  export type PaymentTypeMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    title?: true
    description?: true
  }

  export type PaymentTypeMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    title?: true
    description?: true
  }

  export type PaymentTypeCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    title?: true
    description?: true
    _all?: true
  }

  export type PaymentTypeAggregateArgs = {
    /**
     * Filter which PaymentType to aggregate.
     */
    where?: PaymentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTypes to fetch.
     */
    orderBy?: Enumerable<PaymentTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentTypes
    **/
    _count?: true | PaymentTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentTypeMaxAggregateInputType
  }

  export type GetPaymentTypeAggregateType<T extends PaymentTypeAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentType[P]>
      : GetScalarType<T[P], AggregatePaymentType[P]>
  }




  export type PaymentTypeGroupByArgs = {
    where?: PaymentTypeWhereInput
    orderBy?: Enumerable<PaymentTypeOrderByWithAggregationInput>
    by: PaymentTypeScalarFieldEnum[]
    having?: PaymentTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentTypeCountAggregateInputType | true
    _min?: PaymentTypeMinAggregateInputType
    _max?: PaymentTypeMaxAggregateInputType
  }


  export type PaymentTypeGroupByOutputType = {
    id: string
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string
    title: string | null
    description: string | null
    _count: PaymentTypeCountAggregateOutputType | null
    _min: PaymentTypeMinAggregateOutputType | null
    _max: PaymentTypeMaxAggregateOutputType | null
  }

  type GetPaymentTypeGroupByPayload<T extends PaymentTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PaymentTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentTypeGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentTypeGroupByOutputType[P]>
        }
      >
    >


  export type PaymentTypeSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uuid?: boolean
    title?: boolean
    description?: boolean
    payments?: boolean | PaymentType$paymentsArgs
    _count?: boolean | PaymentTypeCountOutputTypeArgs
  }


  export type PaymentTypeInclude = {
    payments?: boolean | PaymentType$paymentsArgs
    _count?: boolean | PaymentTypeCountOutputTypeArgs
  }

  export type PaymentTypeGetPayload<S extends boolean | null | undefined | PaymentTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PaymentType :
    S extends undefined ? never :
    S extends { include: any } & (PaymentTypeArgs | PaymentTypeFindManyArgs)
    ? PaymentType  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'payments' ? Array < paymentGetPayload<S['include'][P]>>  :
        P extends '_count' ? PaymentTypeCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PaymentTypeArgs | PaymentTypeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'payments' ? Array < paymentGetPayload<S['select'][P]>>  :
        P extends '_count' ? PaymentTypeCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof PaymentType ? PaymentType[P] : never
  } 
      : PaymentType


  type PaymentTypeCountArgs = 
    Omit<PaymentTypeFindManyArgs, 'select' | 'include'> & {
      select?: PaymentTypeCountAggregateInputType | true
    }

  export interface PaymentTypeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one PaymentType that matches the filter.
     * @param {PaymentTypeFindUniqueArgs} args - Arguments to find a PaymentType
     * @example
     * // Get one PaymentType
     * const paymentType = await prisma.paymentType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PaymentTypeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PaymentTypeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PaymentType'> extends True ? Prisma__PaymentTypeClient<PaymentTypeGetPayload<T>> : Prisma__PaymentTypeClient<PaymentTypeGetPayload<T> | null, null>

    /**
     * Find one PaymentType that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PaymentTypeFindUniqueOrThrowArgs} args - Arguments to find a PaymentType
     * @example
     * // Get one PaymentType
     * const paymentType = await prisma.paymentType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PaymentTypeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PaymentTypeFindUniqueOrThrowArgs>
    ): Prisma__PaymentTypeClient<PaymentTypeGetPayload<T>>

    /**
     * Find the first PaymentType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTypeFindFirstArgs} args - Arguments to find a PaymentType
     * @example
     * // Get one PaymentType
     * const paymentType = await prisma.paymentType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PaymentTypeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PaymentTypeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PaymentType'> extends True ? Prisma__PaymentTypeClient<PaymentTypeGetPayload<T>> : Prisma__PaymentTypeClient<PaymentTypeGetPayload<T> | null, null>

    /**
     * Find the first PaymentType that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTypeFindFirstOrThrowArgs} args - Arguments to find a PaymentType
     * @example
     * // Get one PaymentType
     * const paymentType = await prisma.paymentType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PaymentTypeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PaymentTypeFindFirstOrThrowArgs>
    ): Prisma__PaymentTypeClient<PaymentTypeGetPayload<T>>

    /**
     * Find zero or more PaymentTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentTypes
     * const paymentTypes = await prisma.paymentType.findMany()
     * 
     * // Get first 10 PaymentTypes
     * const paymentTypes = await prisma.paymentType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentTypeWithIdOnly = await prisma.paymentType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PaymentTypeFindManyArgs>(
      args?: SelectSubset<T, PaymentTypeFindManyArgs>
    ): Prisma.PrismaPromise<Array<PaymentTypeGetPayload<T>>>

    /**
     * Create a PaymentType.
     * @param {PaymentTypeCreateArgs} args - Arguments to create a PaymentType.
     * @example
     * // Create one PaymentType
     * const PaymentType = await prisma.paymentType.create({
     *   data: {
     *     // ... data to create a PaymentType
     *   }
     * })
     * 
    **/
    create<T extends PaymentTypeCreateArgs>(
      args: SelectSubset<T, PaymentTypeCreateArgs>
    ): Prisma__PaymentTypeClient<PaymentTypeGetPayload<T>>

    /**
     * Create many PaymentTypes.
     *     @param {PaymentTypeCreateManyArgs} args - Arguments to create many PaymentTypes.
     *     @example
     *     // Create many PaymentTypes
     *     const paymentType = await prisma.paymentType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PaymentTypeCreateManyArgs>(
      args?: SelectSubset<T, PaymentTypeCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PaymentType.
     * @param {PaymentTypeDeleteArgs} args - Arguments to delete one PaymentType.
     * @example
     * // Delete one PaymentType
     * const PaymentType = await prisma.paymentType.delete({
     *   where: {
     *     // ... filter to delete one PaymentType
     *   }
     * })
     * 
    **/
    delete<T extends PaymentTypeDeleteArgs>(
      args: SelectSubset<T, PaymentTypeDeleteArgs>
    ): Prisma__PaymentTypeClient<PaymentTypeGetPayload<T>>

    /**
     * Update one PaymentType.
     * @param {PaymentTypeUpdateArgs} args - Arguments to update one PaymentType.
     * @example
     * // Update one PaymentType
     * const paymentType = await prisma.paymentType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PaymentTypeUpdateArgs>(
      args: SelectSubset<T, PaymentTypeUpdateArgs>
    ): Prisma__PaymentTypeClient<PaymentTypeGetPayload<T>>

    /**
     * Delete zero or more PaymentTypes.
     * @param {PaymentTypeDeleteManyArgs} args - Arguments to filter PaymentTypes to delete.
     * @example
     * // Delete a few PaymentTypes
     * const { count } = await prisma.paymentType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PaymentTypeDeleteManyArgs>(
      args?: SelectSubset<T, PaymentTypeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentTypes
     * const paymentType = await prisma.paymentType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PaymentTypeUpdateManyArgs>(
      args: SelectSubset<T, PaymentTypeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentType.
     * @param {PaymentTypeUpsertArgs} args - Arguments to update or create a PaymentType.
     * @example
     * // Update or create a PaymentType
     * const paymentType = await prisma.paymentType.upsert({
     *   create: {
     *     // ... data to create a PaymentType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentType we want to update
     *   }
     * })
    **/
    upsert<T extends PaymentTypeUpsertArgs>(
      args: SelectSubset<T, PaymentTypeUpsertArgs>
    ): Prisma__PaymentTypeClient<PaymentTypeGetPayload<T>>

    /**
     * Find zero or more PaymentTypes that matches the filter.
     * @param {PaymentTypeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const paymentType = await prisma.paymentType.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: PaymentTypeFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a PaymentType.
     * @param {PaymentTypeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const paymentType = await prisma.paymentType.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: PaymentTypeAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of PaymentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTypeCountArgs} args - Arguments to filter PaymentTypes to count.
     * @example
     * // Count the number of PaymentTypes
     * const count = await prisma.paymentType.count({
     *   where: {
     *     // ... the filter for the PaymentTypes we want to count
     *   }
     * })
    **/
    count<T extends PaymentTypeCountArgs>(
      args?: Subset<T, PaymentTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentTypeAggregateArgs>(args: Subset<T, PaymentTypeAggregateArgs>): Prisma.PrismaPromise<GetPaymentTypeAggregateType<T>>

    /**
     * Group by PaymentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentTypeGroupByArgs['orderBy'] }
        : { orderBy?: PaymentTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PaymentTypeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    payments<T extends PaymentType$paymentsArgs= {}>(args?: Subset<T, PaymentType$paymentsArgs>): Prisma.PrismaPromise<Array<paymentGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PaymentType base type for findUnique actions
   */
  export type PaymentTypeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PaymentType
     */
    select?: PaymentTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentTypeInclude | null
    /**
     * Filter, which PaymentType to fetch.
     */
    where: PaymentTypeWhereUniqueInput
  }

  /**
   * PaymentType findUnique
   */
  export interface PaymentTypeFindUniqueArgs extends PaymentTypeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PaymentType findUniqueOrThrow
   */
  export type PaymentTypeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PaymentType
     */
    select?: PaymentTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentTypeInclude | null
    /**
     * Filter, which PaymentType to fetch.
     */
    where: PaymentTypeWhereUniqueInput
  }


  /**
   * PaymentType base type for findFirst actions
   */
  export type PaymentTypeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PaymentType
     */
    select?: PaymentTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentTypeInclude | null
    /**
     * Filter, which PaymentType to fetch.
     */
    where?: PaymentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTypes to fetch.
     */
    orderBy?: Enumerable<PaymentTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentTypes.
     */
    cursor?: PaymentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentTypes.
     */
    distinct?: Enumerable<PaymentTypeScalarFieldEnum>
  }

  /**
   * PaymentType findFirst
   */
  export interface PaymentTypeFindFirstArgs extends PaymentTypeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PaymentType findFirstOrThrow
   */
  export type PaymentTypeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PaymentType
     */
    select?: PaymentTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentTypeInclude | null
    /**
     * Filter, which PaymentType to fetch.
     */
    where?: PaymentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTypes to fetch.
     */
    orderBy?: Enumerable<PaymentTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentTypes.
     */
    cursor?: PaymentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentTypes.
     */
    distinct?: Enumerable<PaymentTypeScalarFieldEnum>
  }


  /**
   * PaymentType findMany
   */
  export type PaymentTypeFindManyArgs = {
    /**
     * Select specific fields to fetch from the PaymentType
     */
    select?: PaymentTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentTypeInclude | null
    /**
     * Filter, which PaymentTypes to fetch.
     */
    where?: PaymentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTypes to fetch.
     */
    orderBy?: Enumerable<PaymentTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentTypes.
     */
    cursor?: PaymentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTypes.
     */
    skip?: number
    distinct?: Enumerable<PaymentTypeScalarFieldEnum>
  }


  /**
   * PaymentType create
   */
  export type PaymentTypeCreateArgs = {
    /**
     * Select specific fields to fetch from the PaymentType
     */
    select?: PaymentTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentTypeInclude | null
    /**
     * The data needed to create a PaymentType.
     */
    data: XOR<PaymentTypeCreateInput, PaymentTypeUncheckedCreateInput>
  }


  /**
   * PaymentType createMany
   */
  export type PaymentTypeCreateManyArgs = {
    /**
     * The data used to create many PaymentTypes.
     */
    data: Enumerable<PaymentTypeCreateManyInput>
  }


  /**
   * PaymentType update
   */
  export type PaymentTypeUpdateArgs = {
    /**
     * Select specific fields to fetch from the PaymentType
     */
    select?: PaymentTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentTypeInclude | null
    /**
     * The data needed to update a PaymentType.
     */
    data: XOR<PaymentTypeUpdateInput, PaymentTypeUncheckedUpdateInput>
    /**
     * Choose, which PaymentType to update.
     */
    where: PaymentTypeWhereUniqueInput
  }


  /**
   * PaymentType updateMany
   */
  export type PaymentTypeUpdateManyArgs = {
    /**
     * The data used to update PaymentTypes.
     */
    data: XOR<PaymentTypeUpdateManyMutationInput, PaymentTypeUncheckedUpdateManyInput>
    /**
     * Filter which PaymentTypes to update
     */
    where?: PaymentTypeWhereInput
  }


  /**
   * PaymentType upsert
   */
  export type PaymentTypeUpsertArgs = {
    /**
     * Select specific fields to fetch from the PaymentType
     */
    select?: PaymentTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentTypeInclude | null
    /**
     * The filter to search for the PaymentType to update in case it exists.
     */
    where: PaymentTypeWhereUniqueInput
    /**
     * In case the PaymentType found by the `where` argument doesn't exist, create a new PaymentType with this data.
     */
    create: XOR<PaymentTypeCreateInput, PaymentTypeUncheckedCreateInput>
    /**
     * In case the PaymentType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentTypeUpdateInput, PaymentTypeUncheckedUpdateInput>
  }


  /**
   * PaymentType delete
   */
  export type PaymentTypeDeleteArgs = {
    /**
     * Select specific fields to fetch from the PaymentType
     */
    select?: PaymentTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentTypeInclude | null
    /**
     * Filter which PaymentType to delete.
     */
    where: PaymentTypeWhereUniqueInput
  }


  /**
   * PaymentType deleteMany
   */
  export type PaymentTypeDeleteManyArgs = {
    /**
     * Filter which PaymentTypes to delete
     */
    where?: PaymentTypeWhereInput
  }


  /**
   * PaymentType findRaw
   */
  export type PaymentTypeFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * PaymentType aggregateRaw
   */
  export type PaymentTypeAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * PaymentType.payments
   */
  export type PaymentType$paymentsArgs = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: paymentInclude | null
    where?: paymentWhereInput
    orderBy?: Enumerable<paymentOrderByWithRelationInput>
    cursor?: paymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * PaymentType without action
   */
  export type PaymentTypeArgs = {
    /**
     * Select specific fields to fetch from the PaymentType
     */
    select?: PaymentTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentTypeInclude | null
  }



  /**
   * Model payment
   */


  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
    title: string | null
    description: string | null
    payment_type_id: string | null
    user_creator_id: string | null
    user_confirm_id: string | null
    receiver_account_id: string | null
    sender_account_id: string | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
    title: string | null
    description: string | null
    payment_type_id: string | null
    user_creator_id: string | null
    user_confirm_id: string | null
    receiver_account_id: string | null
    sender_account_id: string | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    uuid: number
    title: number
    description: number
    payment_type_id: number
    user_creator_id: number
    user_confirm_id: number
    receiver_account_id: number
    sender_account_id: number
    _all: number
  }


  export type PaymentMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    title?: true
    description?: true
    payment_type_id?: true
    user_creator_id?: true
    user_confirm_id?: true
    receiver_account_id?: true
    sender_account_id?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    title?: true
    description?: true
    payment_type_id?: true
    user_creator_id?: true
    user_confirm_id?: true
    receiver_account_id?: true
    sender_account_id?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    title?: true
    description?: true
    payment_type_id?: true
    user_creator_id?: true
    user_confirm_id?: true
    receiver_account_id?: true
    sender_account_id?: true
    _all?: true
  }

  export type PaymentAggregateArgs = {
    /**
     * Filter which payment to aggregate.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: Enumerable<paymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs = {
    where?: paymentWhereInput
    orderBy?: Enumerable<paymentOrderByWithAggregationInput>
    by: PaymentScalarFieldEnum[]
    having?: paymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }


  export type PaymentGroupByOutputType = {
    id: string
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string
    title: string | null
    description: string | null
    payment_type_id: string
    user_creator_id: string
    user_confirm_id: string
    receiver_account_id: string
    sender_account_id: string
    _count: PaymentCountAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type paymentSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uuid?: boolean
    title?: boolean
    description?: boolean
    payment_type_id?: boolean
    user_creator_id?: boolean
    user_confirm_id?: boolean
    receiver_account_id?: boolean
    sender_account_id?: boolean
    amount?: boolean | CurrencyArgs
    payment_type?: boolean | PaymentTypeArgs
    user_creator?: boolean | usersArgs
    user_confirm?: boolean | usersArgs
    recever_account?: boolean | PaymentAccountArgs
    sender_account?: boolean | PaymentAccountArgs
  }


  export type paymentInclude = {
    payment_type?: boolean | PaymentTypeArgs
    user_creator?: boolean | usersArgs
    user_confirm?: boolean | usersArgs
    recever_account?: boolean | PaymentAccountArgs
    sender_account?: boolean | PaymentAccountArgs
  }

  export type paymentGetPayload<S extends boolean | null | undefined | paymentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? payment :
    S extends undefined ? never :
    S extends { include: any } & (paymentArgs | paymentFindManyArgs)
    ? payment  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'payment_type' ? PaymentTypeGetPayload<S['include'][P]> :
        P extends 'user_creator' ? usersGetPayload<S['include'][P]> :
        P extends 'user_confirm' ? usersGetPayload<S['include'][P]> :
        P extends 'recever_account' ? PaymentAccountGetPayload<S['include'][P]> :
        P extends 'sender_account' ? PaymentAccountGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (paymentArgs | paymentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'amount' ? CurrencyGetPayload<S['select'][P]> :
        P extends 'payment_type' ? PaymentTypeGetPayload<S['select'][P]> :
        P extends 'user_creator' ? usersGetPayload<S['select'][P]> :
        P extends 'user_confirm' ? usersGetPayload<S['select'][P]> :
        P extends 'recever_account' ? PaymentAccountGetPayload<S['select'][P]> :
        P extends 'sender_account' ? PaymentAccountGetPayload<S['select'][P]> :  P extends keyof payment ? payment[P] : never
  } 
      : payment


  type paymentCountArgs = 
    Omit<paymentFindManyArgs, 'select' | 'include'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface paymentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Payment that matches the filter.
     * @param {paymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends paymentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, paymentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'payment'> extends True ? Prisma__paymentClient<paymentGetPayload<T>> : Prisma__paymentClient<paymentGetPayload<T> | null, null>

    /**
     * Find one Payment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {paymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends paymentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, paymentFindUniqueOrThrowArgs>
    ): Prisma__paymentClient<paymentGetPayload<T>>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends paymentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, paymentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'payment'> extends True ? Prisma__paymentClient<paymentGetPayload<T>> : Prisma__paymentClient<paymentGetPayload<T> | null, null>

    /**
     * Find the first Payment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends paymentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, paymentFindFirstOrThrowArgs>
    ): Prisma__paymentClient<paymentGetPayload<T>>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends paymentFindManyArgs>(
      args?: SelectSubset<T, paymentFindManyArgs>
    ): Prisma.PrismaPromise<Array<paymentGetPayload<T>>>

    /**
     * Create a Payment.
     * @param {paymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
    **/
    create<T extends paymentCreateArgs>(
      args: SelectSubset<T, paymentCreateArgs>
    ): Prisma__paymentClient<paymentGetPayload<T>>

    /**
     * Create many Payments.
     *     @param {paymentCreateManyArgs} args - Arguments to create many Payments.
     *     @example
     *     // Create many Payments
     *     const payment = await prisma.payment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends paymentCreateManyArgs>(
      args?: SelectSubset<T, paymentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {paymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
    **/
    delete<T extends paymentDeleteArgs>(
      args: SelectSubset<T, paymentDeleteArgs>
    ): Prisma__paymentClient<paymentGetPayload<T>>

    /**
     * Update one Payment.
     * @param {paymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends paymentUpdateArgs>(
      args: SelectSubset<T, paymentUpdateArgs>
    ): Prisma__paymentClient<paymentGetPayload<T>>

    /**
     * Delete zero or more Payments.
     * @param {paymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends paymentDeleteManyArgs>(
      args?: SelectSubset<T, paymentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends paymentUpdateManyArgs>(
      args: SelectSubset<T, paymentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {paymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
    **/
    upsert<T extends paymentUpsertArgs>(
      args: SelectSubset<T, paymentUpsertArgs>
    ): Prisma__paymentClient<paymentGetPayload<T>>

    /**
     * Find zero or more Payments that matches the filter.
     * @param {paymentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const payment = await prisma.payment.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: paymentFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Payment.
     * @param {paymentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const payment = await prisma.payment.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: paymentAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends paymentCountArgs>(
      args?: Subset<T, paymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__paymentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    amount<T extends CurrencyArgs= {}>(args?: Subset<T, CurrencyArgs>): Prisma__CurrencyClient<CurrencyGetPayload<T> | Null>;

    payment_type<T extends PaymentTypeArgs= {}>(args?: Subset<T, PaymentTypeArgs>): Prisma__PaymentTypeClient<PaymentTypeGetPayload<T> | Null>;

    user_creator<T extends usersArgs= {}>(args?: Subset<T, usersArgs>): Prisma__usersClient<usersGetPayload<T> | Null>;

    user_confirm<T extends usersArgs= {}>(args?: Subset<T, usersArgs>): Prisma__usersClient<usersGetPayload<T> | Null>;

    recever_account<T extends PaymentAccountArgs= {}>(args?: Subset<T, PaymentAccountArgs>): Prisma__PaymentAccountClient<PaymentAccountGetPayload<T> | Null>;

    sender_account<T extends PaymentAccountArgs= {}>(args?: Subset<T, PaymentAccountArgs>): Prisma__PaymentAccountClient<PaymentAccountGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * payment base type for findUnique actions
   */
  export type paymentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: paymentInclude | null
    /**
     * Filter, which payment to fetch.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment findUnique
   */
  export interface paymentFindUniqueArgs extends paymentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * payment findUniqueOrThrow
   */
  export type paymentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: paymentInclude | null
    /**
     * Filter, which payment to fetch.
     */
    where: paymentWhereUniqueInput
  }


  /**
   * payment base type for findFirst actions
   */
  export type paymentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: paymentInclude | null
    /**
     * Filter, which payment to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: Enumerable<paymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }

  /**
   * payment findFirst
   */
  export interface paymentFindFirstArgs extends paymentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * payment findFirstOrThrow
   */
  export type paymentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: paymentInclude | null
    /**
     * Filter, which payment to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: Enumerable<paymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * payment findMany
   */
  export type paymentFindManyArgs = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: paymentInclude | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: Enumerable<paymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * payment create
   */
  export type paymentCreateArgs = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: paymentInclude | null
    /**
     * The data needed to create a payment.
     */
    data: XOR<paymentCreateInput, paymentUncheckedCreateInput>
  }


  /**
   * payment createMany
   */
  export type paymentCreateManyArgs = {
    /**
     * The data used to create many payments.
     */
    data: Enumerable<paymentCreateManyInput>
  }


  /**
   * payment update
   */
  export type paymentUpdateArgs = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: paymentInclude | null
    /**
     * The data needed to update a payment.
     */
    data: XOR<paymentUpdateInput, paymentUncheckedUpdateInput>
    /**
     * Choose, which payment to update.
     */
    where: paymentWhereUniqueInput
  }


  /**
   * payment updateMany
   */
  export type paymentUpdateManyArgs = {
    /**
     * The data used to update payments.
     */
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentWhereInput
  }


  /**
   * payment upsert
   */
  export type paymentUpsertArgs = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: paymentInclude | null
    /**
     * The filter to search for the payment to update in case it exists.
     */
    where: paymentWhereUniqueInput
    /**
     * In case the payment found by the `where` argument doesn't exist, create a new payment with this data.
     */
    create: XOR<paymentCreateInput, paymentUncheckedCreateInput>
    /**
     * In case the payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paymentUpdateInput, paymentUncheckedUpdateInput>
  }


  /**
   * payment delete
   */
  export type paymentDeleteArgs = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: paymentInclude | null
    /**
     * Filter which payment to delete.
     */
    where: paymentWhereUniqueInput
  }


  /**
   * payment deleteMany
   */
  export type paymentDeleteManyArgs = {
    /**
     * Filter which payments to delete
     */
    where?: paymentWhereInput
  }


  /**
   * payment findRaw
   */
  export type paymentFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * payment aggregateRaw
   */
  export type paymentAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * payment without action
   */
  export type paymentArgs = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: paymentInclude | null
  }



  /**
   * Model PaymentAccount
   */


  export type AggregatePaymentAccount = {
    _count: PaymentAccountCountAggregateOutputType | null
    _min: PaymentAccountMinAggregateOutputType | null
    _max: PaymentAccountMaxAggregateOutputType | null
  }

  export type PaymentAccountMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
  }

  export type PaymentAccountMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
  }

  export type PaymentAccountCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    uuid: number
    _all: number
  }


  export type PaymentAccountMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
  }

  export type PaymentAccountMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
  }

  export type PaymentAccountCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    _all?: true
  }

  export type PaymentAccountAggregateArgs = {
    /**
     * Filter which PaymentAccount to aggregate.
     */
    where?: PaymentAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAccounts to fetch.
     */
    orderBy?: Enumerable<PaymentAccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentAccounts
    **/
    _count?: true | PaymentAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentAccountMaxAggregateInputType
  }

  export type GetPaymentAccountAggregateType<T extends PaymentAccountAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentAccount[P]>
      : GetScalarType<T[P], AggregatePaymentAccount[P]>
  }




  export type PaymentAccountGroupByArgs = {
    where?: PaymentAccountWhereInput
    orderBy?: Enumerable<PaymentAccountOrderByWithAggregationInput>
    by: PaymentAccountScalarFieldEnum[]
    having?: PaymentAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentAccountCountAggregateInputType | true
    _min?: PaymentAccountMinAggregateInputType
    _max?: PaymentAccountMaxAggregateInputType
  }


  export type PaymentAccountGroupByOutputType = {
    id: string
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string
    _count: PaymentAccountCountAggregateOutputType | null
    _min: PaymentAccountMinAggregateOutputType | null
    _max: PaymentAccountMaxAggregateOutputType | null
  }

  type GetPaymentAccountGroupByPayload<T extends PaymentAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PaymentAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentAccountGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentAccountGroupByOutputType[P]>
        }
      >
    >


  export type PaymentAccountSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uuid?: boolean
    amount?: boolean | CurrencyArgs
    payments_received?: boolean | PaymentAccount$payments_receivedArgs
    payments_sended?: boolean | PaymentAccount$payments_sendedArgs
    _count?: boolean | PaymentAccountCountOutputTypeArgs
  }


  export type PaymentAccountInclude = {
    payments_received?: boolean | PaymentAccount$payments_receivedArgs
    payments_sended?: boolean | PaymentAccount$payments_sendedArgs
    _count?: boolean | PaymentAccountCountOutputTypeArgs
  }

  export type PaymentAccountGetPayload<S extends boolean | null | undefined | PaymentAccountArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PaymentAccount :
    S extends undefined ? never :
    S extends { include: any } & (PaymentAccountArgs | PaymentAccountFindManyArgs)
    ? PaymentAccount  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'payments_received' ? Array < paymentGetPayload<S['include'][P]>>  :
        P extends 'payments_sended' ? Array < paymentGetPayload<S['include'][P]>>  :
        P extends '_count' ? PaymentAccountCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PaymentAccountArgs | PaymentAccountFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'amount' ? CurrencyGetPayload<S['select'][P]> :
        P extends 'payments_received' ? Array < paymentGetPayload<S['select'][P]>>  :
        P extends 'payments_sended' ? Array < paymentGetPayload<S['select'][P]>>  :
        P extends '_count' ? PaymentAccountCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof PaymentAccount ? PaymentAccount[P] : never
  } 
      : PaymentAccount


  type PaymentAccountCountArgs = 
    Omit<PaymentAccountFindManyArgs, 'select' | 'include'> & {
      select?: PaymentAccountCountAggregateInputType | true
    }

  export interface PaymentAccountDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one PaymentAccount that matches the filter.
     * @param {PaymentAccountFindUniqueArgs} args - Arguments to find a PaymentAccount
     * @example
     * // Get one PaymentAccount
     * const paymentAccount = await prisma.paymentAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PaymentAccountFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PaymentAccountFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PaymentAccount'> extends True ? Prisma__PaymentAccountClient<PaymentAccountGetPayload<T>> : Prisma__PaymentAccountClient<PaymentAccountGetPayload<T> | null, null>

    /**
     * Find one PaymentAccount that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PaymentAccountFindUniqueOrThrowArgs} args - Arguments to find a PaymentAccount
     * @example
     * // Get one PaymentAccount
     * const paymentAccount = await prisma.paymentAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PaymentAccountFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PaymentAccountFindUniqueOrThrowArgs>
    ): Prisma__PaymentAccountClient<PaymentAccountGetPayload<T>>

    /**
     * Find the first PaymentAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAccountFindFirstArgs} args - Arguments to find a PaymentAccount
     * @example
     * // Get one PaymentAccount
     * const paymentAccount = await prisma.paymentAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PaymentAccountFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PaymentAccountFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PaymentAccount'> extends True ? Prisma__PaymentAccountClient<PaymentAccountGetPayload<T>> : Prisma__PaymentAccountClient<PaymentAccountGetPayload<T> | null, null>

    /**
     * Find the first PaymentAccount that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAccountFindFirstOrThrowArgs} args - Arguments to find a PaymentAccount
     * @example
     * // Get one PaymentAccount
     * const paymentAccount = await prisma.paymentAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PaymentAccountFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PaymentAccountFindFirstOrThrowArgs>
    ): Prisma__PaymentAccountClient<PaymentAccountGetPayload<T>>

    /**
     * Find zero or more PaymentAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentAccounts
     * const paymentAccounts = await prisma.paymentAccount.findMany()
     * 
     * // Get first 10 PaymentAccounts
     * const paymentAccounts = await prisma.paymentAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentAccountWithIdOnly = await prisma.paymentAccount.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PaymentAccountFindManyArgs>(
      args?: SelectSubset<T, PaymentAccountFindManyArgs>
    ): Prisma.PrismaPromise<Array<PaymentAccountGetPayload<T>>>

    /**
     * Create a PaymentAccount.
     * @param {PaymentAccountCreateArgs} args - Arguments to create a PaymentAccount.
     * @example
     * // Create one PaymentAccount
     * const PaymentAccount = await prisma.paymentAccount.create({
     *   data: {
     *     // ... data to create a PaymentAccount
     *   }
     * })
     * 
    **/
    create<T extends PaymentAccountCreateArgs>(
      args: SelectSubset<T, PaymentAccountCreateArgs>
    ): Prisma__PaymentAccountClient<PaymentAccountGetPayload<T>>

    /**
     * Create many PaymentAccounts.
     *     @param {PaymentAccountCreateManyArgs} args - Arguments to create many PaymentAccounts.
     *     @example
     *     // Create many PaymentAccounts
     *     const paymentAccount = await prisma.paymentAccount.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PaymentAccountCreateManyArgs>(
      args?: SelectSubset<T, PaymentAccountCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PaymentAccount.
     * @param {PaymentAccountDeleteArgs} args - Arguments to delete one PaymentAccount.
     * @example
     * // Delete one PaymentAccount
     * const PaymentAccount = await prisma.paymentAccount.delete({
     *   where: {
     *     // ... filter to delete one PaymentAccount
     *   }
     * })
     * 
    **/
    delete<T extends PaymentAccountDeleteArgs>(
      args: SelectSubset<T, PaymentAccountDeleteArgs>
    ): Prisma__PaymentAccountClient<PaymentAccountGetPayload<T>>

    /**
     * Update one PaymentAccount.
     * @param {PaymentAccountUpdateArgs} args - Arguments to update one PaymentAccount.
     * @example
     * // Update one PaymentAccount
     * const paymentAccount = await prisma.paymentAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PaymentAccountUpdateArgs>(
      args: SelectSubset<T, PaymentAccountUpdateArgs>
    ): Prisma__PaymentAccountClient<PaymentAccountGetPayload<T>>

    /**
     * Delete zero or more PaymentAccounts.
     * @param {PaymentAccountDeleteManyArgs} args - Arguments to filter PaymentAccounts to delete.
     * @example
     * // Delete a few PaymentAccounts
     * const { count } = await prisma.paymentAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PaymentAccountDeleteManyArgs>(
      args?: SelectSubset<T, PaymentAccountDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentAccounts
     * const paymentAccount = await prisma.paymentAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PaymentAccountUpdateManyArgs>(
      args: SelectSubset<T, PaymentAccountUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentAccount.
     * @param {PaymentAccountUpsertArgs} args - Arguments to update or create a PaymentAccount.
     * @example
     * // Update or create a PaymentAccount
     * const paymentAccount = await prisma.paymentAccount.upsert({
     *   create: {
     *     // ... data to create a PaymentAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentAccount we want to update
     *   }
     * })
    **/
    upsert<T extends PaymentAccountUpsertArgs>(
      args: SelectSubset<T, PaymentAccountUpsertArgs>
    ): Prisma__PaymentAccountClient<PaymentAccountGetPayload<T>>

    /**
     * Find zero or more PaymentAccounts that matches the filter.
     * @param {PaymentAccountFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const paymentAccount = await prisma.paymentAccount.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: PaymentAccountFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a PaymentAccount.
     * @param {PaymentAccountAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const paymentAccount = await prisma.paymentAccount.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: PaymentAccountAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of PaymentAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAccountCountArgs} args - Arguments to filter PaymentAccounts to count.
     * @example
     * // Count the number of PaymentAccounts
     * const count = await prisma.paymentAccount.count({
     *   where: {
     *     // ... the filter for the PaymentAccounts we want to count
     *   }
     * })
    **/
    count<T extends PaymentAccountCountArgs>(
      args?: Subset<T, PaymentAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAccountAggregateArgs>(args: Subset<T, PaymentAccountAggregateArgs>): Prisma.PrismaPromise<GetPaymentAccountAggregateType<T>>

    /**
     * Group by PaymentAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentAccountGroupByArgs['orderBy'] }
        : { orderBy?: PaymentAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PaymentAccountClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    amount<T extends CurrencyArgs= {}>(args?: Subset<T, CurrencyArgs>): Prisma__CurrencyClient<CurrencyGetPayload<T> | Null>;

    payments_received<T extends PaymentAccount$payments_receivedArgs= {}>(args?: Subset<T, PaymentAccount$payments_receivedArgs>): Prisma.PrismaPromise<Array<paymentGetPayload<T>>| Null>;

    payments_sended<T extends PaymentAccount$payments_sendedArgs= {}>(args?: Subset<T, PaymentAccount$payments_sendedArgs>): Prisma.PrismaPromise<Array<paymentGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PaymentAccount base type for findUnique actions
   */
  export type PaymentAccountFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PaymentAccount
     */
    select?: PaymentAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentAccountInclude | null
    /**
     * Filter, which PaymentAccount to fetch.
     */
    where: PaymentAccountWhereUniqueInput
  }

  /**
   * PaymentAccount findUnique
   */
  export interface PaymentAccountFindUniqueArgs extends PaymentAccountFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PaymentAccount findUniqueOrThrow
   */
  export type PaymentAccountFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PaymentAccount
     */
    select?: PaymentAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentAccountInclude | null
    /**
     * Filter, which PaymentAccount to fetch.
     */
    where: PaymentAccountWhereUniqueInput
  }


  /**
   * PaymentAccount base type for findFirst actions
   */
  export type PaymentAccountFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PaymentAccount
     */
    select?: PaymentAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentAccountInclude | null
    /**
     * Filter, which PaymentAccount to fetch.
     */
    where?: PaymentAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAccounts to fetch.
     */
    orderBy?: Enumerable<PaymentAccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentAccounts.
     */
    cursor?: PaymentAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentAccounts.
     */
    distinct?: Enumerable<PaymentAccountScalarFieldEnum>
  }

  /**
   * PaymentAccount findFirst
   */
  export interface PaymentAccountFindFirstArgs extends PaymentAccountFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PaymentAccount findFirstOrThrow
   */
  export type PaymentAccountFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PaymentAccount
     */
    select?: PaymentAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentAccountInclude | null
    /**
     * Filter, which PaymentAccount to fetch.
     */
    where?: PaymentAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAccounts to fetch.
     */
    orderBy?: Enumerable<PaymentAccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentAccounts.
     */
    cursor?: PaymentAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentAccounts.
     */
    distinct?: Enumerable<PaymentAccountScalarFieldEnum>
  }


  /**
   * PaymentAccount findMany
   */
  export type PaymentAccountFindManyArgs = {
    /**
     * Select specific fields to fetch from the PaymentAccount
     */
    select?: PaymentAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentAccountInclude | null
    /**
     * Filter, which PaymentAccounts to fetch.
     */
    where?: PaymentAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAccounts to fetch.
     */
    orderBy?: Enumerable<PaymentAccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentAccounts.
     */
    cursor?: PaymentAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAccounts.
     */
    skip?: number
    distinct?: Enumerable<PaymentAccountScalarFieldEnum>
  }


  /**
   * PaymentAccount create
   */
  export type PaymentAccountCreateArgs = {
    /**
     * Select specific fields to fetch from the PaymentAccount
     */
    select?: PaymentAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentAccountInclude | null
    /**
     * The data needed to create a PaymentAccount.
     */
    data: XOR<PaymentAccountCreateInput, PaymentAccountUncheckedCreateInput>
  }


  /**
   * PaymentAccount createMany
   */
  export type PaymentAccountCreateManyArgs = {
    /**
     * The data used to create many PaymentAccounts.
     */
    data: Enumerable<PaymentAccountCreateManyInput>
  }


  /**
   * PaymentAccount update
   */
  export type PaymentAccountUpdateArgs = {
    /**
     * Select specific fields to fetch from the PaymentAccount
     */
    select?: PaymentAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentAccountInclude | null
    /**
     * The data needed to update a PaymentAccount.
     */
    data: XOR<PaymentAccountUpdateInput, PaymentAccountUncheckedUpdateInput>
    /**
     * Choose, which PaymentAccount to update.
     */
    where: PaymentAccountWhereUniqueInput
  }


  /**
   * PaymentAccount updateMany
   */
  export type PaymentAccountUpdateManyArgs = {
    /**
     * The data used to update PaymentAccounts.
     */
    data: XOR<PaymentAccountUpdateManyMutationInput, PaymentAccountUncheckedUpdateManyInput>
    /**
     * Filter which PaymentAccounts to update
     */
    where?: PaymentAccountWhereInput
  }


  /**
   * PaymentAccount upsert
   */
  export type PaymentAccountUpsertArgs = {
    /**
     * Select specific fields to fetch from the PaymentAccount
     */
    select?: PaymentAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentAccountInclude | null
    /**
     * The filter to search for the PaymentAccount to update in case it exists.
     */
    where: PaymentAccountWhereUniqueInput
    /**
     * In case the PaymentAccount found by the `where` argument doesn't exist, create a new PaymentAccount with this data.
     */
    create: XOR<PaymentAccountCreateInput, PaymentAccountUncheckedCreateInput>
    /**
     * In case the PaymentAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentAccountUpdateInput, PaymentAccountUncheckedUpdateInput>
  }


  /**
   * PaymentAccount delete
   */
  export type PaymentAccountDeleteArgs = {
    /**
     * Select specific fields to fetch from the PaymentAccount
     */
    select?: PaymentAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentAccountInclude | null
    /**
     * Filter which PaymentAccount to delete.
     */
    where: PaymentAccountWhereUniqueInput
  }


  /**
   * PaymentAccount deleteMany
   */
  export type PaymentAccountDeleteManyArgs = {
    /**
     * Filter which PaymentAccounts to delete
     */
    where?: PaymentAccountWhereInput
  }


  /**
   * PaymentAccount findRaw
   */
  export type PaymentAccountFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * PaymentAccount aggregateRaw
   */
  export type PaymentAccountAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * PaymentAccount.payments_received
   */
  export type PaymentAccount$payments_receivedArgs = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: paymentInclude | null
    where?: paymentWhereInput
    orderBy?: Enumerable<paymentOrderByWithRelationInput>
    cursor?: paymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * PaymentAccount.payments_sended
   */
  export type PaymentAccount$payments_sendedArgs = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: paymentInclude | null
    where?: paymentWhereInput
    orderBy?: Enumerable<paymentOrderByWithRelationInput>
    cursor?: paymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * PaymentAccount without action
   */
  export type PaymentAccountArgs = {
    /**
     * Select specific fields to fetch from the PaymentAccount
     */
    select?: PaymentAccountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentAccountInclude | null
  }



  /**
   * Model items
   */


  export type AggregateItems = {
    _count: ItemsCountAggregateOutputType | null
    _min: ItemsMinAggregateOutputType | null
    _max: ItemsMaxAggregateOutputType | null
  }

  export type ItemsMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
    name: string | null
    description: string | null
  }

  export type ItemsMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
    name: string | null
    description: string | null
  }

  export type ItemsCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    uuid: number
    name: number
    description: number
    tags: number
    image_ids: number
    _all: number
  }


  export type ItemsMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    name?: true
    description?: true
  }

  export type ItemsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    name?: true
    description?: true
  }

  export type ItemsCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    name?: true
    description?: true
    tags?: true
    image_ids?: true
    _all?: true
  }

  export type ItemsAggregateArgs = {
    /**
     * Filter which items to aggregate.
     */
    where?: itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items to fetch.
     */
    orderBy?: Enumerable<itemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned items
    **/
    _count?: true | ItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemsMaxAggregateInputType
  }

  export type GetItemsAggregateType<T extends ItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItems[P]>
      : GetScalarType<T[P], AggregateItems[P]>
  }




  export type ItemsGroupByArgs = {
    where?: itemsWhereInput
    orderBy?: Enumerable<itemsOrderByWithAggregationInput>
    by: ItemsScalarFieldEnum[]
    having?: itemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemsCountAggregateInputType | true
    _min?: ItemsMinAggregateInputType
    _max?: ItemsMaxAggregateInputType
  }


  export type ItemsGroupByOutputType = {
    id: string
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string
    name: string | null
    description: string | null
    tags: string[]
    image_ids: string[]
    _count: ItemsCountAggregateOutputType | null
    _min: ItemsMinAggregateOutputType | null
    _max: ItemsMaxAggregateOutputType | null
  }

  type GetItemsGroupByPayload<T extends ItemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemsGroupByOutputType[P]>
            : GetScalarType<T[P], ItemsGroupByOutputType[P]>
        }
      >
    >


  export type itemsSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uuid?: boolean
    name?: boolean
    description?: boolean
    tags?: boolean
    image_ids?: boolean
    prices?: boolean | CurrencyArgs
    images?: boolean | items$imagesArgs
    item_inventories?: boolean | items$item_inventoriesArgs
    item_orders?: boolean | items$item_ordersArgs
    _count?: boolean | ItemsCountOutputTypeArgs
  }


  export type itemsInclude = {
    images?: boolean | items$imagesArgs
    item_inventories?: boolean | items$item_inventoriesArgs
    item_orders?: boolean | items$item_ordersArgs
    _count?: boolean | ItemsCountOutputTypeArgs
  }

  export type itemsGetPayload<S extends boolean | null | undefined | itemsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? items :
    S extends undefined ? never :
    S extends { include: any } & (itemsArgs | itemsFindManyArgs)
    ? items  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'images' ? Array < imagesGetPayload<S['include'][P]>>  :
        P extends 'item_inventories' ? Array < item_inventoriesGetPayload<S['include'][P]>>  :
        P extends 'item_orders' ? Array < item_ordersGetPayload<S['include'][P]>>  :
        P extends '_count' ? ItemsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (itemsArgs | itemsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'prices' ? Array < CurrencyGetPayload<S['select'][P]>>  :
        P extends 'images' ? Array < imagesGetPayload<S['select'][P]>>  :
        P extends 'item_inventories' ? Array < item_inventoriesGetPayload<S['select'][P]>>  :
        P extends 'item_orders' ? Array < item_ordersGetPayload<S['select'][P]>>  :
        P extends '_count' ? ItemsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof items ? items[P] : never
  } 
      : items


  type itemsCountArgs = 
    Omit<itemsFindManyArgs, 'select' | 'include'> & {
      select?: ItemsCountAggregateInputType | true
    }

  export interface itemsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Items that matches the filter.
     * @param {itemsFindUniqueArgs} args - Arguments to find a Items
     * @example
     * // Get one Items
     * const items = await prisma.items.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends itemsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, itemsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'items'> extends True ? Prisma__itemsClient<itemsGetPayload<T>> : Prisma__itemsClient<itemsGetPayload<T> | null, null>

    /**
     * Find one Items that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {itemsFindUniqueOrThrowArgs} args - Arguments to find a Items
     * @example
     * // Get one Items
     * const items = await prisma.items.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends itemsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, itemsFindUniqueOrThrowArgs>
    ): Prisma__itemsClient<itemsGetPayload<T>>

    /**
     * Find the first Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsFindFirstArgs} args - Arguments to find a Items
     * @example
     * // Get one Items
     * const items = await prisma.items.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends itemsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, itemsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'items'> extends True ? Prisma__itemsClient<itemsGetPayload<T>> : Prisma__itemsClient<itemsGetPayload<T> | null, null>

    /**
     * Find the first Items that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsFindFirstOrThrowArgs} args - Arguments to find a Items
     * @example
     * // Get one Items
     * const items = await prisma.items.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends itemsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, itemsFindFirstOrThrowArgs>
    ): Prisma__itemsClient<itemsGetPayload<T>>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.items.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.items.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemsWithIdOnly = await prisma.items.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends itemsFindManyArgs>(
      args?: SelectSubset<T, itemsFindManyArgs>
    ): Prisma.PrismaPromise<Array<itemsGetPayload<T>>>

    /**
     * Create a Items.
     * @param {itemsCreateArgs} args - Arguments to create a Items.
     * @example
     * // Create one Items
     * const Items = await prisma.items.create({
     *   data: {
     *     // ... data to create a Items
     *   }
     * })
     * 
    **/
    create<T extends itemsCreateArgs>(
      args: SelectSubset<T, itemsCreateArgs>
    ): Prisma__itemsClient<itemsGetPayload<T>>

    /**
     * Create many Items.
     *     @param {itemsCreateManyArgs} args - Arguments to create many Items.
     *     @example
     *     // Create many Items
     *     const items = await prisma.items.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends itemsCreateManyArgs>(
      args?: SelectSubset<T, itemsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Items.
     * @param {itemsDeleteArgs} args - Arguments to delete one Items.
     * @example
     * // Delete one Items
     * const Items = await prisma.items.delete({
     *   where: {
     *     // ... filter to delete one Items
     *   }
     * })
     * 
    **/
    delete<T extends itemsDeleteArgs>(
      args: SelectSubset<T, itemsDeleteArgs>
    ): Prisma__itemsClient<itemsGetPayload<T>>

    /**
     * Update one Items.
     * @param {itemsUpdateArgs} args - Arguments to update one Items.
     * @example
     * // Update one Items
     * const items = await prisma.items.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends itemsUpdateArgs>(
      args: SelectSubset<T, itemsUpdateArgs>
    ): Prisma__itemsClient<itemsGetPayload<T>>

    /**
     * Delete zero or more Items.
     * @param {itemsDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.items.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends itemsDeleteManyArgs>(
      args?: SelectSubset<T, itemsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const items = await prisma.items.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends itemsUpdateManyArgs>(
      args: SelectSubset<T, itemsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Items.
     * @param {itemsUpsertArgs} args - Arguments to update or create a Items.
     * @example
     * // Update or create a Items
     * const items = await prisma.items.upsert({
     *   create: {
     *     // ... data to create a Items
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Items we want to update
     *   }
     * })
    **/
    upsert<T extends itemsUpsertArgs>(
      args: SelectSubset<T, itemsUpsertArgs>
    ): Prisma__itemsClient<itemsGetPayload<T>>

    /**
     * Find zero or more Items that matches the filter.
     * @param {itemsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const items = await prisma.items.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: itemsFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Items.
     * @param {itemsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const items = await prisma.items.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: itemsAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.items.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends itemsCountArgs>(
      args?: Subset<T, itemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemsAggregateArgs>(args: Subset<T, ItemsAggregateArgs>): Prisma.PrismaPromise<GetItemsAggregateType<T>>

    /**
     * Group by Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemsGroupByArgs['orderBy'] }
        : { orderBy?: ItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for items.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__itemsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    prices<T extends CurrencyArgs= {}>(args?: Subset<T, CurrencyArgs>): Prisma.PrismaPromise<Array<CurrencyGetPayload<T>>| Null>;

    images<T extends items$imagesArgs= {}>(args?: Subset<T, items$imagesArgs>): Prisma.PrismaPromise<Array<imagesGetPayload<T>>| Null>;

    item_inventories<T extends items$item_inventoriesArgs= {}>(args?: Subset<T, items$item_inventoriesArgs>): Prisma.PrismaPromise<Array<item_inventoriesGetPayload<T>>| Null>;

    item_orders<T extends items$item_ordersArgs= {}>(args?: Subset<T, items$item_ordersArgs>): Prisma.PrismaPromise<Array<item_ordersGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * items base type for findUnique actions
   */
  export type itemsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: itemsInclude | null
    /**
     * Filter, which items to fetch.
     */
    where: itemsWhereUniqueInput
  }

  /**
   * items findUnique
   */
  export interface itemsFindUniqueArgs extends itemsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * items findUniqueOrThrow
   */
  export type itemsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: itemsInclude | null
    /**
     * Filter, which items to fetch.
     */
    where: itemsWhereUniqueInput
  }


  /**
   * items base type for findFirst actions
   */
  export type itemsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: itemsInclude | null
    /**
     * Filter, which items to fetch.
     */
    where?: itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items to fetch.
     */
    orderBy?: Enumerable<itemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for items.
     */
    cursor?: itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of items.
     */
    distinct?: Enumerable<ItemsScalarFieldEnum>
  }

  /**
   * items findFirst
   */
  export interface itemsFindFirstArgs extends itemsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * items findFirstOrThrow
   */
  export type itemsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: itemsInclude | null
    /**
     * Filter, which items to fetch.
     */
    where?: itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items to fetch.
     */
    orderBy?: Enumerable<itemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for items.
     */
    cursor?: itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of items.
     */
    distinct?: Enumerable<ItemsScalarFieldEnum>
  }


  /**
   * items findMany
   */
  export type itemsFindManyArgs = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: itemsInclude | null
    /**
     * Filter, which items to fetch.
     */
    where?: itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items to fetch.
     */
    orderBy?: Enumerable<itemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing items.
     */
    cursor?: itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items.
     */
    skip?: number
    distinct?: Enumerable<ItemsScalarFieldEnum>
  }


  /**
   * items create
   */
  export type itemsCreateArgs = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: itemsInclude | null
    /**
     * The data needed to create a items.
     */
    data: XOR<itemsCreateInput, itemsUncheckedCreateInput>
  }


  /**
   * items createMany
   */
  export type itemsCreateManyArgs = {
    /**
     * The data used to create many items.
     */
    data: Enumerable<itemsCreateManyInput>
  }


  /**
   * items update
   */
  export type itemsUpdateArgs = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: itemsInclude | null
    /**
     * The data needed to update a items.
     */
    data: XOR<itemsUpdateInput, itemsUncheckedUpdateInput>
    /**
     * Choose, which items to update.
     */
    where: itemsWhereUniqueInput
  }


  /**
   * items updateMany
   */
  export type itemsUpdateManyArgs = {
    /**
     * The data used to update items.
     */
    data: XOR<itemsUpdateManyMutationInput, itemsUncheckedUpdateManyInput>
    /**
     * Filter which items to update
     */
    where?: itemsWhereInput
  }


  /**
   * items upsert
   */
  export type itemsUpsertArgs = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: itemsInclude | null
    /**
     * The filter to search for the items to update in case it exists.
     */
    where: itemsWhereUniqueInput
    /**
     * In case the items found by the `where` argument doesn't exist, create a new items with this data.
     */
    create: XOR<itemsCreateInput, itemsUncheckedCreateInput>
    /**
     * In case the items was found with the provided `where` argument, update it with this data.
     */
    update: XOR<itemsUpdateInput, itemsUncheckedUpdateInput>
  }


  /**
   * items delete
   */
  export type itemsDeleteArgs = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: itemsInclude | null
    /**
     * Filter which items to delete.
     */
    where: itemsWhereUniqueInput
  }


  /**
   * items deleteMany
   */
  export type itemsDeleteManyArgs = {
    /**
     * Filter which items to delete
     */
    where?: itemsWhereInput
  }


  /**
   * items findRaw
   */
  export type itemsFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * items aggregateRaw
   */
  export type itemsAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * items.images
   */
  export type items$imagesArgs = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagesInclude | null
    where?: imagesWhereInput
    orderBy?: Enumerable<imagesOrderByWithRelationInput>
    cursor?: imagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ImagesScalarFieldEnum>
  }


  /**
   * items.item_inventories
   */
  export type items$item_inventoriesArgs = {
    /**
     * Select specific fields to fetch from the item_inventories
     */
    select?: item_inventoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: item_inventoriesInclude | null
    where?: item_inventoriesWhereInput
    orderBy?: Enumerable<item_inventoriesOrderByWithRelationInput>
    cursor?: item_inventoriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Item_inventoriesScalarFieldEnum>
  }


  /**
   * items.item_orders
   */
  export type items$item_ordersArgs = {
    /**
     * Select specific fields to fetch from the item_orders
     */
    select?: item_ordersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: item_ordersInclude | null
    where?: item_ordersWhereInput
    orderBy?: Enumerable<item_ordersOrderByWithRelationInput>
    cursor?: item_ordersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Item_ordersScalarFieldEnum>
  }


  /**
   * items without action
   */
  export type itemsArgs = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: itemsInclude | null
  }



  /**
   * Model locations
   */


  export type AggregateLocations = {
    _count: LocationsCountAggregateOutputType | null
    _avg: LocationsAvgAggregateOutputType | null
    _sum: LocationsSumAggregateOutputType | null
    _min: LocationsMinAggregateOutputType | null
    _max: LocationsMaxAggregateOutputType | null
  }

  export type LocationsAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type LocationsSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type LocationsMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
    name: string | null
    latitude: number | null
    longitude: number | null
  }

  export type LocationsMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
    name: string | null
    latitude: number | null
    longitude: number | null
  }

  export type LocationsCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    uuid: number
    name: number
    latitude: number
    longitude: number
    user_ids: number
    organizations_ids: number
    store_ids: number
    _all: number
  }


  export type LocationsAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type LocationsSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type LocationsMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    name?: true
    latitude?: true
    longitude?: true
  }

  export type LocationsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    name?: true
    latitude?: true
    longitude?: true
  }

  export type LocationsCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    name?: true
    latitude?: true
    longitude?: true
    user_ids?: true
    organizations_ids?: true
    store_ids?: true
    _all?: true
  }

  export type LocationsAggregateArgs = {
    /**
     * Filter which locations to aggregate.
     */
    where?: locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: Enumerable<locationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned locations
    **/
    _count?: true | LocationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationsMaxAggregateInputType
  }

  export type GetLocationsAggregateType<T extends LocationsAggregateArgs> = {
        [P in keyof T & keyof AggregateLocations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocations[P]>
      : GetScalarType<T[P], AggregateLocations[P]>
  }




  export type LocationsGroupByArgs = {
    where?: locationsWhereInput
    orderBy?: Enumerable<locationsOrderByWithAggregationInput>
    by: LocationsScalarFieldEnum[]
    having?: locationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationsCountAggregateInputType | true
    _avg?: LocationsAvgAggregateInputType
    _sum?: LocationsSumAggregateInputType
    _min?: LocationsMinAggregateInputType
    _max?: LocationsMaxAggregateInputType
  }


  export type LocationsGroupByOutputType = {
    id: string
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string
    name: string | null
    latitude: number | null
    longitude: number | null
    user_ids: string[]
    organizations_ids: string[]
    store_ids: string[]
    _count: LocationsCountAggregateOutputType | null
    _avg: LocationsAvgAggregateOutputType | null
    _sum: LocationsSumAggregateOutputType | null
    _min: LocationsMinAggregateOutputType | null
    _max: LocationsMaxAggregateOutputType | null
  }

  type GetLocationsGroupByPayload<T extends LocationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LocationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationsGroupByOutputType[P]>
            : GetScalarType<T[P], LocationsGroupByOutputType[P]>
        }
      >
    >


  export type locationsSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uuid?: boolean
    name?: boolean
    latitude?: boolean
    longitude?: boolean
    user_ids?: boolean
    organizations_ids?: boolean
    store_ids?: boolean
    users?: boolean | locations$usersArgs
    organizations?: boolean | locations$organizationsArgs
    stores?: boolean | locations$storesArgs
    users_prefered?: boolean | locations$users_preferedArgs
    _count?: boolean | LocationsCountOutputTypeArgs
  }


  export type locationsInclude = {
    users?: boolean | locations$usersArgs
    organizations?: boolean | locations$organizationsArgs
    stores?: boolean | locations$storesArgs
    users_prefered?: boolean | locations$users_preferedArgs
    _count?: boolean | LocationsCountOutputTypeArgs
  }

  export type locationsGetPayload<S extends boolean | null | undefined | locationsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? locations :
    S extends undefined ? never :
    S extends { include: any } & (locationsArgs | locationsFindManyArgs)
    ? locations  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'users' ? Array < usersGetPayload<S['include'][P]>>  :
        P extends 'organizations' ? Array < organizationsGetPayload<S['include'][P]>>  :
        P extends 'stores' ? Array < storesGetPayload<S['include'][P]>>  :
        P extends 'users_prefered' ? Array < usersGetPayload<S['include'][P]>>  :
        P extends '_count' ? LocationsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (locationsArgs | locationsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'users' ? Array < usersGetPayload<S['select'][P]>>  :
        P extends 'organizations' ? Array < organizationsGetPayload<S['select'][P]>>  :
        P extends 'stores' ? Array < storesGetPayload<S['select'][P]>>  :
        P extends 'users_prefered' ? Array < usersGetPayload<S['select'][P]>>  :
        P extends '_count' ? LocationsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof locations ? locations[P] : never
  } 
      : locations


  type locationsCountArgs = 
    Omit<locationsFindManyArgs, 'select' | 'include'> & {
      select?: LocationsCountAggregateInputType | true
    }

  export interface locationsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Locations that matches the filter.
     * @param {locationsFindUniqueArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends locationsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, locationsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'locations'> extends True ? Prisma__locationsClient<locationsGetPayload<T>> : Prisma__locationsClient<locationsGetPayload<T> | null, null>

    /**
     * Find one Locations that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {locationsFindUniqueOrThrowArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends locationsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, locationsFindUniqueOrThrowArgs>
    ): Prisma__locationsClient<locationsGetPayload<T>>

    /**
     * Find the first Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsFindFirstArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends locationsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, locationsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'locations'> extends True ? Prisma__locationsClient<locationsGetPayload<T>> : Prisma__locationsClient<locationsGetPayload<T> | null, null>

    /**
     * Find the first Locations that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsFindFirstOrThrowArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends locationsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, locationsFindFirstOrThrowArgs>
    ): Prisma__locationsClient<locationsGetPayload<T>>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.locations.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.locations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationsWithIdOnly = await prisma.locations.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends locationsFindManyArgs>(
      args?: SelectSubset<T, locationsFindManyArgs>
    ): Prisma.PrismaPromise<Array<locationsGetPayload<T>>>

    /**
     * Create a Locations.
     * @param {locationsCreateArgs} args - Arguments to create a Locations.
     * @example
     * // Create one Locations
     * const Locations = await prisma.locations.create({
     *   data: {
     *     // ... data to create a Locations
     *   }
     * })
     * 
    **/
    create<T extends locationsCreateArgs>(
      args: SelectSubset<T, locationsCreateArgs>
    ): Prisma__locationsClient<locationsGetPayload<T>>

    /**
     * Create many Locations.
     *     @param {locationsCreateManyArgs} args - Arguments to create many Locations.
     *     @example
     *     // Create many Locations
     *     const locations = await prisma.locations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends locationsCreateManyArgs>(
      args?: SelectSubset<T, locationsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Locations.
     * @param {locationsDeleteArgs} args - Arguments to delete one Locations.
     * @example
     * // Delete one Locations
     * const Locations = await prisma.locations.delete({
     *   where: {
     *     // ... filter to delete one Locations
     *   }
     * })
     * 
    **/
    delete<T extends locationsDeleteArgs>(
      args: SelectSubset<T, locationsDeleteArgs>
    ): Prisma__locationsClient<locationsGetPayload<T>>

    /**
     * Update one Locations.
     * @param {locationsUpdateArgs} args - Arguments to update one Locations.
     * @example
     * // Update one Locations
     * const locations = await prisma.locations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends locationsUpdateArgs>(
      args: SelectSubset<T, locationsUpdateArgs>
    ): Prisma__locationsClient<locationsGetPayload<T>>

    /**
     * Delete zero or more Locations.
     * @param {locationsDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.locations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends locationsDeleteManyArgs>(
      args?: SelectSubset<T, locationsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const locations = await prisma.locations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends locationsUpdateManyArgs>(
      args: SelectSubset<T, locationsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Locations.
     * @param {locationsUpsertArgs} args - Arguments to update or create a Locations.
     * @example
     * // Update or create a Locations
     * const locations = await prisma.locations.upsert({
     *   create: {
     *     // ... data to create a Locations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Locations we want to update
     *   }
     * })
    **/
    upsert<T extends locationsUpsertArgs>(
      args: SelectSubset<T, locationsUpsertArgs>
    ): Prisma__locationsClient<locationsGetPayload<T>>

    /**
     * Find zero or more Locations that matches the filter.
     * @param {locationsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const locations = await prisma.locations.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: locationsFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Locations.
     * @param {locationsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const locations = await prisma.locations.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: locationsAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.locations.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends locationsCountArgs>(
      args?: Subset<T, locationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationsAggregateArgs>(args: Subset<T, LocationsAggregateArgs>): Prisma.PrismaPromise<GetLocationsAggregateType<T>>

    /**
     * Group by Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationsGroupByArgs['orderBy'] }
        : { orderBy?: LocationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for locations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__locationsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    users<T extends locations$usersArgs= {}>(args?: Subset<T, locations$usersArgs>): Prisma.PrismaPromise<Array<usersGetPayload<T>>| Null>;

    organizations<T extends locations$organizationsArgs= {}>(args?: Subset<T, locations$organizationsArgs>): Prisma.PrismaPromise<Array<organizationsGetPayload<T>>| Null>;

    stores<T extends locations$storesArgs= {}>(args?: Subset<T, locations$storesArgs>): Prisma.PrismaPromise<Array<storesGetPayload<T>>| Null>;

    users_prefered<T extends locations$users_preferedArgs= {}>(args?: Subset<T, locations$users_preferedArgs>): Prisma.PrismaPromise<Array<usersGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * locations base type for findUnique actions
   */
  export type locationsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: locationsInclude | null
    /**
     * Filter, which locations to fetch.
     */
    where: locationsWhereUniqueInput
  }

  /**
   * locations findUnique
   */
  export interface locationsFindUniqueArgs extends locationsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * locations findUniqueOrThrow
   */
  export type locationsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: locationsInclude | null
    /**
     * Filter, which locations to fetch.
     */
    where: locationsWhereUniqueInput
  }


  /**
   * locations base type for findFirst actions
   */
  export type locationsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: locationsInclude | null
    /**
     * Filter, which locations to fetch.
     */
    where?: locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: Enumerable<locationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locations.
     */
    cursor?: locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locations.
     */
    distinct?: Enumerable<LocationsScalarFieldEnum>
  }

  /**
   * locations findFirst
   */
  export interface locationsFindFirstArgs extends locationsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * locations findFirstOrThrow
   */
  export type locationsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: locationsInclude | null
    /**
     * Filter, which locations to fetch.
     */
    where?: locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: Enumerable<locationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locations.
     */
    cursor?: locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locations.
     */
    distinct?: Enumerable<LocationsScalarFieldEnum>
  }


  /**
   * locations findMany
   */
  export type locationsFindManyArgs = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: locationsInclude | null
    /**
     * Filter, which locations to fetch.
     */
    where?: locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: Enumerable<locationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing locations.
     */
    cursor?: locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    distinct?: Enumerable<LocationsScalarFieldEnum>
  }


  /**
   * locations create
   */
  export type locationsCreateArgs = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: locationsInclude | null
    /**
     * The data needed to create a locations.
     */
    data: XOR<locationsCreateInput, locationsUncheckedCreateInput>
  }


  /**
   * locations createMany
   */
  export type locationsCreateManyArgs = {
    /**
     * The data used to create many locations.
     */
    data: Enumerable<locationsCreateManyInput>
  }


  /**
   * locations update
   */
  export type locationsUpdateArgs = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: locationsInclude | null
    /**
     * The data needed to update a locations.
     */
    data: XOR<locationsUpdateInput, locationsUncheckedUpdateInput>
    /**
     * Choose, which locations to update.
     */
    where: locationsWhereUniqueInput
  }


  /**
   * locations updateMany
   */
  export type locationsUpdateManyArgs = {
    /**
     * The data used to update locations.
     */
    data: XOR<locationsUpdateManyMutationInput, locationsUncheckedUpdateManyInput>
    /**
     * Filter which locations to update
     */
    where?: locationsWhereInput
  }


  /**
   * locations upsert
   */
  export type locationsUpsertArgs = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: locationsInclude | null
    /**
     * The filter to search for the locations to update in case it exists.
     */
    where: locationsWhereUniqueInput
    /**
     * In case the locations found by the `where` argument doesn't exist, create a new locations with this data.
     */
    create: XOR<locationsCreateInput, locationsUncheckedCreateInput>
    /**
     * In case the locations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<locationsUpdateInput, locationsUncheckedUpdateInput>
  }


  /**
   * locations delete
   */
  export type locationsDeleteArgs = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: locationsInclude | null
    /**
     * Filter which locations to delete.
     */
    where: locationsWhereUniqueInput
  }


  /**
   * locations deleteMany
   */
  export type locationsDeleteManyArgs = {
    /**
     * Filter which locations to delete
     */
    where?: locationsWhereInput
  }


  /**
   * locations findRaw
   */
  export type locationsFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * locations aggregateRaw
   */
  export type locationsAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * locations.users
   */
  export type locations$usersArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    where?: usersWhereInput
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * locations.organizations
   */
  export type locations$organizationsArgs = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude | null
    where?: organizationsWhereInput
    orderBy?: Enumerable<organizationsOrderByWithRelationInput>
    cursor?: organizationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OrganizationsScalarFieldEnum>
  }


  /**
   * locations.stores
   */
  export type locations$storesArgs = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: storesInclude | null
    where?: storesWhereInput
    orderBy?: Enumerable<storesOrderByWithRelationInput>
    cursor?: storesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<StoresScalarFieldEnum>
  }


  /**
   * locations.users_prefered
   */
  export type locations$users_preferedArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    where?: usersWhereInput
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * locations without action
   */
  export type locationsArgs = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: locationsInclude | null
  }



  /**
   * Model sessions
   */


  export type AggregateSessions = {
    _count: SessionsCountAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  export type SessionsMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
    jwt: string | null
    user_uuid: string | null
    user_id: string | null
  }

  export type SessionsMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
    jwt: string | null
    user_uuid: string | null
    user_id: string | null
  }

  export type SessionsCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    uuid: number
    jwt: number
    user_uuid: number
    user_id: number
    _all: number
  }


  export type SessionsMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    jwt?: true
    user_uuid?: true
    user_id?: true
  }

  export type SessionsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    jwt?: true
    user_uuid?: true
    user_id?: true
  }

  export type SessionsCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    jwt?: true
    user_uuid?: true
    user_id?: true
    _all?: true
  }

  export type SessionsAggregateArgs = {
    /**
     * Filter which sessions to aggregate.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: Enumerable<sessionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sessions
    **/
    _count?: true | SessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionsMaxAggregateInputType
  }

  export type GetSessionsAggregateType<T extends SessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessions[P]>
      : GetScalarType<T[P], AggregateSessions[P]>
  }




  export type SessionsGroupByArgs = {
    where?: sessionsWhereInput
    orderBy?: Enumerable<sessionsOrderByWithAggregationInput>
    by: SessionsScalarFieldEnum[]
    having?: sessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionsCountAggregateInputType | true
    _min?: SessionsMinAggregateInputType
    _max?: SessionsMaxAggregateInputType
  }


  export type SessionsGroupByOutputType = {
    id: string
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string
    jwt: string
    user_uuid: string
    user_id: string
    _count: SessionsCountAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  type GetSessionsGroupByPayload<T extends SessionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionsGroupByOutputType[P]>
            : GetScalarType<T[P], SessionsGroupByOutputType[P]>
        }
      >
    >


  export type sessionsSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uuid?: boolean
    jwt?: boolean
    user_uuid?: boolean
    user_id?: boolean
    user?: boolean | usersArgs
  }


  export type sessionsInclude = {
    user?: boolean | usersArgs
  }

  export type sessionsGetPayload<S extends boolean | null | undefined | sessionsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? sessions :
    S extends undefined ? never :
    S extends { include: any } & (sessionsArgs | sessionsFindManyArgs)
    ? sessions  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? usersGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (sessionsArgs | sessionsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? usersGetPayload<S['select'][P]> :  P extends keyof sessions ? sessions[P] : never
  } 
      : sessions


  type sessionsCountArgs = 
    Omit<sessionsFindManyArgs, 'select' | 'include'> & {
      select?: SessionsCountAggregateInputType | true
    }

  export interface sessionsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Sessions that matches the filter.
     * @param {sessionsFindUniqueArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends sessionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, sessionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'sessions'> extends True ? Prisma__sessionsClient<sessionsGetPayload<T>> : Prisma__sessionsClient<sessionsGetPayload<T> | null, null>

    /**
     * Find one Sessions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {sessionsFindUniqueOrThrowArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends sessionsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, sessionsFindUniqueOrThrowArgs>
    ): Prisma__sessionsClient<sessionsGetPayload<T>>

    /**
     * Find the first Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindFirstArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends sessionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, sessionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'sessions'> extends True ? Prisma__sessionsClient<sessionsGetPayload<T>> : Prisma__sessionsClient<sessionsGetPayload<T> | null, null>

    /**
     * Find the first Sessions that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindFirstOrThrowArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends sessionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, sessionsFindFirstOrThrowArgs>
    ): Prisma__sessionsClient<sessionsGetPayload<T>>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.sessions.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.sessions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionsWithIdOnly = await prisma.sessions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends sessionsFindManyArgs>(
      args?: SelectSubset<T, sessionsFindManyArgs>
    ): Prisma.PrismaPromise<Array<sessionsGetPayload<T>>>

    /**
     * Create a Sessions.
     * @param {sessionsCreateArgs} args - Arguments to create a Sessions.
     * @example
     * // Create one Sessions
     * const Sessions = await prisma.sessions.create({
     *   data: {
     *     // ... data to create a Sessions
     *   }
     * })
     * 
    **/
    create<T extends sessionsCreateArgs>(
      args: SelectSubset<T, sessionsCreateArgs>
    ): Prisma__sessionsClient<sessionsGetPayload<T>>

    /**
     * Create many Sessions.
     *     @param {sessionsCreateManyArgs} args - Arguments to create many Sessions.
     *     @example
     *     // Create many Sessions
     *     const sessions = await prisma.sessions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends sessionsCreateManyArgs>(
      args?: SelectSubset<T, sessionsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sessions.
     * @param {sessionsDeleteArgs} args - Arguments to delete one Sessions.
     * @example
     * // Delete one Sessions
     * const Sessions = await prisma.sessions.delete({
     *   where: {
     *     // ... filter to delete one Sessions
     *   }
     * })
     * 
    **/
    delete<T extends sessionsDeleteArgs>(
      args: SelectSubset<T, sessionsDeleteArgs>
    ): Prisma__sessionsClient<sessionsGetPayload<T>>

    /**
     * Update one Sessions.
     * @param {sessionsUpdateArgs} args - Arguments to update one Sessions.
     * @example
     * // Update one Sessions
     * const sessions = await prisma.sessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends sessionsUpdateArgs>(
      args: SelectSubset<T, sessionsUpdateArgs>
    ): Prisma__sessionsClient<sessionsGetPayload<T>>

    /**
     * Delete zero or more Sessions.
     * @param {sessionsDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.sessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends sessionsDeleteManyArgs>(
      args?: SelectSubset<T, sessionsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const sessions = await prisma.sessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends sessionsUpdateManyArgs>(
      args: SelectSubset<T, sessionsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sessions.
     * @param {sessionsUpsertArgs} args - Arguments to update or create a Sessions.
     * @example
     * // Update or create a Sessions
     * const sessions = await prisma.sessions.upsert({
     *   create: {
     *     // ... data to create a Sessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sessions we want to update
     *   }
     * })
    **/
    upsert<T extends sessionsUpsertArgs>(
      args: SelectSubset<T, sessionsUpsertArgs>
    ): Prisma__sessionsClient<sessionsGetPayload<T>>

    /**
     * Find zero or more Sessions that matches the filter.
     * @param {sessionsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const sessions = await prisma.sessions.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: sessionsFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Sessions.
     * @param {sessionsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const sessions = await prisma.sessions.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: sessionsAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.sessions.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends sessionsCountArgs>(
      args?: Subset<T, sessionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionsAggregateArgs>(args: Subset<T, SessionsAggregateArgs>): Prisma.PrismaPromise<GetSessionsAggregateType<T>>

    /**
     * Group by Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionsGroupByArgs['orderBy'] }
        : { orderBy?: SessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for sessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__sessionsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends usersArgs= {}>(args?: Subset<T, usersArgs>): Prisma__usersClient<usersGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * sessions base type for findUnique actions
   */
  export type sessionsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sessionsInclude | null
    /**
     * Filter, which sessions to fetch.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions findUnique
   */
  export interface sessionsFindUniqueArgs extends sessionsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * sessions findUniqueOrThrow
   */
  export type sessionsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sessionsInclude | null
    /**
     * Filter, which sessions to fetch.
     */
    where: sessionsWhereUniqueInput
  }


  /**
   * sessions base type for findFirst actions
   */
  export type sessionsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sessionsInclude | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: Enumerable<sessionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: Enumerable<SessionsScalarFieldEnum>
  }

  /**
   * sessions findFirst
   */
  export interface sessionsFindFirstArgs extends sessionsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * sessions findFirstOrThrow
   */
  export type sessionsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sessionsInclude | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: Enumerable<sessionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: Enumerable<SessionsScalarFieldEnum>
  }


  /**
   * sessions findMany
   */
  export type sessionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sessionsInclude | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: Enumerable<sessionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    distinct?: Enumerable<SessionsScalarFieldEnum>
  }


  /**
   * sessions create
   */
  export type sessionsCreateArgs = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sessionsInclude | null
    /**
     * The data needed to create a sessions.
     */
    data: XOR<sessionsCreateInput, sessionsUncheckedCreateInput>
  }


  /**
   * sessions createMany
   */
  export type sessionsCreateManyArgs = {
    /**
     * The data used to create many sessions.
     */
    data: Enumerable<sessionsCreateManyInput>
  }


  /**
   * sessions update
   */
  export type sessionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sessionsInclude | null
    /**
     * The data needed to update a sessions.
     */
    data: XOR<sessionsUpdateInput, sessionsUncheckedUpdateInput>
    /**
     * Choose, which sessions to update.
     */
    where: sessionsWhereUniqueInput
  }


  /**
   * sessions updateMany
   */
  export type sessionsUpdateManyArgs = {
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionsUpdateManyMutationInput, sessionsUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionsWhereInput
  }


  /**
   * sessions upsert
   */
  export type sessionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sessionsInclude | null
    /**
     * The filter to search for the sessions to update in case it exists.
     */
    where: sessionsWhereUniqueInput
    /**
     * In case the sessions found by the `where` argument doesn't exist, create a new sessions with this data.
     */
    create: XOR<sessionsCreateInput, sessionsUncheckedCreateInput>
    /**
     * In case the sessions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sessionsUpdateInput, sessionsUncheckedUpdateInput>
  }


  /**
   * sessions delete
   */
  export type sessionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sessionsInclude | null
    /**
     * Filter which sessions to delete.
     */
    where: sessionsWhereUniqueInput
  }


  /**
   * sessions deleteMany
   */
  export type sessionsDeleteManyArgs = {
    /**
     * Filter which sessions to delete
     */
    where?: sessionsWhereInput
  }


  /**
   * sessions findRaw
   */
  export type sessionsFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * sessions aggregateRaw
   */
  export type sessionsAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * sessions without action
   */
  export type sessionsArgs = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sessionsInclude | null
  }



  /**
   * Model images
   */


  export type AggregateImages = {
    _count: ImagesCountAggregateOutputType | null
    _min: ImagesMinAggregateOutputType | null
    _max: ImagesMaxAggregateOutputType | null
  }

  export type ImagesMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
    key: string | null
    url: string | null
    clipped_key: string | null
    clipped_url: string | null
  }

  export type ImagesMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
    key: string | null
    url: string | null
    clipped_key: string | null
    clipped_url: string | null
  }

  export type ImagesCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    uuid: number
    key: number
    url: number
    clipped_key: number
    clipped_url: number
    item_ids: number
    _all: number
  }


  export type ImagesMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    key?: true
    url?: true
    clipped_key?: true
    clipped_url?: true
  }

  export type ImagesMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    key?: true
    url?: true
    clipped_key?: true
    clipped_url?: true
  }

  export type ImagesCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    key?: true
    url?: true
    clipped_key?: true
    clipped_url?: true
    item_ids?: true
    _all?: true
  }

  export type ImagesAggregateArgs = {
    /**
     * Filter which images to aggregate.
     */
    where?: imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of images to fetch.
     */
    orderBy?: Enumerable<imagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned images
    **/
    _count?: true | ImagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImagesMaxAggregateInputType
  }

  export type GetImagesAggregateType<T extends ImagesAggregateArgs> = {
        [P in keyof T & keyof AggregateImages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImages[P]>
      : GetScalarType<T[P], AggregateImages[P]>
  }




  export type ImagesGroupByArgs = {
    where?: imagesWhereInput
    orderBy?: Enumerable<imagesOrderByWithAggregationInput>
    by: ImagesScalarFieldEnum[]
    having?: imagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImagesCountAggregateInputType | true
    _min?: ImagesMinAggregateInputType
    _max?: ImagesMaxAggregateInputType
  }


  export type ImagesGroupByOutputType = {
    id: string
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string
    key: string
    url: string | null
    clipped_key: string | null
    clipped_url: string | null
    item_ids: string[]
    _count: ImagesCountAggregateOutputType | null
    _min: ImagesMinAggregateOutputType | null
    _max: ImagesMaxAggregateOutputType | null
  }

  type GetImagesGroupByPayload<T extends ImagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ImagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImagesGroupByOutputType[P]>
            : GetScalarType<T[P], ImagesGroupByOutputType[P]>
        }
      >
    >


  export type imagesSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uuid?: boolean
    key?: boolean
    url?: boolean
    clipped_key?: boolean
    clipped_url?: boolean
    item_ids?: boolean
    platforms?: boolean | images$platformsArgs
    providers?: boolean | images$providersArgs
    organizations?: boolean | images$organizationsArgs
    stores?: boolean | images$storesArgs
    users?: boolean | images$usersArgs
    items?: boolean | images$itemsArgs
    _count?: boolean | ImagesCountOutputTypeArgs
  }


  export type imagesInclude = {
    platforms?: boolean | images$platformsArgs
    providers?: boolean | images$providersArgs
    organizations?: boolean | images$organizationsArgs
    stores?: boolean | images$storesArgs
    users?: boolean | images$usersArgs
    items?: boolean | images$itemsArgs
    _count?: boolean | ImagesCountOutputTypeArgs
  }

  export type imagesGetPayload<S extends boolean | null | undefined | imagesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? images :
    S extends undefined ? never :
    S extends { include: any } & (imagesArgs | imagesFindManyArgs)
    ? images  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'platforms' ? Array < platformsGetPayload<S['include'][P]>>  :
        P extends 'providers' ? Array < providersGetPayload<S['include'][P]>>  :
        P extends 'organizations' ? Array < organizationsGetPayload<S['include'][P]>>  :
        P extends 'stores' ? Array < storesGetPayload<S['include'][P]>>  :
        P extends 'users' ? Array < usersGetPayload<S['include'][P]>>  :
        P extends 'items' ? Array < itemsGetPayload<S['include'][P]>>  :
        P extends '_count' ? ImagesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (imagesArgs | imagesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'platforms' ? Array < platformsGetPayload<S['select'][P]>>  :
        P extends 'providers' ? Array < providersGetPayload<S['select'][P]>>  :
        P extends 'organizations' ? Array < organizationsGetPayload<S['select'][P]>>  :
        P extends 'stores' ? Array < storesGetPayload<S['select'][P]>>  :
        P extends 'users' ? Array < usersGetPayload<S['select'][P]>>  :
        P extends 'items' ? Array < itemsGetPayload<S['select'][P]>>  :
        P extends '_count' ? ImagesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof images ? images[P] : never
  } 
      : images


  type imagesCountArgs = 
    Omit<imagesFindManyArgs, 'select' | 'include'> & {
      select?: ImagesCountAggregateInputType | true
    }

  export interface imagesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Images that matches the filter.
     * @param {imagesFindUniqueArgs} args - Arguments to find a Images
     * @example
     * // Get one Images
     * const images = await prisma.images.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends imagesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, imagesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'images'> extends True ? Prisma__imagesClient<imagesGetPayload<T>> : Prisma__imagesClient<imagesGetPayload<T> | null, null>

    /**
     * Find one Images that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {imagesFindUniqueOrThrowArgs} args - Arguments to find a Images
     * @example
     * // Get one Images
     * const images = await prisma.images.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends imagesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, imagesFindUniqueOrThrowArgs>
    ): Prisma__imagesClient<imagesGetPayload<T>>

    /**
     * Find the first Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagesFindFirstArgs} args - Arguments to find a Images
     * @example
     * // Get one Images
     * const images = await prisma.images.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends imagesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, imagesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'images'> extends True ? Prisma__imagesClient<imagesGetPayload<T>> : Prisma__imagesClient<imagesGetPayload<T> | null, null>

    /**
     * Find the first Images that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagesFindFirstOrThrowArgs} args - Arguments to find a Images
     * @example
     * // Get one Images
     * const images = await prisma.images.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends imagesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, imagesFindFirstOrThrowArgs>
    ): Prisma__imagesClient<imagesGetPayload<T>>

    /**
     * Find zero or more Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Images
     * const images = await prisma.images.findMany()
     * 
     * // Get first 10 Images
     * const images = await prisma.images.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imagesWithIdOnly = await prisma.images.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends imagesFindManyArgs>(
      args?: SelectSubset<T, imagesFindManyArgs>
    ): Prisma.PrismaPromise<Array<imagesGetPayload<T>>>

    /**
     * Create a Images.
     * @param {imagesCreateArgs} args - Arguments to create a Images.
     * @example
     * // Create one Images
     * const Images = await prisma.images.create({
     *   data: {
     *     // ... data to create a Images
     *   }
     * })
     * 
    **/
    create<T extends imagesCreateArgs>(
      args: SelectSubset<T, imagesCreateArgs>
    ): Prisma__imagesClient<imagesGetPayload<T>>

    /**
     * Create many Images.
     *     @param {imagesCreateManyArgs} args - Arguments to create many Images.
     *     @example
     *     // Create many Images
     *     const images = await prisma.images.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends imagesCreateManyArgs>(
      args?: SelectSubset<T, imagesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Images.
     * @param {imagesDeleteArgs} args - Arguments to delete one Images.
     * @example
     * // Delete one Images
     * const Images = await prisma.images.delete({
     *   where: {
     *     // ... filter to delete one Images
     *   }
     * })
     * 
    **/
    delete<T extends imagesDeleteArgs>(
      args: SelectSubset<T, imagesDeleteArgs>
    ): Prisma__imagesClient<imagesGetPayload<T>>

    /**
     * Update one Images.
     * @param {imagesUpdateArgs} args - Arguments to update one Images.
     * @example
     * // Update one Images
     * const images = await prisma.images.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends imagesUpdateArgs>(
      args: SelectSubset<T, imagesUpdateArgs>
    ): Prisma__imagesClient<imagesGetPayload<T>>

    /**
     * Delete zero or more Images.
     * @param {imagesDeleteManyArgs} args - Arguments to filter Images to delete.
     * @example
     * // Delete a few Images
     * const { count } = await prisma.images.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends imagesDeleteManyArgs>(
      args?: SelectSubset<T, imagesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Images
     * const images = await prisma.images.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends imagesUpdateManyArgs>(
      args: SelectSubset<T, imagesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Images.
     * @param {imagesUpsertArgs} args - Arguments to update or create a Images.
     * @example
     * // Update or create a Images
     * const images = await prisma.images.upsert({
     *   create: {
     *     // ... data to create a Images
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Images we want to update
     *   }
     * })
    **/
    upsert<T extends imagesUpsertArgs>(
      args: SelectSubset<T, imagesUpsertArgs>
    ): Prisma__imagesClient<imagesGetPayload<T>>

    /**
     * Find zero or more Images that matches the filter.
     * @param {imagesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const images = await prisma.images.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: imagesFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Images.
     * @param {imagesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const images = await prisma.images.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: imagesAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imagesCountArgs} args - Arguments to filter Images to count.
     * @example
     * // Count the number of Images
     * const count = await prisma.images.count({
     *   where: {
     *     // ... the filter for the Images we want to count
     *   }
     * })
    **/
    count<T extends imagesCountArgs>(
      args?: Subset<T, imagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImagesAggregateArgs>(args: Subset<T, ImagesAggregateArgs>): Prisma.PrismaPromise<GetImagesAggregateType<T>>

    /**
     * Group by Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImagesGroupByArgs['orderBy'] }
        : { orderBy?: ImagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for images.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__imagesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    platforms<T extends images$platformsArgs= {}>(args?: Subset<T, images$platformsArgs>): Prisma.PrismaPromise<Array<platformsGetPayload<T>>| Null>;

    providers<T extends images$providersArgs= {}>(args?: Subset<T, images$providersArgs>): Prisma.PrismaPromise<Array<providersGetPayload<T>>| Null>;

    organizations<T extends images$organizationsArgs= {}>(args?: Subset<T, images$organizationsArgs>): Prisma.PrismaPromise<Array<organizationsGetPayload<T>>| Null>;

    stores<T extends images$storesArgs= {}>(args?: Subset<T, images$storesArgs>): Prisma.PrismaPromise<Array<storesGetPayload<T>>| Null>;

    users<T extends images$usersArgs= {}>(args?: Subset<T, images$usersArgs>): Prisma.PrismaPromise<Array<usersGetPayload<T>>| Null>;

    items<T extends images$itemsArgs= {}>(args?: Subset<T, images$itemsArgs>): Prisma.PrismaPromise<Array<itemsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * images base type for findUnique actions
   */
  export type imagesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagesInclude | null
    /**
     * Filter, which images to fetch.
     */
    where: imagesWhereUniqueInput
  }

  /**
   * images findUnique
   */
  export interface imagesFindUniqueArgs extends imagesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * images findUniqueOrThrow
   */
  export type imagesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagesInclude | null
    /**
     * Filter, which images to fetch.
     */
    where: imagesWhereUniqueInput
  }


  /**
   * images base type for findFirst actions
   */
  export type imagesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagesInclude | null
    /**
     * Filter, which images to fetch.
     */
    where?: imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of images to fetch.
     */
    orderBy?: Enumerable<imagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for images.
     */
    cursor?: imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of images.
     */
    distinct?: Enumerable<ImagesScalarFieldEnum>
  }

  /**
   * images findFirst
   */
  export interface imagesFindFirstArgs extends imagesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * images findFirstOrThrow
   */
  export type imagesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagesInclude | null
    /**
     * Filter, which images to fetch.
     */
    where?: imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of images to fetch.
     */
    orderBy?: Enumerable<imagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for images.
     */
    cursor?: imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of images.
     */
    distinct?: Enumerable<ImagesScalarFieldEnum>
  }


  /**
   * images findMany
   */
  export type imagesFindManyArgs = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagesInclude | null
    /**
     * Filter, which images to fetch.
     */
    where?: imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of images to fetch.
     */
    orderBy?: Enumerable<imagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing images.
     */
    cursor?: imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` images.
     */
    skip?: number
    distinct?: Enumerable<ImagesScalarFieldEnum>
  }


  /**
   * images create
   */
  export type imagesCreateArgs = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagesInclude | null
    /**
     * The data needed to create a images.
     */
    data: XOR<imagesCreateInput, imagesUncheckedCreateInput>
  }


  /**
   * images createMany
   */
  export type imagesCreateManyArgs = {
    /**
     * The data used to create many images.
     */
    data: Enumerable<imagesCreateManyInput>
  }


  /**
   * images update
   */
  export type imagesUpdateArgs = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagesInclude | null
    /**
     * The data needed to update a images.
     */
    data: XOR<imagesUpdateInput, imagesUncheckedUpdateInput>
    /**
     * Choose, which images to update.
     */
    where: imagesWhereUniqueInput
  }


  /**
   * images updateMany
   */
  export type imagesUpdateManyArgs = {
    /**
     * The data used to update images.
     */
    data: XOR<imagesUpdateManyMutationInput, imagesUncheckedUpdateManyInput>
    /**
     * Filter which images to update
     */
    where?: imagesWhereInput
  }


  /**
   * images upsert
   */
  export type imagesUpsertArgs = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagesInclude | null
    /**
     * The filter to search for the images to update in case it exists.
     */
    where: imagesWhereUniqueInput
    /**
     * In case the images found by the `where` argument doesn't exist, create a new images with this data.
     */
    create: XOR<imagesCreateInput, imagesUncheckedCreateInput>
    /**
     * In case the images was found with the provided `where` argument, update it with this data.
     */
    update: XOR<imagesUpdateInput, imagesUncheckedUpdateInput>
  }


  /**
   * images delete
   */
  export type imagesDeleteArgs = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagesInclude | null
    /**
     * Filter which images to delete.
     */
    where: imagesWhereUniqueInput
  }


  /**
   * images deleteMany
   */
  export type imagesDeleteManyArgs = {
    /**
     * Filter which images to delete
     */
    where?: imagesWhereInput
  }


  /**
   * images findRaw
   */
  export type imagesFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * images aggregateRaw
   */
  export type imagesAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * images.platforms
   */
  export type images$platformsArgs = {
    /**
     * Select specific fields to fetch from the platforms
     */
    select?: platformsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: platformsInclude | null
    where?: platformsWhereInput
    orderBy?: Enumerable<platformsOrderByWithRelationInput>
    cursor?: platformsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PlatformsScalarFieldEnum>
  }


  /**
   * images.providers
   */
  export type images$providersArgs = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: providersInclude | null
    where?: providersWhereInput
    orderBy?: Enumerable<providersOrderByWithRelationInput>
    cursor?: providersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProvidersScalarFieldEnum>
  }


  /**
   * images.organizations
   */
  export type images$organizationsArgs = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude | null
    where?: organizationsWhereInput
    orderBy?: Enumerable<organizationsOrderByWithRelationInput>
    cursor?: organizationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OrganizationsScalarFieldEnum>
  }


  /**
   * images.stores
   */
  export type images$storesArgs = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: storesInclude | null
    where?: storesWhereInput
    orderBy?: Enumerable<storesOrderByWithRelationInput>
    cursor?: storesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<StoresScalarFieldEnum>
  }


  /**
   * images.users
   */
  export type images$usersArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    where?: usersWhereInput
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * images.items
   */
  export type images$itemsArgs = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: itemsInclude | null
    where?: itemsWhereInput
    orderBy?: Enumerable<itemsOrderByWithRelationInput>
    cursor?: itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ItemsScalarFieldEnum>
  }


  /**
   * images without action
   */
  export type imagesArgs = {
    /**
     * Select specific fields to fetch from the images
     */
    select?: imagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imagesInclude | null
  }



  /**
   * Model ClauTest
   */


  export type AggregateClauTest = {
    _count: ClauTestCountAggregateOutputType | null
    _min: ClauTestMinAggregateOutputType | null
    _max: ClauTestMaxAggregateOutputType | null
  }

  export type ClauTestMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
  }

  export type ClauTestMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string | null
  }

  export type ClauTestCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    uuid: number
    _all: number
  }


  export type ClauTestMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
  }

  export type ClauTestMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
  }

  export type ClauTestCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    uuid?: true
    _all?: true
  }

  export type ClauTestAggregateArgs = {
    /**
     * Filter which ClauTest to aggregate.
     */
    where?: ClauTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClauTests to fetch.
     */
    orderBy?: Enumerable<ClauTestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClauTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClauTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClauTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClauTests
    **/
    _count?: true | ClauTestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClauTestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClauTestMaxAggregateInputType
  }

  export type GetClauTestAggregateType<T extends ClauTestAggregateArgs> = {
        [P in keyof T & keyof AggregateClauTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClauTest[P]>
      : GetScalarType<T[P], AggregateClauTest[P]>
  }




  export type ClauTestGroupByArgs = {
    where?: ClauTestWhereInput
    orderBy?: Enumerable<ClauTestOrderByWithAggregationInput>
    by: ClauTestScalarFieldEnum[]
    having?: ClauTestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClauTestCountAggregateInputType | true
    _min?: ClauTestMinAggregateInputType
    _max?: ClauTestMaxAggregateInputType
  }


  export type ClauTestGroupByOutputType = {
    id: string
    createdAt: Date | null
    updatedAt: Date | null
    uuid: string
    _count: ClauTestCountAggregateOutputType | null
    _min: ClauTestMinAggregateOutputType | null
    _max: ClauTestMaxAggregateOutputType | null
  }

  type GetClauTestGroupByPayload<T extends ClauTestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ClauTestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClauTestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClauTestGroupByOutputType[P]>
            : GetScalarType<T[P], ClauTestGroupByOutputType[P]>
        }
      >
    >


  export type ClauTestSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uuid?: boolean
  }


  export type ClauTestGetPayload<S extends boolean | null | undefined | ClauTestArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ClauTest :
    S extends undefined ? never :
    S extends { include: any } & (ClauTestArgs | ClauTestFindManyArgs)
    ? ClauTest 
    : S extends { select: any } & (ClauTestArgs | ClauTestFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ClauTest ? ClauTest[P] : never
  } 
      : ClauTest


  type ClauTestCountArgs = 
    Omit<ClauTestFindManyArgs, 'select' | 'include'> & {
      select?: ClauTestCountAggregateInputType | true
    }

  export interface ClauTestDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ClauTest that matches the filter.
     * @param {ClauTestFindUniqueArgs} args - Arguments to find a ClauTest
     * @example
     * // Get one ClauTest
     * const clauTest = await prisma.clauTest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClauTestFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ClauTestFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ClauTest'> extends True ? Prisma__ClauTestClient<ClauTestGetPayload<T>> : Prisma__ClauTestClient<ClauTestGetPayload<T> | null, null>

    /**
     * Find one ClauTest that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ClauTestFindUniqueOrThrowArgs} args - Arguments to find a ClauTest
     * @example
     * // Get one ClauTest
     * const clauTest = await prisma.clauTest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClauTestFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ClauTestFindUniqueOrThrowArgs>
    ): Prisma__ClauTestClient<ClauTestGetPayload<T>>

    /**
     * Find the first ClauTest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClauTestFindFirstArgs} args - Arguments to find a ClauTest
     * @example
     * // Get one ClauTest
     * const clauTest = await prisma.clauTest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClauTestFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ClauTestFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ClauTest'> extends True ? Prisma__ClauTestClient<ClauTestGetPayload<T>> : Prisma__ClauTestClient<ClauTestGetPayload<T> | null, null>

    /**
     * Find the first ClauTest that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClauTestFindFirstOrThrowArgs} args - Arguments to find a ClauTest
     * @example
     * // Get one ClauTest
     * const clauTest = await prisma.clauTest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClauTestFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ClauTestFindFirstOrThrowArgs>
    ): Prisma__ClauTestClient<ClauTestGetPayload<T>>

    /**
     * Find zero or more ClauTests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClauTestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClauTests
     * const clauTests = await prisma.clauTest.findMany()
     * 
     * // Get first 10 ClauTests
     * const clauTests = await prisma.clauTest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clauTestWithIdOnly = await prisma.clauTest.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClauTestFindManyArgs>(
      args?: SelectSubset<T, ClauTestFindManyArgs>
    ): Prisma.PrismaPromise<Array<ClauTestGetPayload<T>>>

    /**
     * Create a ClauTest.
     * @param {ClauTestCreateArgs} args - Arguments to create a ClauTest.
     * @example
     * // Create one ClauTest
     * const ClauTest = await prisma.clauTest.create({
     *   data: {
     *     // ... data to create a ClauTest
     *   }
     * })
     * 
    **/
    create<T extends ClauTestCreateArgs>(
      args: SelectSubset<T, ClauTestCreateArgs>
    ): Prisma__ClauTestClient<ClauTestGetPayload<T>>

    /**
     * Create many ClauTests.
     *     @param {ClauTestCreateManyArgs} args - Arguments to create many ClauTests.
     *     @example
     *     // Create many ClauTests
     *     const clauTest = await prisma.clauTest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClauTestCreateManyArgs>(
      args?: SelectSubset<T, ClauTestCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClauTest.
     * @param {ClauTestDeleteArgs} args - Arguments to delete one ClauTest.
     * @example
     * // Delete one ClauTest
     * const ClauTest = await prisma.clauTest.delete({
     *   where: {
     *     // ... filter to delete one ClauTest
     *   }
     * })
     * 
    **/
    delete<T extends ClauTestDeleteArgs>(
      args: SelectSubset<T, ClauTestDeleteArgs>
    ): Prisma__ClauTestClient<ClauTestGetPayload<T>>

    /**
     * Update one ClauTest.
     * @param {ClauTestUpdateArgs} args - Arguments to update one ClauTest.
     * @example
     * // Update one ClauTest
     * const clauTest = await prisma.clauTest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClauTestUpdateArgs>(
      args: SelectSubset<T, ClauTestUpdateArgs>
    ): Prisma__ClauTestClient<ClauTestGetPayload<T>>

    /**
     * Delete zero or more ClauTests.
     * @param {ClauTestDeleteManyArgs} args - Arguments to filter ClauTests to delete.
     * @example
     * // Delete a few ClauTests
     * const { count } = await prisma.clauTest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClauTestDeleteManyArgs>(
      args?: SelectSubset<T, ClauTestDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClauTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClauTestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClauTests
     * const clauTest = await prisma.clauTest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClauTestUpdateManyArgs>(
      args: SelectSubset<T, ClauTestUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClauTest.
     * @param {ClauTestUpsertArgs} args - Arguments to update or create a ClauTest.
     * @example
     * // Update or create a ClauTest
     * const clauTest = await prisma.clauTest.upsert({
     *   create: {
     *     // ... data to create a ClauTest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClauTest we want to update
     *   }
     * })
    **/
    upsert<T extends ClauTestUpsertArgs>(
      args: SelectSubset<T, ClauTestUpsertArgs>
    ): Prisma__ClauTestClient<ClauTestGetPayload<T>>

    /**
     * Find zero or more ClauTests that matches the filter.
     * @param {ClauTestFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const clauTest = await prisma.clauTest.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ClauTestFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ClauTest.
     * @param {ClauTestAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const clauTest = await prisma.clauTest.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ClauTestAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of ClauTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClauTestCountArgs} args - Arguments to filter ClauTests to count.
     * @example
     * // Count the number of ClauTests
     * const count = await prisma.clauTest.count({
     *   where: {
     *     // ... the filter for the ClauTests we want to count
     *   }
     * })
    **/
    count<T extends ClauTestCountArgs>(
      args?: Subset<T, ClauTestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClauTestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClauTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClauTestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClauTestAggregateArgs>(args: Subset<T, ClauTestAggregateArgs>): Prisma.PrismaPromise<GetClauTestAggregateType<T>>

    /**
     * Group by ClauTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClauTestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClauTestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClauTestGroupByArgs['orderBy'] }
        : { orderBy?: ClauTestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClauTestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClauTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ClauTest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ClauTestClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ClauTest base type for findUnique actions
   */
  export type ClauTestFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ClauTest
     */
    select?: ClauTestSelect | null
    /**
     * Filter, which ClauTest to fetch.
     */
    where: ClauTestWhereUniqueInput
  }

  /**
   * ClauTest findUnique
   */
  export interface ClauTestFindUniqueArgs extends ClauTestFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ClauTest findUniqueOrThrow
   */
  export type ClauTestFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ClauTest
     */
    select?: ClauTestSelect | null
    /**
     * Filter, which ClauTest to fetch.
     */
    where: ClauTestWhereUniqueInput
  }


  /**
   * ClauTest base type for findFirst actions
   */
  export type ClauTestFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ClauTest
     */
    select?: ClauTestSelect | null
    /**
     * Filter, which ClauTest to fetch.
     */
    where?: ClauTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClauTests to fetch.
     */
    orderBy?: Enumerable<ClauTestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClauTests.
     */
    cursor?: ClauTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClauTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClauTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClauTests.
     */
    distinct?: Enumerable<ClauTestScalarFieldEnum>
  }

  /**
   * ClauTest findFirst
   */
  export interface ClauTestFindFirstArgs extends ClauTestFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ClauTest findFirstOrThrow
   */
  export type ClauTestFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ClauTest
     */
    select?: ClauTestSelect | null
    /**
     * Filter, which ClauTest to fetch.
     */
    where?: ClauTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClauTests to fetch.
     */
    orderBy?: Enumerable<ClauTestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClauTests.
     */
    cursor?: ClauTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClauTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClauTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClauTests.
     */
    distinct?: Enumerable<ClauTestScalarFieldEnum>
  }


  /**
   * ClauTest findMany
   */
  export type ClauTestFindManyArgs = {
    /**
     * Select specific fields to fetch from the ClauTest
     */
    select?: ClauTestSelect | null
    /**
     * Filter, which ClauTests to fetch.
     */
    where?: ClauTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClauTests to fetch.
     */
    orderBy?: Enumerable<ClauTestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClauTests.
     */
    cursor?: ClauTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClauTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClauTests.
     */
    skip?: number
    distinct?: Enumerable<ClauTestScalarFieldEnum>
  }


  /**
   * ClauTest create
   */
  export type ClauTestCreateArgs = {
    /**
     * Select specific fields to fetch from the ClauTest
     */
    select?: ClauTestSelect | null
    /**
     * The data needed to create a ClauTest.
     */
    data: XOR<ClauTestCreateInput, ClauTestUncheckedCreateInput>
  }


  /**
   * ClauTest createMany
   */
  export type ClauTestCreateManyArgs = {
    /**
     * The data used to create many ClauTests.
     */
    data: Enumerable<ClauTestCreateManyInput>
  }


  /**
   * ClauTest update
   */
  export type ClauTestUpdateArgs = {
    /**
     * Select specific fields to fetch from the ClauTest
     */
    select?: ClauTestSelect | null
    /**
     * The data needed to update a ClauTest.
     */
    data: XOR<ClauTestUpdateInput, ClauTestUncheckedUpdateInput>
    /**
     * Choose, which ClauTest to update.
     */
    where: ClauTestWhereUniqueInput
  }


  /**
   * ClauTest updateMany
   */
  export type ClauTestUpdateManyArgs = {
    /**
     * The data used to update ClauTests.
     */
    data: XOR<ClauTestUpdateManyMutationInput, ClauTestUncheckedUpdateManyInput>
    /**
     * Filter which ClauTests to update
     */
    where?: ClauTestWhereInput
  }


  /**
   * ClauTest upsert
   */
  export type ClauTestUpsertArgs = {
    /**
     * Select specific fields to fetch from the ClauTest
     */
    select?: ClauTestSelect | null
    /**
     * The filter to search for the ClauTest to update in case it exists.
     */
    where: ClauTestWhereUniqueInput
    /**
     * In case the ClauTest found by the `where` argument doesn't exist, create a new ClauTest with this data.
     */
    create: XOR<ClauTestCreateInput, ClauTestUncheckedCreateInput>
    /**
     * In case the ClauTest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClauTestUpdateInput, ClauTestUncheckedUpdateInput>
  }


  /**
   * ClauTest delete
   */
  export type ClauTestDeleteArgs = {
    /**
     * Select specific fields to fetch from the ClauTest
     */
    select?: ClauTestSelect | null
    /**
     * Filter which ClauTest to delete.
     */
    where: ClauTestWhereUniqueInput
  }


  /**
   * ClauTest deleteMany
   */
  export type ClauTestDeleteManyArgs = {
    /**
     * Filter which ClauTests to delete
     */
    where?: ClauTestWhereInput
  }


  /**
   * ClauTest findRaw
   */
  export type ClauTestFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * ClauTest aggregateRaw
   */
  export type ClauTestAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * ClauTest without action
   */
  export type ClauTestArgs = {
    /**
     * Select specific fields to fetch from the ClauTest
     */
    select?: ClauTestSelect | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const ClauTestScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    uuid: 'uuid'
  };

  export type ClauTestScalarFieldEnum = (typeof ClauTestScalarFieldEnum)[keyof typeof ClauTestScalarFieldEnum]


  export const ImagesScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    uuid: 'uuid',
    key: 'key',
    url: 'url',
    clipped_key: 'clipped_key',
    clipped_url: 'clipped_url',
    item_ids: 'item_ids'
  };

  export type ImagesScalarFieldEnum = (typeof ImagesScalarFieldEnum)[keyof typeof ImagesScalarFieldEnum]


  export const InventoriesScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    uuid: 'uuid',
    name: 'name',
    description: 'description',
    item_iventory_ids: 'item_iventory_ids',
    store_ids: 'store_ids'
  };

  export type InventoriesScalarFieldEnum = (typeof InventoriesScalarFieldEnum)[keyof typeof InventoriesScalarFieldEnum]


  export const Item_inventoriesScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    uuid: 'uuid',
    item_id: 'item_id',
    type: 'type',
    value: 'value',
    iventory_ids: 'iventory_ids'
  };

  export type Item_inventoriesScalarFieldEnum = (typeof Item_inventoriesScalarFieldEnum)[keyof typeof Item_inventoriesScalarFieldEnum]


  export const Item_ordersScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    uuid: 'uuid',
    item_id: 'item_id',
    type: 'type',
    value: 'value',
    order_ids: 'order_ids'
  };

  export type Item_ordersScalarFieldEnum = (typeof Item_ordersScalarFieldEnum)[keyof typeof Item_ordersScalarFieldEnum]


  export const ItemsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    uuid: 'uuid',
    name: 'name',
    description: 'description',
    tags: 'tags',
    image_ids: 'image_ids'
  };

  export type ItemsScalarFieldEnum = (typeof ItemsScalarFieldEnum)[keyof typeof ItemsScalarFieldEnum]


  export const LocationsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    uuid: 'uuid',
    name: 'name',
    latitude: 'latitude',
    longitude: 'longitude',
    user_ids: 'user_ids',
    organizations_ids: 'organizations_ids',
    store_ids: 'store_ids'
  };

  export type LocationsScalarFieldEnum = (typeof LocationsScalarFieldEnum)[keyof typeof LocationsScalarFieldEnum]


  export const OdersScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    uuid: 'uuid',
    total: 'total',
    item_order_ids: 'item_order_ids'
  };

  export type OdersScalarFieldEnum = (typeof OdersScalarFieldEnum)[keyof typeof OdersScalarFieldEnum]


  export const OrganizationsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    uuid: 'uuid',
    username: 'username',
    name: 'name',
    image_id: 'image_id',
    platform_ids: 'platform_ids',
    user_ids: 'user_ids',
    location_ids: 'location_ids'
  };

  export type OrganizationsScalarFieldEnum = (typeof OrganizationsScalarFieldEnum)[keyof typeof OrganizationsScalarFieldEnum]


  export const PaymentAccountScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    uuid: 'uuid'
  };

  export type PaymentAccountScalarFieldEnum = (typeof PaymentAccountScalarFieldEnum)[keyof typeof PaymentAccountScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    uuid: 'uuid',
    title: 'title',
    description: 'description',
    payment_type_id: 'payment_type_id',
    user_creator_id: 'user_creator_id',
    user_confirm_id: 'user_confirm_id',
    receiver_account_id: 'receiver_account_id',
    sender_account_id: 'sender_account_id'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const PaymentTypeScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    uuid: 'uuid',
    title: 'title',
    description: 'description'
  };

  export type PaymentTypeScalarFieldEnum = (typeof PaymentTypeScalarFieldEnum)[keyof typeof PaymentTypeScalarFieldEnum]


  export const PlatformsScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    key: 'key',
    username: 'username',
    name: 'name',
    image_id: 'image_id',
    provider_ids: 'provider_ids',
    provider_key_ids: 'provider_key_ids',
    user_ids: 'user_ids',
    organization_ids: 'organization_ids'
  };

  export type PlatformsScalarFieldEnum = (typeof PlatformsScalarFieldEnum)[keyof typeof PlatformsScalarFieldEnum]


  export const Provider_keysScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    uuid: 'uuid',
    public_key: 'public_key',
    private_key: 'private_key',
    secret: 'secret',
    description: 'description',
    provider_id: 'provider_id',
    platform_ids: 'platform_ids'
  };

  export type Provider_keysScalarFieldEnum = (typeof Provider_keysScalarFieldEnum)[keyof typeof Provider_keysScalarFieldEnum]


  export const ProvidersScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    uuid: 'uuid',
    key: 'key',
    name: 'name',
    image_id: 'image_id',
    platform_ids: 'platform_ids',
    provider_key_ids: 'provider_key_ids'
  };

  export type ProvidersScalarFieldEnum = (typeof ProvidersScalarFieldEnum)[keyof typeof ProvidersScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const SessionsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    uuid: 'uuid',
    jwt: 'jwt',
    user_uuid: 'user_uuid',
    user_id: 'user_id'
  };

  export type SessionsScalarFieldEnum = (typeof SessionsScalarFieldEnum)[keyof typeof SessionsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const StoresScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    uuid: 'uuid',
    username: 'username',
    name: 'name',
    image_id: 'image_id',
    user_ids: 'user_ids',
    location_ids: 'location_ids',
    inventory_ids: 'inventory_ids'
  };

  export type StoresScalarFieldEnum = (typeof StoresScalarFieldEnum)[keyof typeof StoresScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    uuid: 'uuid',
    username: 'username',
    email: 'email',
    phone: 'phone',
    name: 'name',
    birthDate: 'birthDate',
    gender: 'gender',
    image_id: 'image_id',
    prefered_location_id: 'prefered_location_id',
    location_ids: 'location_ids',
    platform_ids: 'platform_ids',
    organization_ids: 'organization_ids',
    store_ids: 'store_ids'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type platformsWhereInput = {
    AND?: Enumerable<platformsWhereInput>
    OR?: Enumerable<platformsWhereInput>
    NOT?: Enumerable<platformsWhereInput>
    id?: StringFilter | string
    uuid?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    key?: StringFilter | string
    username?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    image_id?: StringNullableFilter | string | null
    provider_ids?: StringNullableListFilter
    provider_key_ids?: StringNullableListFilter
    user_ids?: StringNullableListFilter
    organization_ids?: StringNullableListFilter
    image?: XOR<ImagesRelationFilter, imagesWhereInput> | null
    providers?: ProvidersListRelationFilter
    provider_keys?: Provider_keysListRelationFilter
    users?: UsersListRelationFilter
    organizations?: OrganizationsListRelationFilter
  }

  export type platformsOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    key?: SortOrder
    username?: SortOrder
    name?: SortOrder
    image_id?: SortOrder
    provider_ids?: SortOrder
    provider_key_ids?: SortOrder
    user_ids?: SortOrder
    organization_ids?: SortOrder
    image?: imagesOrderByWithRelationInput
    providers?: providersOrderByRelationAggregateInput
    provider_keys?: provider_keysOrderByRelationAggregateInput
    users?: usersOrderByRelationAggregateInput
    organizations?: organizationsOrderByRelationAggregateInput
  }

  export type platformsWhereUniqueInput = {
    id?: string
    uuid?: string
    key?: string
    username?: string
  }

  export type platformsOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    key?: SortOrder
    username?: SortOrder
    name?: SortOrder
    image_id?: SortOrder
    provider_ids?: SortOrder
    provider_key_ids?: SortOrder
    user_ids?: SortOrder
    organization_ids?: SortOrder
    _count?: platformsCountOrderByAggregateInput
    _max?: platformsMaxOrderByAggregateInput
    _min?: platformsMinOrderByAggregateInput
  }

  export type platformsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<platformsScalarWhereWithAggregatesInput>
    OR?: Enumerable<platformsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<platformsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    uuid?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    key?: StringWithAggregatesFilter | string
    username?: StringNullableWithAggregatesFilter | string | null
    name?: StringNullableWithAggregatesFilter | string | null
    image_id?: StringNullableWithAggregatesFilter | string | null
    provider_ids?: StringNullableListFilter
    provider_key_ids?: StringNullableListFilter
    user_ids?: StringNullableListFilter
    organization_ids?: StringNullableListFilter
  }

  export type providersWhereInput = {
    AND?: Enumerable<providersWhereInput>
    OR?: Enumerable<providersWhereInput>
    NOT?: Enumerable<providersWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
    key?: StringFilter | string
    name?: StringNullableFilter | string | null
    image_id?: StringNullableFilter | string | null
    platform_ids?: StringNullableListFilter
    provider_key_ids?: StringNullableListFilter
    image?: XOR<ImagesRelationFilter, imagesWhereInput> | null
    platforms?: PlatformsListRelationFilter
    provider_keys?: Provider_keysListRelationFilter
  }

  export type providersOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    key?: SortOrder
    name?: SortOrder
    image_id?: SortOrder
    platform_ids?: SortOrder
    provider_key_ids?: SortOrder
    image?: imagesOrderByWithRelationInput
    platforms?: platformsOrderByRelationAggregateInput
    provider_keys?: provider_keysOrderByRelationAggregateInput
  }

  export type providersWhereUniqueInput = {
    id?: string
    uuid?: string
    key?: string
  }

  export type providersOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    key?: SortOrder
    name?: SortOrder
    image_id?: SortOrder
    platform_ids?: SortOrder
    provider_key_ids?: SortOrder
    _count?: providersCountOrderByAggregateInput
    _max?: providersMaxOrderByAggregateInput
    _min?: providersMinOrderByAggregateInput
  }

  export type providersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<providersScalarWhereWithAggregatesInput>
    OR?: Enumerable<providersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<providersScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    uuid?: StringWithAggregatesFilter | string
    key?: StringWithAggregatesFilter | string
    name?: StringNullableWithAggregatesFilter | string | null
    image_id?: StringNullableWithAggregatesFilter | string | null
    platform_ids?: StringNullableListFilter
    provider_key_ids?: StringNullableListFilter
  }

  export type provider_keysWhereInput = {
    AND?: Enumerable<provider_keysWhereInput>
    OR?: Enumerable<provider_keysWhereInput>
    NOT?: Enumerable<provider_keysWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
    public_key?: StringFilter | string
    private_key?: StringFilter | string
    secret?: BoolFilter | boolean
    description?: StringNullableFilter | string | null
    provider_id?: StringFilter | string
    platform_ids?: StringNullableListFilter
    provider?: XOR<ProvidersRelationFilter, providersWhereInput>
    platforms?: PlatformsListRelationFilter
  }

  export type provider_keysOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    public_key?: SortOrder
    private_key?: SortOrder
    secret?: SortOrder
    description?: SortOrder
    provider_id?: SortOrder
    platform_ids?: SortOrder
    provider?: providersOrderByWithRelationInput
    platforms?: platformsOrderByRelationAggregateInput
  }

  export type provider_keysWhereUniqueInput = {
    id?: string
    uuid?: string
  }

  export type provider_keysOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    public_key?: SortOrder
    private_key?: SortOrder
    secret?: SortOrder
    description?: SortOrder
    provider_id?: SortOrder
    platform_ids?: SortOrder
    _count?: provider_keysCountOrderByAggregateInput
    _max?: provider_keysMaxOrderByAggregateInput
    _min?: provider_keysMinOrderByAggregateInput
  }

  export type provider_keysScalarWhereWithAggregatesInput = {
    AND?: Enumerable<provider_keysScalarWhereWithAggregatesInput>
    OR?: Enumerable<provider_keysScalarWhereWithAggregatesInput>
    NOT?: Enumerable<provider_keysScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    uuid?: StringWithAggregatesFilter | string
    public_key?: StringWithAggregatesFilter | string
    private_key?: StringWithAggregatesFilter | string
    secret?: BoolWithAggregatesFilter | boolean
    description?: StringNullableWithAggregatesFilter | string | null
    provider_id?: StringWithAggregatesFilter | string
    platform_ids?: StringNullableListFilter
  }

  export type usersWhereInput = {
    AND?: Enumerable<usersWhereInput>
    OR?: Enumerable<usersWhereInput>
    NOT?: Enumerable<usersWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
    username?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    birthDate?: DateTimeNullableFilter | Date | string | null
    gender?: EnumGenderTypeNullableFilter | GenderType | null
    image_id?: StringNullableFilter | string | null
    prefered_location_id?: StringNullableFilter | string | null
    location_ids?: StringNullableListFilter
    platform_ids?: StringNullableListFilter
    organization_ids?: StringNullableListFilter
    store_ids?: StringNullableListFilter
    image?: XOR<ImagesRelationFilter, imagesWhereInput> | null
    prefered_location?: XOR<LocationsRelationFilter, locationsWhereInput> | null
    locations?: LocationsListRelationFilter
    platforms?: PlatformsListRelationFilter
    organizations?: OrganizationsListRelationFilter
    stores?: StoresListRelationFilter
    payments_created?: PaymentListRelationFilter
    payments_confirmed?: PaymentListRelationFilter
    session?: SessionsListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    username?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    image_id?: SortOrder
    prefered_location_id?: SortOrder
    location_ids?: SortOrder
    platform_ids?: SortOrder
    organization_ids?: SortOrder
    store_ids?: SortOrder
    image?: imagesOrderByWithRelationInput
    prefered_location?: locationsOrderByWithRelationInput
    locations?: locationsOrderByRelationAggregateInput
    platforms?: platformsOrderByRelationAggregateInput
    organizations?: organizationsOrderByRelationAggregateInput
    stores?: storesOrderByRelationAggregateInput
    payments_created?: paymentOrderByRelationAggregateInput
    payments_confirmed?: paymentOrderByRelationAggregateInput
    session?: sessionsOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = {
    id?: string
    uuid?: string
    username?: string
    email?: string
    phone?: string
  }

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    username?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    image_id?: SortOrder
    prefered_location_id?: SortOrder
    location_ids?: SortOrder
    platform_ids?: SortOrder
    organization_ids?: SortOrder
    store_ids?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<usersScalarWhereWithAggregatesInput>
    OR?: Enumerable<usersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<usersScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    uuid?: StringWithAggregatesFilter | string
    username?: StringNullableWithAggregatesFilter | string | null
    email?: StringNullableWithAggregatesFilter | string | null
    phone?: StringNullableWithAggregatesFilter | string | null
    name?: StringNullableWithAggregatesFilter | string | null
    birthDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    gender?: EnumGenderTypeNullableWithAggregatesFilter | GenderType | null
    image_id?: StringNullableWithAggregatesFilter | string | null
    prefered_location_id?: StringNullableWithAggregatesFilter | string | null
    location_ids?: StringNullableListFilter
    platform_ids?: StringNullableListFilter
    organization_ids?: StringNullableListFilter
    store_ids?: StringNullableListFilter
  }

  export type organizationsWhereInput = {
    AND?: Enumerable<organizationsWhereInput>
    OR?: Enumerable<organizationsWhereInput>
    NOT?: Enumerable<organizationsWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
    username?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    image_id?: StringNullableFilter | string | null
    platform_ids?: StringNullableListFilter
    user_ids?: StringNullableListFilter
    location_ids?: StringNullableListFilter
    image?: XOR<ImagesRelationFilter, imagesWhereInput> | null
    platforms?: PlatformsListRelationFilter
    users?: UsersListRelationFilter
    locations?: LocationsListRelationFilter
  }

  export type organizationsOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    username?: SortOrder
    name?: SortOrder
    image_id?: SortOrder
    platform_ids?: SortOrder
    user_ids?: SortOrder
    location_ids?: SortOrder
    image?: imagesOrderByWithRelationInput
    platforms?: platformsOrderByRelationAggregateInput
    users?: usersOrderByRelationAggregateInput
    locations?: locationsOrderByRelationAggregateInput
  }

  export type organizationsWhereUniqueInput = {
    id?: string
    uuid?: string
    username?: string
  }

  export type organizationsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    username?: SortOrder
    name?: SortOrder
    image_id?: SortOrder
    platform_ids?: SortOrder
    user_ids?: SortOrder
    location_ids?: SortOrder
    _count?: organizationsCountOrderByAggregateInput
    _max?: organizationsMaxOrderByAggregateInput
    _min?: organizationsMinOrderByAggregateInput
  }

  export type organizationsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<organizationsScalarWhereWithAggregatesInput>
    OR?: Enumerable<organizationsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<organizationsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    uuid?: StringWithAggregatesFilter | string
    username?: StringNullableWithAggregatesFilter | string | null
    name?: StringNullableWithAggregatesFilter | string | null
    image_id?: StringNullableWithAggregatesFilter | string | null
    platform_ids?: StringNullableListFilter
    user_ids?: StringNullableListFilter
    location_ids?: StringNullableListFilter
  }

  export type storesWhereInput = {
    AND?: Enumerable<storesWhereInput>
    OR?: Enumerable<storesWhereInput>
    NOT?: Enumerable<storesWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
    username?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    image_id?: StringNullableFilter | string | null
    user_ids?: StringNullableListFilter
    location_ids?: StringNullableListFilter
    inventory_ids?: StringNullableListFilter
    image?: XOR<ImagesRelationFilter, imagesWhereInput> | null
    users?: UsersListRelationFilter
    locations?: LocationsListRelationFilter
    inventories?: InventoriesListRelationFilter
  }

  export type storesOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    username?: SortOrder
    name?: SortOrder
    image_id?: SortOrder
    user_ids?: SortOrder
    location_ids?: SortOrder
    inventory_ids?: SortOrder
    image?: imagesOrderByWithRelationInput
    users?: usersOrderByRelationAggregateInput
    locations?: locationsOrderByRelationAggregateInput
    inventories?: inventoriesOrderByRelationAggregateInput
  }

  export type storesWhereUniqueInput = {
    id?: string
    uuid?: string
    username?: string
  }

  export type storesOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    username?: SortOrder
    name?: SortOrder
    image_id?: SortOrder
    user_ids?: SortOrder
    location_ids?: SortOrder
    inventory_ids?: SortOrder
    _count?: storesCountOrderByAggregateInput
    _max?: storesMaxOrderByAggregateInput
    _min?: storesMinOrderByAggregateInput
  }

  export type storesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<storesScalarWhereWithAggregatesInput>
    OR?: Enumerable<storesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<storesScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    uuid?: StringWithAggregatesFilter | string
    username?: StringNullableWithAggregatesFilter | string | null
    name?: StringNullableWithAggregatesFilter | string | null
    image_id?: StringNullableWithAggregatesFilter | string | null
    user_ids?: StringNullableListFilter
    location_ids?: StringNullableListFilter
    inventory_ids?: StringNullableListFilter
  }

  export type inventoriesWhereInput = {
    AND?: Enumerable<inventoriesWhereInput>
    OR?: Enumerable<inventoriesWhereInput>
    NOT?: Enumerable<inventoriesWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
    name?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    item_iventory_ids?: StringNullableListFilter
    store_ids?: StringNullableListFilter
    item_inventories?: Item_inventoriesListRelationFilter
    stores?: StoresListRelationFilter
  }

  export type inventoriesOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    item_iventory_ids?: SortOrder
    store_ids?: SortOrder
    item_inventories?: item_inventoriesOrderByRelationAggregateInput
    stores?: storesOrderByRelationAggregateInput
  }

  export type inventoriesWhereUniqueInput = {
    id?: string
    uuid?: string
  }

  export type inventoriesOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    item_iventory_ids?: SortOrder
    store_ids?: SortOrder
    _count?: inventoriesCountOrderByAggregateInput
    _max?: inventoriesMaxOrderByAggregateInput
    _min?: inventoriesMinOrderByAggregateInput
  }

  export type inventoriesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<inventoriesScalarWhereWithAggregatesInput>
    OR?: Enumerable<inventoriesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<inventoriesScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    uuid?: StringWithAggregatesFilter | string
    name?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    item_iventory_ids?: StringNullableListFilter
    store_ids?: StringNullableListFilter
  }

  export type item_inventoriesWhereInput = {
    AND?: Enumerable<item_inventoriesWhereInput>
    OR?: Enumerable<item_inventoriesWhereInput>
    NOT?: Enumerable<item_inventoriesWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
    item_id?: StringFilter | string
    type?: EnumItemQualitativeTypeFilter | ItemQualitativeType
    value?: FloatFilter | number
    iventory_ids?: StringNullableListFilter
    item?: XOR<ItemsRelationFilter, itemsWhereInput>
    inventories?: InventoriesListRelationFilter
  }

  export type item_inventoriesOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    item_id?: SortOrder
    type?: SortOrder
    value?: SortOrder
    iventory_ids?: SortOrder
    item?: itemsOrderByWithRelationInput
    inventories?: inventoriesOrderByRelationAggregateInput
  }

  export type item_inventoriesWhereUniqueInput = {
    id?: string
    uuid?: string
  }

  export type item_inventoriesOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    item_id?: SortOrder
    type?: SortOrder
    value?: SortOrder
    iventory_ids?: SortOrder
    _count?: item_inventoriesCountOrderByAggregateInput
    _avg?: item_inventoriesAvgOrderByAggregateInput
    _max?: item_inventoriesMaxOrderByAggregateInput
    _min?: item_inventoriesMinOrderByAggregateInput
    _sum?: item_inventoriesSumOrderByAggregateInput
  }

  export type item_inventoriesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<item_inventoriesScalarWhereWithAggregatesInput>
    OR?: Enumerable<item_inventoriesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<item_inventoriesScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    uuid?: StringWithAggregatesFilter | string
    item_id?: StringWithAggregatesFilter | string
    type?: EnumItemQualitativeTypeWithAggregatesFilter | ItemQualitativeType
    value?: FloatWithAggregatesFilter | number
    iventory_ids?: StringNullableListFilter
  }

  export type odersWhereInput = {
    AND?: Enumerable<odersWhereInput>
    OR?: Enumerable<odersWhereInput>
    NOT?: Enumerable<odersWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
    total?: FloatFilter | number
    item_order_ids?: StringNullableListFilter
    item_orders?: Item_ordersListRelationFilter
  }

  export type odersOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    total?: SortOrder
    item_order_ids?: SortOrder
    item_orders?: item_ordersOrderByRelationAggregateInput
  }

  export type odersWhereUniqueInput = {
    id?: string
    uuid?: string
  }

  export type odersOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    total?: SortOrder
    item_order_ids?: SortOrder
    _count?: odersCountOrderByAggregateInput
    _avg?: odersAvgOrderByAggregateInput
    _max?: odersMaxOrderByAggregateInput
    _min?: odersMinOrderByAggregateInput
    _sum?: odersSumOrderByAggregateInput
  }

  export type odersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<odersScalarWhereWithAggregatesInput>
    OR?: Enumerable<odersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<odersScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    uuid?: StringWithAggregatesFilter | string
    total?: FloatWithAggregatesFilter | number
    item_order_ids?: StringNullableListFilter
  }

  export type item_ordersWhereInput = {
    AND?: Enumerable<item_ordersWhereInput>
    OR?: Enumerable<item_ordersWhereInput>
    NOT?: Enumerable<item_ordersWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
    item_id?: StringFilter | string
    type?: EnumItemQualitativeTypeFilter | ItemQualitativeType
    value?: FloatFilter | number
    order_ids?: StringNullableListFilter
    item?: XOR<ItemsRelationFilter, itemsWhereInput>
    orders?: OdersListRelationFilter
  }

  export type item_ordersOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    item_id?: SortOrder
    type?: SortOrder
    value?: SortOrder
    order_ids?: SortOrder
    item?: itemsOrderByWithRelationInput
    orders?: odersOrderByRelationAggregateInput
  }

  export type item_ordersWhereUniqueInput = {
    id?: string
    uuid?: string
  }

  export type item_ordersOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    item_id?: SortOrder
    type?: SortOrder
    value?: SortOrder
    order_ids?: SortOrder
    _count?: item_ordersCountOrderByAggregateInput
    _avg?: item_ordersAvgOrderByAggregateInput
    _max?: item_ordersMaxOrderByAggregateInput
    _min?: item_ordersMinOrderByAggregateInput
    _sum?: item_ordersSumOrderByAggregateInput
  }

  export type item_ordersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<item_ordersScalarWhereWithAggregatesInput>
    OR?: Enumerable<item_ordersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<item_ordersScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    uuid?: StringWithAggregatesFilter | string
    item_id?: StringWithAggregatesFilter | string
    type?: EnumItemQualitativeTypeWithAggregatesFilter | ItemQualitativeType
    value?: FloatWithAggregatesFilter | number
    order_ids?: StringNullableListFilter
  }

  export type PaymentTypeWhereInput = {
    AND?: Enumerable<PaymentTypeWhereInput>
    OR?: Enumerable<PaymentTypeWhereInput>
    NOT?: Enumerable<PaymentTypeWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
    title?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    payments?: PaymentListRelationFilter
  }

  export type PaymentTypeOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    title?: SortOrder
    description?: SortOrder
    payments?: paymentOrderByRelationAggregateInput
  }

  export type PaymentTypeWhereUniqueInput = {
    id?: string
    uuid?: string
  }

  export type PaymentTypeOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    title?: SortOrder
    description?: SortOrder
    _count?: PaymentTypeCountOrderByAggregateInput
    _max?: PaymentTypeMaxOrderByAggregateInput
    _min?: PaymentTypeMinOrderByAggregateInput
  }

  export type PaymentTypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PaymentTypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<PaymentTypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PaymentTypeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    uuid?: StringWithAggregatesFilter | string
    title?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type paymentWhereInput = {
    AND?: Enumerable<paymentWhereInput>
    OR?: Enumerable<paymentWhereInput>
    NOT?: Enumerable<paymentWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
    title?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    payment_type_id?: StringFilter | string
    user_creator_id?: StringFilter | string
    user_confirm_id?: StringFilter | string
    receiver_account_id?: StringFilter | string
    sender_account_id?: StringFilter | string
    amount?: XOR<CurrencyCompositeFilter, CurrencyObjectEqualityInput>
    payment_type?: XOR<PaymentTypeRelationFilter, PaymentTypeWhereInput>
    user_creator?: XOR<UsersRelationFilter, usersWhereInput>
    user_confirm?: XOR<UsersRelationFilter, usersWhereInput>
    recever_account?: XOR<PaymentAccountRelationFilter, PaymentAccountWhereInput>
    sender_account?: XOR<PaymentAccountRelationFilter, PaymentAccountWhereInput>
  }

  export type paymentOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    title?: SortOrder
    description?: SortOrder
    payment_type_id?: SortOrder
    user_creator_id?: SortOrder
    user_confirm_id?: SortOrder
    receiver_account_id?: SortOrder
    sender_account_id?: SortOrder
    amount?: CurrencyOrderByInput
    payment_type?: PaymentTypeOrderByWithRelationInput
    user_creator?: usersOrderByWithRelationInput
    user_confirm?: usersOrderByWithRelationInput
    recever_account?: PaymentAccountOrderByWithRelationInput
    sender_account?: PaymentAccountOrderByWithRelationInput
  }

  export type paymentWhereUniqueInput = {
    id?: string
    uuid?: string
  }

  export type paymentOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    title?: SortOrder
    description?: SortOrder
    payment_type_id?: SortOrder
    user_creator_id?: SortOrder
    user_confirm_id?: SortOrder
    receiver_account_id?: SortOrder
    sender_account_id?: SortOrder
    _count?: paymentCountOrderByAggregateInput
    _max?: paymentMaxOrderByAggregateInput
    _min?: paymentMinOrderByAggregateInput
  }

  export type paymentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<paymentScalarWhereWithAggregatesInput>
    OR?: Enumerable<paymentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<paymentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    uuid?: StringWithAggregatesFilter | string
    title?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    payment_type_id?: StringWithAggregatesFilter | string
    user_creator_id?: StringWithAggregatesFilter | string
    user_confirm_id?: StringWithAggregatesFilter | string
    receiver_account_id?: StringWithAggregatesFilter | string
    sender_account_id?: StringWithAggregatesFilter | string
  }

  export type PaymentAccountWhereInput = {
    AND?: Enumerable<PaymentAccountWhereInput>
    OR?: Enumerable<PaymentAccountWhereInput>
    NOT?: Enumerable<PaymentAccountWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
    amount?: XOR<CurrencyCompositeFilter, CurrencyObjectEqualityInput>
    payments_received?: PaymentListRelationFilter
    payments_sended?: PaymentListRelationFilter
  }

  export type PaymentAccountOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    amount?: CurrencyOrderByInput
    payments_received?: paymentOrderByRelationAggregateInput
    payments_sended?: paymentOrderByRelationAggregateInput
  }

  export type PaymentAccountWhereUniqueInput = {
    id?: string
    uuid?: string
  }

  export type PaymentAccountOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    _count?: PaymentAccountCountOrderByAggregateInput
    _max?: PaymentAccountMaxOrderByAggregateInput
    _min?: PaymentAccountMinOrderByAggregateInput
  }

  export type PaymentAccountScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PaymentAccountScalarWhereWithAggregatesInput>
    OR?: Enumerable<PaymentAccountScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PaymentAccountScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    uuid?: StringWithAggregatesFilter | string
  }

  export type itemsWhereInput = {
    AND?: Enumerable<itemsWhereInput>
    OR?: Enumerable<itemsWhereInput>
    NOT?: Enumerable<itemsWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
    name?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    tags?: StringNullableListFilter
    image_ids?: StringNullableListFilter
    prices?: XOR<CurrencyCompositeListFilter, Enumerable<CurrencyObjectEqualityInput>>
    images?: ImagesListRelationFilter
    item_inventories?: Item_inventoriesListRelationFilter
    item_orders?: Item_ordersListRelationFilter
  }

  export type itemsOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    image_ids?: SortOrder
    prices?: CurrencyOrderByCompositeAggregateInput
    images?: imagesOrderByRelationAggregateInput
    item_inventories?: item_inventoriesOrderByRelationAggregateInput
    item_orders?: item_ordersOrderByRelationAggregateInput
  }

  export type itemsWhereUniqueInput = {
    id?: string
    uuid?: string
  }

  export type itemsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    image_ids?: SortOrder
    _count?: itemsCountOrderByAggregateInput
    _max?: itemsMaxOrderByAggregateInput
    _min?: itemsMinOrderByAggregateInput
  }

  export type itemsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<itemsScalarWhereWithAggregatesInput>
    OR?: Enumerable<itemsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<itemsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    uuid?: StringWithAggregatesFilter | string
    name?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    tags?: StringNullableListFilter
    image_ids?: StringNullableListFilter
  }

  export type locationsWhereInput = {
    AND?: Enumerable<locationsWhereInput>
    OR?: Enumerable<locationsWhereInput>
    NOT?: Enumerable<locationsWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
    name?: StringNullableFilter | string | null
    latitude?: FloatNullableFilter | number | null
    longitude?: FloatNullableFilter | number | null
    user_ids?: StringNullableListFilter
    organizations_ids?: StringNullableListFilter
    store_ids?: StringNullableListFilter
    users?: UsersListRelationFilter
    organizations?: OrganizationsListRelationFilter
    stores?: StoresListRelationFilter
    users_prefered?: UsersListRelationFilter
  }

  export type locationsOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    user_ids?: SortOrder
    organizations_ids?: SortOrder
    store_ids?: SortOrder
    users?: usersOrderByRelationAggregateInput
    organizations?: organizationsOrderByRelationAggregateInput
    stores?: storesOrderByRelationAggregateInput
    users_prefered?: usersOrderByRelationAggregateInput
  }

  export type locationsWhereUniqueInput = {
    id?: string
    uuid?: string
  }

  export type locationsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    user_ids?: SortOrder
    organizations_ids?: SortOrder
    store_ids?: SortOrder
    _count?: locationsCountOrderByAggregateInput
    _avg?: locationsAvgOrderByAggregateInput
    _max?: locationsMaxOrderByAggregateInput
    _min?: locationsMinOrderByAggregateInput
    _sum?: locationsSumOrderByAggregateInput
  }

  export type locationsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<locationsScalarWhereWithAggregatesInput>
    OR?: Enumerable<locationsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<locationsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    uuid?: StringWithAggregatesFilter | string
    name?: StringNullableWithAggregatesFilter | string | null
    latitude?: FloatNullableWithAggregatesFilter | number | null
    longitude?: FloatNullableWithAggregatesFilter | number | null
    user_ids?: StringNullableListFilter
    organizations_ids?: StringNullableListFilter
    store_ids?: StringNullableListFilter
  }

  export type sessionsWhereInput = {
    AND?: Enumerable<sessionsWhereInput>
    OR?: Enumerable<sessionsWhereInput>
    NOT?: Enumerable<sessionsWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
    jwt?: StringFilter | string
    user_uuid?: StringFilter | string
    user_id?: StringFilter | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type sessionsOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    jwt?: SortOrder
    user_uuid?: SortOrder
    user_id?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type sessionsWhereUniqueInput = {
    id?: string
    uuid?: string
  }

  export type sessionsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    jwt?: SortOrder
    user_uuid?: SortOrder
    user_id?: SortOrder
    _count?: sessionsCountOrderByAggregateInput
    _max?: sessionsMaxOrderByAggregateInput
    _min?: sessionsMinOrderByAggregateInput
  }

  export type sessionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<sessionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<sessionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<sessionsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    uuid?: StringWithAggregatesFilter | string
    jwt?: StringWithAggregatesFilter | string
    user_uuid?: StringWithAggregatesFilter | string
    user_id?: StringWithAggregatesFilter | string
  }

  export type imagesWhereInput = {
    AND?: Enumerable<imagesWhereInput>
    OR?: Enumerable<imagesWhereInput>
    NOT?: Enumerable<imagesWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
    key?: StringFilter | string
    url?: StringNullableFilter | string | null
    clipped_key?: StringNullableFilter | string | null
    clipped_url?: StringNullableFilter | string | null
    item_ids?: StringNullableListFilter
    platforms?: PlatformsListRelationFilter
    providers?: ProvidersListRelationFilter
    organizations?: OrganizationsListRelationFilter
    stores?: StoresListRelationFilter
    users?: UsersListRelationFilter
    items?: ItemsListRelationFilter
  }

  export type imagesOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    key?: SortOrder
    url?: SortOrder
    clipped_key?: SortOrder
    clipped_url?: SortOrder
    item_ids?: SortOrder
    platforms?: platformsOrderByRelationAggregateInput
    providers?: providersOrderByRelationAggregateInput
    organizations?: organizationsOrderByRelationAggregateInput
    stores?: storesOrderByRelationAggregateInput
    users?: usersOrderByRelationAggregateInput
    items?: itemsOrderByRelationAggregateInput
  }

  export type imagesWhereUniqueInput = {
    id?: string
    uuid?: string
    key?: string
    url?: string
    clipped_key?: string
    clipped_url?: string
  }

  export type imagesOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    key?: SortOrder
    url?: SortOrder
    clipped_key?: SortOrder
    clipped_url?: SortOrder
    item_ids?: SortOrder
    _count?: imagesCountOrderByAggregateInput
    _max?: imagesMaxOrderByAggregateInput
    _min?: imagesMinOrderByAggregateInput
  }

  export type imagesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<imagesScalarWhereWithAggregatesInput>
    OR?: Enumerable<imagesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<imagesScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    uuid?: StringWithAggregatesFilter | string
    key?: StringWithAggregatesFilter | string
    url?: StringNullableWithAggregatesFilter | string | null
    clipped_key?: StringNullableWithAggregatesFilter | string | null
    clipped_url?: StringNullableWithAggregatesFilter | string | null
    item_ids?: StringNullableListFilter
  }

  export type ClauTestWhereInput = {
    AND?: Enumerable<ClauTestWhereInput>
    OR?: Enumerable<ClauTestWhereInput>
    NOT?: Enumerable<ClauTestWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
  }

  export type ClauTestOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
  }

  export type ClauTestWhereUniqueInput = {
    id?: string
    uuid?: string
  }

  export type ClauTestOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    _count?: ClauTestCountOrderByAggregateInput
    _max?: ClauTestMaxOrderByAggregateInput
    _min?: ClauTestMinOrderByAggregateInput
  }

  export type ClauTestScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ClauTestScalarWhereWithAggregatesInput>
    OR?: Enumerable<ClauTestScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ClauTestScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    uuid?: StringWithAggregatesFilter | string
  }

  export type platformsCreateInput = {
    id?: string
    uuid?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    key: string
    username?: string | null
    name?: string | null
    image?: imagesCreateNestedOneWithoutPlatformsInput
    providers?: providersCreateNestedManyWithoutPlatformsInput
    provider_keys?: provider_keysCreateNestedManyWithoutPlatformsInput
    users?: usersCreateNestedManyWithoutPlatformsInput
    organizations?: organizationsCreateNestedManyWithoutPlatformsInput
  }

  export type platformsUncheckedCreateInput = {
    id?: string
    uuid?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    key: string
    username?: string | null
    name?: string | null
    image_id?: string | null
    provider_ids?: platformsCreateprovider_idsInput | Enumerable<string>
    provider_key_ids?: platformsCreateprovider_key_idsInput | Enumerable<string>
    user_ids?: platformsCreateuser_idsInput | Enumerable<string>
    organization_ids?: platformsCreateorganization_idsInput | Enumerable<string>
    providers?: providersUncheckedCreateNestedManyWithoutPlatformsInput
    provider_keys?: provider_keysUncheckedCreateNestedManyWithoutPlatformsInput
    users?: usersUncheckedCreateNestedManyWithoutPlatformsInput
    organizations?: organizationsUncheckedCreateNestedManyWithoutPlatformsInput
  }

  export type platformsUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    key?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: imagesUpdateOneWithoutPlatformsNestedInput
    providers?: providersUpdateManyWithoutPlatformsNestedInput
    provider_keys?: provider_keysUpdateManyWithoutPlatformsNestedInput
    users?: usersUpdateManyWithoutPlatformsNestedInput
    organizations?: organizationsUpdateManyWithoutPlatformsNestedInput
  }

  export type platformsUncheckedUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    key?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_ids?: platformsUpdateprovider_idsInput | Enumerable<string>
    provider_key_ids?: platformsUpdateprovider_key_idsInput | Enumerable<string>
    user_ids?: platformsUpdateuser_idsInput | Enumerable<string>
    organization_ids?: platformsUpdateorganization_idsInput | Enumerable<string>
    providers?: providersUncheckedUpdateManyWithoutPlatformsNestedInput
    provider_keys?: provider_keysUncheckedUpdateManyWithoutPlatformsNestedInput
    users?: usersUncheckedUpdateManyWithoutPlatformsNestedInput
    organizations?: organizationsUncheckedUpdateManyWithoutPlatformsNestedInput
  }

  export type platformsCreateManyInput = {
    id?: string
    uuid?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    key: string
    username?: string | null
    name?: string | null
    image_id?: string | null
    provider_ids?: platformsCreateprovider_idsInput | Enumerable<string>
    provider_key_ids?: platformsCreateprovider_key_idsInput | Enumerable<string>
    user_ids?: platformsCreateuser_idsInput | Enumerable<string>
    organization_ids?: platformsCreateorganization_idsInput | Enumerable<string>
  }

  export type platformsUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    key?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type platformsUncheckedUpdateManyInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    key?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_ids?: platformsUpdateprovider_idsInput | Enumerable<string>
    provider_key_ids?: platformsUpdateprovider_key_idsInput | Enumerable<string>
    user_ids?: platformsUpdateuser_idsInput | Enumerable<string>
    organization_ids?: platformsUpdateorganization_idsInput | Enumerable<string>
  }

  export type providersCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    key: string
    name?: string | null
    provider_key_ids?: providersCreateprovider_key_idsInput | Enumerable<string>
    image?: imagesCreateNestedOneWithoutProvidersInput
    platforms?: platformsCreateNestedManyWithoutProvidersInput
    provider_keys?: provider_keysCreateNestedManyWithoutProviderInput
  }

  export type providersUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    key: string
    name?: string | null
    image_id?: string | null
    platform_ids?: providersCreateplatform_idsInput | Enumerable<string>
    provider_key_ids?: providersCreateprovider_key_idsInput | Enumerable<string>
    platforms?: platformsUncheckedCreateNestedManyWithoutProvidersInput
    provider_keys?: provider_keysUncheckedCreateNestedManyWithoutProviderInput
  }

  export type providersUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    provider_key_ids?: providersUpdateprovider_key_idsInput | Enumerable<string>
    image?: imagesUpdateOneWithoutProvidersNestedInput
    platforms?: platformsUpdateManyWithoutProvidersNestedInput
    provider_keys?: provider_keysUpdateManyWithoutProviderNestedInput
  }

  export type providersUncheckedUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    platform_ids?: providersUpdateplatform_idsInput | Enumerable<string>
    provider_key_ids?: providersUpdateprovider_key_idsInput | Enumerable<string>
    platforms?: platformsUncheckedUpdateManyWithoutProvidersNestedInput
    provider_keys?: provider_keysUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type providersCreateManyInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    key: string
    name?: string | null
    image_id?: string | null
    platform_ids?: providersCreateplatform_idsInput | Enumerable<string>
    provider_key_ids?: providersCreateprovider_key_idsInput | Enumerable<string>
  }

  export type providersUpdateManyMutationInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    provider_key_ids?: providersUpdateprovider_key_idsInput | Enumerable<string>
  }

  export type providersUncheckedUpdateManyInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    platform_ids?: providersUpdateplatform_idsInput | Enumerable<string>
    provider_key_ids?: providersUpdateprovider_key_idsInput | Enumerable<string>
  }

  export type provider_keysCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    public_key: string
    private_key: string
    secret: boolean
    description?: string | null
    provider: providersCreateNestedOneWithoutProvider_keysInput
    platforms?: platformsCreateNestedManyWithoutProvider_keysInput
  }

  export type provider_keysUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    public_key: string
    private_key: string
    secret: boolean
    description?: string | null
    provider_id: string
    platform_ids?: provider_keysCreateplatform_idsInput | Enumerable<string>
    platforms?: platformsUncheckedCreateNestedManyWithoutProvider_keysInput
  }

  export type provider_keysUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    public_key?: StringFieldUpdateOperationsInput | string
    private_key?: StringFieldUpdateOperationsInput | string
    secret?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: providersUpdateOneRequiredWithoutProvider_keysNestedInput
    platforms?: platformsUpdateManyWithoutProvider_keysNestedInput
  }

  export type provider_keysUncheckedUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    public_key?: StringFieldUpdateOperationsInput | string
    private_key?: StringFieldUpdateOperationsInput | string
    secret?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    provider_id?: StringFieldUpdateOperationsInput | string
    platform_ids?: provider_keysUpdateplatform_idsInput | Enumerable<string>
    platforms?: platformsUncheckedUpdateManyWithoutProvider_keysNestedInput
  }

  export type provider_keysCreateManyInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    public_key: string
    private_key: string
    secret: boolean
    description?: string | null
    provider_id: string
    platform_ids?: provider_keysCreateplatform_idsInput | Enumerable<string>
  }

  export type provider_keysUpdateManyMutationInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    public_key?: StringFieldUpdateOperationsInput | string
    private_key?: StringFieldUpdateOperationsInput | string
    secret?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type provider_keysUncheckedUpdateManyInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    public_key?: StringFieldUpdateOperationsInput | string
    private_key?: StringFieldUpdateOperationsInput | string
    secret?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    provider_id?: StringFieldUpdateOperationsInput | string
    platform_ids?: provider_keysUpdateplatform_idsInput | Enumerable<string>
  }

  export type usersCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    email?: string | null
    phone?: string | null
    name?: string | null
    birthDate?: Date | string | null
    gender?: GenderType | null
    image?: imagesCreateNestedOneWithoutUsersInput
    prefered_location?: locationsCreateNestedOneWithoutUsers_preferedInput
    locations?: locationsCreateNestedManyWithoutUsersInput
    platforms?: platformsCreateNestedManyWithoutUsersInput
    organizations?: organizationsCreateNestedManyWithoutUsersInput
    stores?: storesCreateNestedManyWithoutUsersInput
    payments_created?: paymentCreateNestedManyWithoutUser_creatorInput
    payments_confirmed?: paymentCreateNestedManyWithoutUser_confirmInput
    session?: sessionsCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    email?: string | null
    phone?: string | null
    name?: string | null
    birthDate?: Date | string | null
    gender?: GenderType | null
    image_id?: string | null
    prefered_location_id?: string | null
    location_ids?: usersCreatelocation_idsInput | Enumerable<string>
    platform_ids?: usersCreateplatform_idsInput | Enumerable<string>
    organization_ids?: usersCreateorganization_idsInput | Enumerable<string>
    store_ids?: usersCreatestore_idsInput | Enumerable<string>
    locations?: locationsUncheckedCreateNestedManyWithoutUsersInput
    platforms?: platformsUncheckedCreateNestedManyWithoutUsersInput
    organizations?: organizationsUncheckedCreateNestedManyWithoutUsersInput
    stores?: storesUncheckedCreateNestedManyWithoutUsersInput
    payments_created?: paymentUncheckedCreateNestedManyWithoutUser_creatorInput
    payments_confirmed?: paymentUncheckedCreateNestedManyWithoutUser_confirmInput
    session?: sessionsUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    image?: imagesUpdateOneWithoutUsersNestedInput
    prefered_location?: locationsUpdateOneWithoutUsers_preferedNestedInput
    locations?: locationsUpdateManyWithoutUsersNestedInput
    platforms?: platformsUpdateManyWithoutUsersNestedInput
    organizations?: organizationsUpdateManyWithoutUsersNestedInput
    stores?: storesUpdateManyWithoutUsersNestedInput
    payments_created?: paymentUpdateManyWithoutUser_creatorNestedInput
    payments_confirmed?: paymentUpdateManyWithoutUser_confirmNestedInput
    session?: sessionsUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    prefered_location_id?: NullableStringFieldUpdateOperationsInput | string | null
    location_ids?: usersUpdatelocation_idsInput | Enumerable<string>
    platform_ids?: usersUpdateplatform_idsInput | Enumerable<string>
    organization_ids?: usersUpdateorganization_idsInput | Enumerable<string>
    store_ids?: usersUpdatestore_idsInput | Enumerable<string>
    locations?: locationsUncheckedUpdateManyWithoutUsersNestedInput
    platforms?: platformsUncheckedUpdateManyWithoutUsersNestedInput
    organizations?: organizationsUncheckedUpdateManyWithoutUsersNestedInput
    stores?: storesUncheckedUpdateManyWithoutUsersNestedInput
    payments_created?: paymentUncheckedUpdateManyWithoutUser_creatorNestedInput
    payments_confirmed?: paymentUncheckedUpdateManyWithoutUser_confirmNestedInput
    session?: sessionsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateManyInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    email?: string | null
    phone?: string | null
    name?: string | null
    birthDate?: Date | string | null
    gender?: GenderType | null
    image_id?: string | null
    prefered_location_id?: string | null
    location_ids?: usersCreatelocation_idsInput | Enumerable<string>
    platform_ids?: usersCreateplatform_idsInput | Enumerable<string>
    organization_ids?: usersCreateorganization_idsInput | Enumerable<string>
    store_ids?: usersCreatestore_idsInput | Enumerable<string>
  }

  export type usersUpdateManyMutationInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
  }

  export type usersUncheckedUpdateManyInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    prefered_location_id?: NullableStringFieldUpdateOperationsInput | string | null
    location_ids?: usersUpdatelocation_idsInput | Enumerable<string>
    platform_ids?: usersUpdateplatform_idsInput | Enumerable<string>
    organization_ids?: usersUpdateorganization_idsInput | Enumerable<string>
    store_ids?: usersUpdatestore_idsInput | Enumerable<string>
  }

  export type organizationsCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    name?: string | null
    image?: imagesCreateNestedOneWithoutOrganizationsInput
    platforms?: platformsCreateNestedManyWithoutOrganizationsInput
    users?: usersCreateNestedManyWithoutOrganizationsInput
    locations?: locationsCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    name?: string | null
    image_id?: string | null
    platform_ids?: organizationsCreateplatform_idsInput | Enumerable<string>
    user_ids?: organizationsCreateuser_idsInput | Enumerable<string>
    location_ids?: organizationsCreatelocation_idsInput | Enumerable<string>
    platforms?: platformsUncheckedCreateNestedManyWithoutOrganizationsInput
    users?: usersUncheckedCreateNestedManyWithoutOrganizationsInput
    locations?: locationsUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: imagesUpdateOneWithoutOrganizationsNestedInput
    platforms?: platformsUpdateManyWithoutOrganizationsNestedInput
    users?: usersUpdateManyWithoutOrganizationsNestedInput
    locations?: locationsUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsUncheckedUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    platform_ids?: organizationsUpdateplatform_idsInput | Enumerable<string>
    user_ids?: organizationsUpdateuser_idsInput | Enumerable<string>
    location_ids?: organizationsUpdatelocation_idsInput | Enumerable<string>
    platforms?: platformsUncheckedUpdateManyWithoutOrganizationsNestedInput
    users?: usersUncheckedUpdateManyWithoutOrganizationsNestedInput
    locations?: locationsUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsCreateManyInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    name?: string | null
    image_id?: string | null
    platform_ids?: organizationsCreateplatform_idsInput | Enumerable<string>
    user_ids?: organizationsCreateuser_idsInput | Enumerable<string>
    location_ids?: organizationsCreatelocation_idsInput | Enumerable<string>
  }

  export type organizationsUpdateManyMutationInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type organizationsUncheckedUpdateManyInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    platform_ids?: organizationsUpdateplatform_idsInput | Enumerable<string>
    user_ids?: organizationsUpdateuser_idsInput | Enumerable<string>
    location_ids?: organizationsUpdatelocation_idsInput | Enumerable<string>
  }

  export type storesCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    name?: string | null
    image?: imagesCreateNestedOneWithoutStoresInput
    users?: usersCreateNestedManyWithoutStoresInput
    locations?: locationsCreateNestedManyWithoutStoresInput
    inventories?: inventoriesCreateNestedManyWithoutStoresInput
  }

  export type storesUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    name?: string | null
    image_id?: string | null
    user_ids?: storesCreateuser_idsInput | Enumerable<string>
    location_ids?: storesCreatelocation_idsInput | Enumerable<string>
    inventory_ids?: storesCreateinventory_idsInput | Enumerable<string>
    users?: usersUncheckedCreateNestedManyWithoutStoresInput
    locations?: locationsUncheckedCreateNestedManyWithoutStoresInput
    inventories?: inventoriesUncheckedCreateNestedManyWithoutStoresInput
  }

  export type storesUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: imagesUpdateOneWithoutStoresNestedInput
    users?: usersUpdateManyWithoutStoresNestedInput
    locations?: locationsUpdateManyWithoutStoresNestedInput
    inventories?: inventoriesUpdateManyWithoutStoresNestedInput
  }

  export type storesUncheckedUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_ids?: storesUpdateuser_idsInput | Enumerable<string>
    location_ids?: storesUpdatelocation_idsInput | Enumerable<string>
    inventory_ids?: storesUpdateinventory_idsInput | Enumerable<string>
    users?: usersUncheckedUpdateManyWithoutStoresNestedInput
    locations?: locationsUncheckedUpdateManyWithoutStoresNestedInput
    inventories?: inventoriesUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type storesCreateManyInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    name?: string | null
    image_id?: string | null
    user_ids?: storesCreateuser_idsInput | Enumerable<string>
    location_ids?: storesCreatelocation_idsInput | Enumerable<string>
    inventory_ids?: storesCreateinventory_idsInput | Enumerable<string>
  }

  export type storesUpdateManyMutationInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type storesUncheckedUpdateManyInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_ids?: storesUpdateuser_idsInput | Enumerable<string>
    location_ids?: storesUpdatelocation_idsInput | Enumerable<string>
    inventory_ids?: storesUpdateinventory_idsInput | Enumerable<string>
  }

  export type inventoriesCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    name?: string | null
    description?: string | null
    item_inventories?: item_inventoriesCreateNestedManyWithoutInventoriesInput
    stores?: storesCreateNestedManyWithoutInventoriesInput
  }

  export type inventoriesUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    name?: string | null
    description?: string | null
    item_iventory_ids?: inventoriesCreateitem_iventory_idsInput | Enumerable<string>
    store_ids?: inventoriesCreatestore_idsInput | Enumerable<string>
    item_inventories?: item_inventoriesUncheckedCreateNestedManyWithoutInventoriesInput
    stores?: storesUncheckedCreateNestedManyWithoutInventoriesInput
  }

  export type inventoriesUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    item_inventories?: item_inventoriesUpdateManyWithoutInventoriesNestedInput
    stores?: storesUpdateManyWithoutInventoriesNestedInput
  }

  export type inventoriesUncheckedUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    item_iventory_ids?: inventoriesUpdateitem_iventory_idsInput | Enumerable<string>
    store_ids?: inventoriesUpdatestore_idsInput | Enumerable<string>
    item_inventories?: item_inventoriesUncheckedUpdateManyWithoutInventoriesNestedInput
    stores?: storesUncheckedUpdateManyWithoutInventoriesNestedInput
  }

  export type inventoriesCreateManyInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    name?: string | null
    description?: string | null
    item_iventory_ids?: inventoriesCreateitem_iventory_idsInput | Enumerable<string>
    store_ids?: inventoriesCreatestore_idsInput | Enumerable<string>
  }

  export type inventoriesUpdateManyMutationInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inventoriesUncheckedUpdateManyInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    item_iventory_ids?: inventoriesUpdateitem_iventory_idsInput | Enumerable<string>
    store_ids?: inventoriesUpdatestore_idsInput | Enumerable<string>
  }

  export type item_inventoriesCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    type: ItemQualitativeType
    value: number
    item: itemsCreateNestedOneWithoutItem_inventoriesInput
    inventories?: inventoriesCreateNestedManyWithoutItem_inventoriesInput
  }

  export type item_inventoriesUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    item_id: string
    type: ItemQualitativeType
    value: number
    iventory_ids?: item_inventoriesCreateiventory_idsInput | Enumerable<string>
    inventories?: inventoriesUncheckedCreateNestedManyWithoutItem_inventoriesInput
  }

  export type item_inventoriesUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumItemQualitativeTypeFieldUpdateOperationsInput | ItemQualitativeType
    value?: FloatFieldUpdateOperationsInput | number
    item?: itemsUpdateOneRequiredWithoutItem_inventoriesNestedInput
    inventories?: inventoriesUpdateManyWithoutItem_inventoriesNestedInput
  }

  export type item_inventoriesUncheckedUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    type?: EnumItemQualitativeTypeFieldUpdateOperationsInput | ItemQualitativeType
    value?: FloatFieldUpdateOperationsInput | number
    iventory_ids?: item_inventoriesUpdateiventory_idsInput | Enumerable<string>
    inventories?: inventoriesUncheckedUpdateManyWithoutItem_inventoriesNestedInput
  }

  export type item_inventoriesCreateManyInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    item_id: string
    type: ItemQualitativeType
    value: number
    iventory_ids?: item_inventoriesCreateiventory_idsInput | Enumerable<string>
  }

  export type item_inventoriesUpdateManyMutationInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumItemQualitativeTypeFieldUpdateOperationsInput | ItemQualitativeType
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type item_inventoriesUncheckedUpdateManyInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    type?: EnumItemQualitativeTypeFieldUpdateOperationsInput | ItemQualitativeType
    value?: FloatFieldUpdateOperationsInput | number
    iventory_ids?: item_inventoriesUpdateiventory_idsInput | Enumerable<string>
  }

  export type odersCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    total: number
    item_orders?: item_ordersCreateNestedManyWithoutOrdersInput
  }

  export type odersUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    total: number
    item_order_ids?: odersCreateitem_order_idsInput | Enumerable<string>
    item_orders?: item_ordersUncheckedCreateNestedManyWithoutOrdersInput
  }

  export type odersUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    item_orders?: item_ordersUpdateManyWithoutOrdersNestedInput
  }

  export type odersUncheckedUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    item_order_ids?: odersUpdateitem_order_idsInput | Enumerable<string>
    item_orders?: item_ordersUncheckedUpdateManyWithoutOrdersNestedInput
  }

  export type odersCreateManyInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    total: number
    item_order_ids?: odersCreateitem_order_idsInput | Enumerable<string>
  }

  export type odersUpdateManyMutationInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type odersUncheckedUpdateManyInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    item_order_ids?: odersUpdateitem_order_idsInput | Enumerable<string>
  }

  export type item_ordersCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    type: ItemQualitativeType
    value: number
    item: itemsCreateNestedOneWithoutItem_ordersInput
    orders?: odersCreateNestedManyWithoutItem_ordersInput
  }

  export type item_ordersUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    item_id: string
    type: ItemQualitativeType
    value: number
    order_ids?: item_ordersCreateorder_idsInput | Enumerable<string>
    orders?: odersUncheckedCreateNestedManyWithoutItem_ordersInput
  }

  export type item_ordersUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumItemQualitativeTypeFieldUpdateOperationsInput | ItemQualitativeType
    value?: FloatFieldUpdateOperationsInput | number
    item?: itemsUpdateOneRequiredWithoutItem_ordersNestedInput
    orders?: odersUpdateManyWithoutItem_ordersNestedInput
  }

  export type item_ordersUncheckedUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    type?: EnumItemQualitativeTypeFieldUpdateOperationsInput | ItemQualitativeType
    value?: FloatFieldUpdateOperationsInput | number
    order_ids?: item_ordersUpdateorder_idsInput | Enumerable<string>
    orders?: odersUncheckedUpdateManyWithoutItem_ordersNestedInput
  }

  export type item_ordersCreateManyInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    item_id: string
    type: ItemQualitativeType
    value: number
    order_ids?: item_ordersCreateorder_idsInput | Enumerable<string>
  }

  export type item_ordersUpdateManyMutationInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumItemQualitativeTypeFieldUpdateOperationsInput | ItemQualitativeType
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type item_ordersUncheckedUpdateManyInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    type?: EnumItemQualitativeTypeFieldUpdateOperationsInput | ItemQualitativeType
    value?: FloatFieldUpdateOperationsInput | number
    order_ids?: item_ordersUpdateorder_idsInput | Enumerable<string>
  }

  export type PaymentTypeCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    title?: string | null
    description?: string | null
    payments?: paymentCreateNestedManyWithoutPayment_typeInput
  }

  export type PaymentTypeUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    title?: string | null
    description?: string | null
    payments?: paymentUncheckedCreateNestedManyWithoutPayment_typeInput
  }

  export type PaymentTypeUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: paymentUpdateManyWithoutPayment_typeNestedInput
  }

  export type PaymentTypeUncheckedUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: paymentUncheckedUpdateManyWithoutPayment_typeNestedInput
  }

  export type PaymentTypeCreateManyInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    title?: string | null
    description?: string | null
  }

  export type PaymentTypeUpdateManyMutationInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentTypeUncheckedUpdateManyInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    title?: string | null
    description?: string | null
    amount: XOR<CurrencyCreateEnvelopeInput, CurrencyCreateInput>
    payment_type: PaymentTypeCreateNestedOneWithoutPaymentsInput
    user_creator: usersCreateNestedOneWithoutPayments_createdInput
    user_confirm: usersCreateNestedOneWithoutPayments_confirmedInput
    recever_account: PaymentAccountCreateNestedOneWithoutPayments_receivedInput
    sender_account: PaymentAccountCreateNestedOneWithoutPayments_sendedInput
  }

  export type paymentUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    title?: string | null
    description?: string | null
    payment_type_id: string
    user_creator_id: string
    user_confirm_id: string
    receiver_account_id: string
    sender_account_id: string
    amount: XOR<CurrencyCreateEnvelopeInput, CurrencyCreateInput>
  }

  export type paymentUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: XOR<CurrencyUpdateEnvelopeInput, CurrencyCreateInput>
    payment_type?: PaymentTypeUpdateOneRequiredWithoutPaymentsNestedInput
    user_creator?: usersUpdateOneRequiredWithoutPayments_createdNestedInput
    user_confirm?: usersUpdateOneRequiredWithoutPayments_confirmedNestedInput
    recever_account?: PaymentAccountUpdateOneRequiredWithoutPayments_receivedNestedInput
    sender_account?: PaymentAccountUpdateOneRequiredWithoutPayments_sendedNestedInput
  }

  export type paymentUncheckedUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    payment_type_id?: StringFieldUpdateOperationsInput | string
    user_creator_id?: StringFieldUpdateOperationsInput | string
    user_confirm_id?: StringFieldUpdateOperationsInput | string
    receiver_account_id?: StringFieldUpdateOperationsInput | string
    sender_account_id?: StringFieldUpdateOperationsInput | string
    amount?: XOR<CurrencyUpdateEnvelopeInput, CurrencyCreateInput>
  }

  export type paymentCreateManyInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    title?: string | null
    description?: string | null
    payment_type_id: string
    user_creator_id: string
    user_confirm_id: string
    receiver_account_id: string
    sender_account_id: string
    amount: XOR<CurrencyCreateEnvelopeInput, CurrencyCreateInput>
  }

  export type paymentUpdateManyMutationInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: XOR<CurrencyUpdateEnvelopeInput, CurrencyCreateInput>
  }

  export type paymentUncheckedUpdateManyInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    payment_type_id?: StringFieldUpdateOperationsInput | string
    user_creator_id?: StringFieldUpdateOperationsInput | string
    user_confirm_id?: StringFieldUpdateOperationsInput | string
    receiver_account_id?: StringFieldUpdateOperationsInput | string
    sender_account_id?: StringFieldUpdateOperationsInput | string
    amount?: XOR<CurrencyUpdateEnvelopeInput, CurrencyCreateInput>
  }

  export type PaymentAccountCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    amount: XOR<CurrencyCreateEnvelopeInput, CurrencyCreateInput>
    payments_received?: paymentCreateNestedManyWithoutRecever_accountInput
    payments_sended?: paymentCreateNestedManyWithoutSender_accountInput
  }

  export type PaymentAccountUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    amount: XOR<CurrencyCreateEnvelopeInput, CurrencyCreateInput>
    payments_received?: paymentUncheckedCreateNestedManyWithoutRecever_accountInput
    payments_sended?: paymentUncheckedCreateNestedManyWithoutSender_accountInput
  }

  export type PaymentAccountUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    amount?: XOR<CurrencyUpdateEnvelopeInput, CurrencyCreateInput>
    payments_received?: paymentUpdateManyWithoutRecever_accountNestedInput
    payments_sended?: paymentUpdateManyWithoutSender_accountNestedInput
  }

  export type PaymentAccountUncheckedUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    amount?: XOR<CurrencyUpdateEnvelopeInput, CurrencyCreateInput>
    payments_received?: paymentUncheckedUpdateManyWithoutRecever_accountNestedInput
    payments_sended?: paymentUncheckedUpdateManyWithoutSender_accountNestedInput
  }

  export type PaymentAccountCreateManyInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    amount: XOR<CurrencyCreateEnvelopeInput, CurrencyCreateInput>
  }

  export type PaymentAccountUpdateManyMutationInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    amount?: XOR<CurrencyUpdateEnvelopeInput, CurrencyCreateInput>
  }

  export type PaymentAccountUncheckedUpdateManyInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    amount?: XOR<CurrencyUpdateEnvelopeInput, CurrencyCreateInput>
  }

  export type itemsCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    name?: string | null
    description?: string | null
    tags?: itemsCreatetagsInput | Enumerable<string>
    prices?: XOR<CurrencyListCreateEnvelopeInput, Enumerable<CurrencyCreateInput>>
    images?: imagesCreateNestedManyWithoutItemsInput
    item_inventories?: item_inventoriesCreateNestedManyWithoutItemInput
    item_orders?: item_ordersCreateNestedManyWithoutItemInput
  }

  export type itemsUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    name?: string | null
    description?: string | null
    tags?: itemsCreatetagsInput | Enumerable<string>
    image_ids?: itemsCreateimage_idsInput | Enumerable<string>
    prices?: XOR<CurrencyListCreateEnvelopeInput, Enumerable<CurrencyCreateInput>>
    images?: imagesUncheckedCreateNestedManyWithoutItemsInput
    item_inventories?: item_inventoriesUncheckedCreateNestedManyWithoutItemInput
    item_orders?: item_ordersUncheckedCreateNestedManyWithoutItemInput
  }

  export type itemsUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: itemsUpdatetagsInput | Enumerable<string>
    prices?: XOR<CurrencyListUpdateEnvelopeInput, Enumerable<CurrencyCreateInput>>
    images?: imagesUpdateManyWithoutItemsNestedInput
    item_inventories?: item_inventoriesUpdateManyWithoutItemNestedInput
    item_orders?: item_ordersUpdateManyWithoutItemNestedInput
  }

  export type itemsUncheckedUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: itemsUpdatetagsInput | Enumerable<string>
    image_ids?: itemsUpdateimage_idsInput | Enumerable<string>
    prices?: XOR<CurrencyListUpdateEnvelopeInput, Enumerable<CurrencyCreateInput>>
    images?: imagesUncheckedUpdateManyWithoutItemsNestedInput
    item_inventories?: item_inventoriesUncheckedUpdateManyWithoutItemNestedInput
    item_orders?: item_ordersUncheckedUpdateManyWithoutItemNestedInput
  }

  export type itemsCreateManyInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    name?: string | null
    description?: string | null
    tags?: itemsCreatetagsInput | Enumerable<string>
    image_ids?: itemsCreateimage_idsInput | Enumerable<string>
    prices?: XOR<CurrencyListCreateEnvelopeInput, Enumerable<CurrencyCreateInput>>
  }

  export type itemsUpdateManyMutationInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: itemsUpdatetagsInput | Enumerable<string>
    prices?: XOR<CurrencyListUpdateEnvelopeInput, Enumerable<CurrencyCreateInput>>
  }

  export type itemsUncheckedUpdateManyInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: itemsUpdatetagsInput | Enumerable<string>
    image_ids?: itemsUpdateimage_idsInput | Enumerable<string>
    prices?: XOR<CurrencyListUpdateEnvelopeInput, Enumerable<CurrencyCreateInput>>
  }

  export type locationsCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    name?: string | null
    latitude?: number | null
    longitude?: number | null
    store_ids?: locationsCreatestore_idsInput | Enumerable<string>
    users?: usersCreateNestedManyWithoutLocationsInput
    organizations?: organizationsCreateNestedManyWithoutLocationsInput
    stores?: storesCreateNestedManyWithoutLocationsInput
    users_prefered?: usersCreateNestedManyWithoutPrefered_locationInput
  }

  export type locationsUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    name?: string | null
    latitude?: number | null
    longitude?: number | null
    user_ids?: locationsCreateuser_idsInput | Enumerable<string>
    organizations_ids?: locationsCreateorganizations_idsInput | Enumerable<string>
    store_ids?: locationsCreatestore_idsInput | Enumerable<string>
    users?: usersUncheckedCreateNestedManyWithoutLocationsInput
    organizations?: organizationsUncheckedCreateNestedManyWithoutLocationsInput
    stores?: storesUncheckedCreateNestedManyWithoutLocationsInput
    users_prefered?: usersUncheckedCreateNestedManyWithoutPrefered_locationInput
  }

  export type locationsUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    store_ids?: locationsUpdatestore_idsInput | Enumerable<string>
    users?: usersUpdateManyWithoutLocationsNestedInput
    organizations?: organizationsUpdateManyWithoutLocationsNestedInput
    stores?: storesUpdateManyWithoutLocationsNestedInput
    users_prefered?: usersUpdateManyWithoutPrefered_locationNestedInput
  }

  export type locationsUncheckedUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    user_ids?: locationsUpdateuser_idsInput | Enumerable<string>
    organizations_ids?: locationsUpdateorganizations_idsInput | Enumerable<string>
    store_ids?: locationsUpdatestore_idsInput | Enumerable<string>
    users?: usersUncheckedUpdateManyWithoutLocationsNestedInput
    organizations?: organizationsUncheckedUpdateManyWithoutLocationsNestedInput
    stores?: storesUncheckedUpdateManyWithoutLocationsNestedInput
    users_prefered?: usersUncheckedUpdateManyWithoutPrefered_locationNestedInput
  }

  export type locationsCreateManyInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    name?: string | null
    latitude?: number | null
    longitude?: number | null
    user_ids?: locationsCreateuser_idsInput | Enumerable<string>
    organizations_ids?: locationsCreateorganizations_idsInput | Enumerable<string>
    store_ids?: locationsCreatestore_idsInput | Enumerable<string>
  }

  export type locationsUpdateManyMutationInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    store_ids?: locationsUpdatestore_idsInput | Enumerable<string>
  }

  export type locationsUncheckedUpdateManyInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    user_ids?: locationsUpdateuser_idsInput | Enumerable<string>
    organizations_ids?: locationsUpdateorganizations_idsInput | Enumerable<string>
    store_ids?: locationsUpdatestore_idsInput | Enumerable<string>
  }

  export type sessionsCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    jwt: string
    user_uuid: string
    user: usersCreateNestedOneWithoutSessionInput
  }

  export type sessionsUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    jwt: string
    user_uuid: string
    user_id: string
  }

  export type sessionsUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    jwt?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    user?: usersUpdateOneRequiredWithoutSessionNestedInput
  }

  export type sessionsUncheckedUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    jwt?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type sessionsCreateManyInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    jwt: string
    user_uuid: string
    user_id: string
  }

  export type sessionsUpdateManyMutationInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    jwt?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
  }

  export type sessionsUncheckedUpdateManyInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    jwt?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type imagesCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    key: string
    url?: string | null
    clipped_key?: string | null
    clipped_url?: string | null
    platforms?: platformsCreateNestedManyWithoutImageInput
    providers?: providersCreateNestedManyWithoutImageInput
    organizations?: organizationsCreateNestedManyWithoutImageInput
    stores?: storesCreateNestedManyWithoutImageInput
    users?: usersCreateNestedManyWithoutImageInput
    items?: itemsCreateNestedManyWithoutImagesInput
  }

  export type imagesUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    key: string
    url?: string | null
    clipped_key?: string | null
    clipped_url?: string | null
    item_ids?: imagesCreateitem_idsInput | Enumerable<string>
    platforms?: platformsUncheckedCreateNestedManyWithoutImageInput
    providers?: providersUncheckedCreateNestedManyWithoutImageInput
    organizations?: organizationsUncheckedCreateNestedManyWithoutImageInput
    stores?: storesUncheckedCreateNestedManyWithoutImageInput
    users?: usersUncheckedCreateNestedManyWithoutImageInput
    items?: itemsUncheckedCreateNestedManyWithoutImagesInput
  }

  export type imagesUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_key?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_url?: NullableStringFieldUpdateOperationsInput | string | null
    platforms?: platformsUpdateManyWithoutImageNestedInput
    providers?: providersUpdateManyWithoutImageNestedInput
    organizations?: organizationsUpdateManyWithoutImageNestedInput
    stores?: storesUpdateManyWithoutImageNestedInput
    users?: usersUpdateManyWithoutImageNestedInput
    items?: itemsUpdateManyWithoutImagesNestedInput
  }

  export type imagesUncheckedUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_key?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_url?: NullableStringFieldUpdateOperationsInput | string | null
    item_ids?: imagesUpdateitem_idsInput | Enumerable<string>
    platforms?: platformsUncheckedUpdateManyWithoutImageNestedInput
    providers?: providersUncheckedUpdateManyWithoutImageNestedInput
    organizations?: organizationsUncheckedUpdateManyWithoutImageNestedInput
    stores?: storesUncheckedUpdateManyWithoutImageNestedInput
    users?: usersUncheckedUpdateManyWithoutImageNestedInput
    items?: itemsUncheckedUpdateManyWithoutImagesNestedInput
  }

  export type imagesCreateManyInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    key: string
    url?: string | null
    clipped_key?: string | null
    clipped_url?: string | null
    item_ids?: imagesCreateitem_idsInput | Enumerable<string>
  }

  export type imagesUpdateManyMutationInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_key?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type imagesUncheckedUpdateManyInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_key?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_url?: NullableStringFieldUpdateOperationsInput | string | null
    item_ids?: imagesUpdateitem_idsInput | Enumerable<string>
  }

  export type ClauTestCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
  }

  export type ClauTestUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
  }

  export type ClauTestUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
  }

  export type ClauTestUncheckedUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
  }

  export type ClauTestCreateManyInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
  }

  export type ClauTestUpdateManyMutationInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
  }

  export type ClauTestUncheckedUpdateManyInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
    isSet?: boolean
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
    isSet?: boolean
  }

  export type StringNullableListFilter = {
    equals?: Enumerable<string> | null
    has?: string | null
    hasEvery?: Enumerable<string>
    hasSome?: Enumerable<string>
    isEmpty?: boolean
  }

  export type ImagesRelationFilter = {
    is?: imagesWhereInput | null
    isNot?: imagesWhereInput | null
  }

  export type ProvidersListRelationFilter = {
    every?: providersWhereInput
    some?: providersWhereInput
    none?: providersWhereInput
  }

  export type Provider_keysListRelationFilter = {
    every?: provider_keysWhereInput
    some?: provider_keysWhereInput
    none?: provider_keysWhereInput
  }

  export type UsersListRelationFilter = {
    every?: usersWhereInput
    some?: usersWhereInput
    none?: usersWhereInput
  }

  export type OrganizationsListRelationFilter = {
    every?: organizationsWhereInput
    some?: organizationsWhereInput
    none?: organizationsWhereInput
  }

  export type providersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type provider_keysOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type organizationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type platformsCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    key?: SortOrder
    username?: SortOrder
    name?: SortOrder
    image_id?: SortOrder
    provider_ids?: SortOrder
    provider_key_ids?: SortOrder
    user_ids?: SortOrder
    organization_ids?: SortOrder
  }

  export type platformsMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    key?: SortOrder
    username?: SortOrder
    name?: SortOrder
    image_id?: SortOrder
  }

  export type platformsMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    key?: SortOrder
    username?: SortOrder
    name?: SortOrder
    image_id?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
    isSet?: boolean
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    isSet?: boolean
  }

  export type PlatformsListRelationFilter = {
    every?: platformsWhereInput
    some?: platformsWhereInput
    none?: platformsWhereInput
  }

  export type platformsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type providersCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    key?: SortOrder
    name?: SortOrder
    image_id?: SortOrder
    platform_ids?: SortOrder
    provider_key_ids?: SortOrder
  }

  export type providersMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    key?: SortOrder
    name?: SortOrder
    image_id?: SortOrder
  }

  export type providersMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    key?: SortOrder
    name?: SortOrder
    image_id?: SortOrder
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type ProvidersRelationFilter = {
    is?: providersWhereInput
    isNot?: providersWhereInput
  }

  export type provider_keysCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    public_key?: SortOrder
    private_key?: SortOrder
    secret?: SortOrder
    description?: SortOrder
    provider_id?: SortOrder
    platform_ids?: SortOrder
  }

  export type provider_keysMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    public_key?: SortOrder
    private_key?: SortOrder
    secret?: SortOrder
    description?: SortOrder
    provider_id?: SortOrder
  }

  export type provider_keysMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    public_key?: SortOrder
    private_key?: SortOrder
    secret?: SortOrder
    description?: SortOrder
    provider_id?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type EnumGenderTypeNullableFilter = {
    equals?: GenderType | null
    in?: Enumerable<GenderType> | null
    notIn?: Enumerable<GenderType> | null
    not?: NestedEnumGenderTypeNullableFilter | GenderType | null
    isSet?: boolean
  }

  export type LocationsRelationFilter = {
    is?: locationsWhereInput | null
    isNot?: locationsWhereInput | null
  }

  export type LocationsListRelationFilter = {
    every?: locationsWhereInput
    some?: locationsWhereInput
    none?: locationsWhereInput
  }

  export type StoresListRelationFilter = {
    every?: storesWhereInput
    some?: storesWhereInput
    none?: storesWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: paymentWhereInput
    some?: paymentWhereInput
    none?: paymentWhereInput
  }

  export type SessionsListRelationFilter = {
    every?: sessionsWhereInput
    some?: sessionsWhereInput
    none?: sessionsWhereInput
  }

  export type locationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type storesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type paymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sessionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    username?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    image_id?: SortOrder
    prefered_location_id?: SortOrder
    location_ids?: SortOrder
    platform_ids?: SortOrder
    organization_ids?: SortOrder
    store_ids?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    username?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    image_id?: SortOrder
    prefered_location_id?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    username?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    image_id?: SortOrder
    prefered_location_id?: SortOrder
  }

  export type EnumGenderTypeNullableWithAggregatesFilter = {
    equals?: GenderType | null
    in?: Enumerable<GenderType> | null
    notIn?: Enumerable<GenderType> | null
    not?: NestedEnumGenderTypeNullableWithAggregatesFilter | GenderType | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumGenderTypeNullableFilter
    _max?: NestedEnumGenderTypeNullableFilter
    isSet?: boolean
  }

  export type organizationsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    username?: SortOrder
    name?: SortOrder
    image_id?: SortOrder
    platform_ids?: SortOrder
    user_ids?: SortOrder
    location_ids?: SortOrder
  }

  export type organizationsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    username?: SortOrder
    name?: SortOrder
    image_id?: SortOrder
  }

  export type organizationsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    username?: SortOrder
    name?: SortOrder
    image_id?: SortOrder
  }

  export type InventoriesListRelationFilter = {
    every?: inventoriesWhereInput
    some?: inventoriesWhereInput
    none?: inventoriesWhereInput
  }

  export type inventoriesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type storesCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    username?: SortOrder
    name?: SortOrder
    image_id?: SortOrder
    user_ids?: SortOrder
    location_ids?: SortOrder
    inventory_ids?: SortOrder
  }

  export type storesMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    username?: SortOrder
    name?: SortOrder
    image_id?: SortOrder
  }

  export type storesMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    username?: SortOrder
    name?: SortOrder
    image_id?: SortOrder
  }

  export type Item_inventoriesListRelationFilter = {
    every?: item_inventoriesWhereInput
    some?: item_inventoriesWhereInput
    none?: item_inventoriesWhereInput
  }

  export type item_inventoriesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type inventoriesCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    item_iventory_ids?: SortOrder
    store_ids?: SortOrder
  }

  export type inventoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type inventoriesMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type EnumItemQualitativeTypeFilter = {
    equals?: ItemQualitativeType
    in?: Enumerable<ItemQualitativeType>
    notIn?: Enumerable<ItemQualitativeType>
    not?: NestedEnumItemQualitativeTypeFilter | ItemQualitativeType
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type ItemsRelationFilter = {
    is?: itemsWhereInput
    isNot?: itemsWhereInput
  }

  export type item_inventoriesCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    item_id?: SortOrder
    type?: SortOrder
    value?: SortOrder
    iventory_ids?: SortOrder
  }

  export type item_inventoriesAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type item_inventoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    item_id?: SortOrder
    type?: SortOrder
    value?: SortOrder
  }

  export type item_inventoriesMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    item_id?: SortOrder
    type?: SortOrder
    value?: SortOrder
  }

  export type item_inventoriesSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type EnumItemQualitativeTypeWithAggregatesFilter = {
    equals?: ItemQualitativeType
    in?: Enumerable<ItemQualitativeType>
    notIn?: Enumerable<ItemQualitativeType>
    not?: NestedEnumItemQualitativeTypeWithAggregatesFilter | ItemQualitativeType
    _count?: NestedIntFilter
    _min?: NestedEnumItemQualitativeTypeFilter
    _max?: NestedEnumItemQualitativeTypeFilter
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type Item_ordersListRelationFilter = {
    every?: item_ordersWhereInput
    some?: item_ordersWhereInput
    none?: item_ordersWhereInput
  }

  export type item_ordersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type odersCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    total?: SortOrder
    item_order_ids?: SortOrder
  }

  export type odersAvgOrderByAggregateInput = {
    total?: SortOrder
  }

  export type odersMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    total?: SortOrder
  }

  export type odersMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    total?: SortOrder
  }

  export type odersSumOrderByAggregateInput = {
    total?: SortOrder
  }

  export type OdersListRelationFilter = {
    every?: odersWhereInput
    some?: odersWhereInput
    none?: odersWhereInput
  }

  export type odersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type item_ordersCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    item_id?: SortOrder
    type?: SortOrder
    value?: SortOrder
    order_ids?: SortOrder
  }

  export type item_ordersAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type item_ordersMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    item_id?: SortOrder
    type?: SortOrder
    value?: SortOrder
  }

  export type item_ordersMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    item_id?: SortOrder
    type?: SortOrder
    value?: SortOrder
  }

  export type item_ordersSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type PaymentTypeCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type PaymentTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type PaymentTypeMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type CurrencyCompositeFilter = {
    equals?: CurrencyObjectEqualityInput
    is?: CurrencyWhereInput
    isNot?: CurrencyWhereInput
  }

  export type CurrencyObjectEqualityInput = {
    amount: number
    currency: CurrencyType
  }

  export type PaymentTypeRelationFilter = {
    is?: PaymentTypeWhereInput
    isNot?: PaymentTypeWhereInput
  }

  export type UsersRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type PaymentAccountRelationFilter = {
    is?: PaymentAccountWhereInput
    isNot?: PaymentAccountWhereInput
  }

  export type CurrencyOrderByInput = {
    amount?: SortOrder
    currency?: SortOrder
  }

  export type paymentCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    title?: SortOrder
    description?: SortOrder
    payment_type_id?: SortOrder
    user_creator_id?: SortOrder
    user_confirm_id?: SortOrder
    receiver_account_id?: SortOrder
    sender_account_id?: SortOrder
  }

  export type paymentMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    title?: SortOrder
    description?: SortOrder
    payment_type_id?: SortOrder
    user_creator_id?: SortOrder
    user_confirm_id?: SortOrder
    receiver_account_id?: SortOrder
    sender_account_id?: SortOrder
  }

  export type paymentMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    title?: SortOrder
    description?: SortOrder
    payment_type_id?: SortOrder
    user_creator_id?: SortOrder
    user_confirm_id?: SortOrder
    receiver_account_id?: SortOrder
    sender_account_id?: SortOrder
  }

  export type PaymentAccountCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
  }

  export type PaymentAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
  }

  export type PaymentAccountMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
  }

  export type CurrencyCompositeListFilter = {
    equals?: Enumerable<CurrencyObjectEqualityInput>
    every?: CurrencyWhereInput
    some?: CurrencyWhereInput
    none?: CurrencyWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type ImagesListRelationFilter = {
    every?: imagesWhereInput
    some?: imagesWhereInput
    none?: imagesWhereInput
  }

  export type CurrencyOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type imagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type itemsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    image_ids?: SortOrder
  }

  export type itemsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type itemsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
    isSet?: boolean
  }

  export type locationsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    user_ids?: SortOrder
    organizations_ids?: SortOrder
    store_ids?: SortOrder
  }

  export type locationsAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type locationsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type locationsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type locationsSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
    isSet?: boolean
  }

  export type sessionsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    jwt?: SortOrder
    user_uuid?: SortOrder
    user_id?: SortOrder
  }

  export type sessionsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    jwt?: SortOrder
    user_uuid?: SortOrder
    user_id?: SortOrder
  }

  export type sessionsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    jwt?: SortOrder
    user_uuid?: SortOrder
    user_id?: SortOrder
  }

  export type ItemsListRelationFilter = {
    every?: itemsWhereInput
    some?: itemsWhereInput
    none?: itemsWhereInput
  }

  export type itemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type imagesCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    key?: SortOrder
    url?: SortOrder
    clipped_key?: SortOrder
    clipped_url?: SortOrder
    item_ids?: SortOrder
  }

  export type imagesMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    key?: SortOrder
    url?: SortOrder
    clipped_key?: SortOrder
    clipped_url?: SortOrder
  }

  export type imagesMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
    key?: SortOrder
    url?: SortOrder
    clipped_key?: SortOrder
    clipped_url?: SortOrder
  }

  export type ClauTestCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
  }

  export type ClauTestMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
  }

  export type ClauTestMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uuid?: SortOrder
  }

  export type imagesCreateNestedOneWithoutPlatformsInput = {
    create?: XOR<imagesCreateWithoutPlatformsInput, imagesUncheckedCreateWithoutPlatformsInput>
    connectOrCreate?: imagesCreateOrConnectWithoutPlatformsInput
    connect?: imagesWhereUniqueInput
  }

  export type providersCreateNestedManyWithoutPlatformsInput = {
    create?: XOR<Enumerable<providersCreateWithoutPlatformsInput>, Enumerable<providersUncheckedCreateWithoutPlatformsInput>>
    connectOrCreate?: Enumerable<providersCreateOrConnectWithoutPlatformsInput>
    connect?: Enumerable<providersWhereUniqueInput>
  }

  export type provider_keysCreateNestedManyWithoutPlatformsInput = {
    create?: XOR<Enumerable<provider_keysCreateWithoutPlatformsInput>, Enumerable<provider_keysUncheckedCreateWithoutPlatformsInput>>
    connectOrCreate?: Enumerable<provider_keysCreateOrConnectWithoutPlatformsInput>
    connect?: Enumerable<provider_keysWhereUniqueInput>
  }

  export type usersCreateNestedManyWithoutPlatformsInput = {
    create?: XOR<Enumerable<usersCreateWithoutPlatformsInput>, Enumerable<usersUncheckedCreateWithoutPlatformsInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutPlatformsInput>
    connect?: Enumerable<usersWhereUniqueInput>
  }

  export type organizationsCreateNestedManyWithoutPlatformsInput = {
    create?: XOR<Enumerable<organizationsCreateWithoutPlatformsInput>, Enumerable<organizationsUncheckedCreateWithoutPlatformsInput>>
    connectOrCreate?: Enumerable<organizationsCreateOrConnectWithoutPlatformsInput>
    connect?: Enumerable<organizationsWhereUniqueInput>
  }

  export type platformsCreateprovider_idsInput = {
    set: Enumerable<string>
  }

  export type platformsCreateprovider_key_idsInput = {
    set: Enumerable<string>
  }

  export type platformsCreateuser_idsInput = {
    set: Enumerable<string>
  }

  export type platformsCreateorganization_idsInput = {
    set: Enumerable<string>
  }

  export type providersUncheckedCreateNestedManyWithoutPlatformsInput = {
    create?: XOR<Enumerable<providersCreateWithoutPlatformsInput>, Enumerable<providersUncheckedCreateWithoutPlatformsInput>>
    connectOrCreate?: Enumerable<providersCreateOrConnectWithoutPlatformsInput>
    connect?: Enumerable<providersWhereUniqueInput>
  }

  export type provider_keysUncheckedCreateNestedManyWithoutPlatformsInput = {
    create?: XOR<Enumerable<provider_keysCreateWithoutPlatformsInput>, Enumerable<provider_keysUncheckedCreateWithoutPlatformsInput>>
    connectOrCreate?: Enumerable<provider_keysCreateOrConnectWithoutPlatformsInput>
    connect?: Enumerable<provider_keysWhereUniqueInput>
  }

  export type usersUncheckedCreateNestedManyWithoutPlatformsInput = {
    create?: XOR<Enumerable<usersCreateWithoutPlatformsInput>, Enumerable<usersUncheckedCreateWithoutPlatformsInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutPlatformsInput>
    connect?: Enumerable<usersWhereUniqueInput>
  }

  export type organizationsUncheckedCreateNestedManyWithoutPlatformsInput = {
    create?: XOR<Enumerable<organizationsCreateWithoutPlatformsInput>, Enumerable<organizationsUncheckedCreateWithoutPlatformsInput>>
    connectOrCreate?: Enumerable<organizationsCreateOrConnectWithoutPlatformsInput>
    connect?: Enumerable<organizationsWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type imagesUpdateOneWithoutPlatformsNestedInput = {
    create?: XOR<imagesCreateWithoutPlatformsInput, imagesUncheckedCreateWithoutPlatformsInput>
    connectOrCreate?: imagesCreateOrConnectWithoutPlatformsInput
    upsert?: imagesUpsertWithoutPlatformsInput
    disconnect?: boolean
    delete?: boolean
    connect?: imagesWhereUniqueInput
    update?: XOR<imagesUpdateWithoutPlatformsInput, imagesUncheckedUpdateWithoutPlatformsInput>
  }

  export type providersUpdateManyWithoutPlatformsNestedInput = {
    create?: XOR<Enumerable<providersCreateWithoutPlatformsInput>, Enumerable<providersUncheckedCreateWithoutPlatformsInput>>
    connectOrCreate?: Enumerable<providersCreateOrConnectWithoutPlatformsInput>
    upsert?: Enumerable<providersUpsertWithWhereUniqueWithoutPlatformsInput>
    set?: Enumerable<providersWhereUniqueInput>
    disconnect?: Enumerable<providersWhereUniqueInput>
    delete?: Enumerable<providersWhereUniqueInput>
    connect?: Enumerable<providersWhereUniqueInput>
    update?: Enumerable<providersUpdateWithWhereUniqueWithoutPlatformsInput>
    updateMany?: Enumerable<providersUpdateManyWithWhereWithoutPlatformsInput>
    deleteMany?: Enumerable<providersScalarWhereInput>
  }

  export type provider_keysUpdateManyWithoutPlatformsNestedInput = {
    create?: XOR<Enumerable<provider_keysCreateWithoutPlatformsInput>, Enumerable<provider_keysUncheckedCreateWithoutPlatformsInput>>
    connectOrCreate?: Enumerable<provider_keysCreateOrConnectWithoutPlatformsInput>
    upsert?: Enumerable<provider_keysUpsertWithWhereUniqueWithoutPlatformsInput>
    set?: Enumerable<provider_keysWhereUniqueInput>
    disconnect?: Enumerable<provider_keysWhereUniqueInput>
    delete?: Enumerable<provider_keysWhereUniqueInput>
    connect?: Enumerable<provider_keysWhereUniqueInput>
    update?: Enumerable<provider_keysUpdateWithWhereUniqueWithoutPlatformsInput>
    updateMany?: Enumerable<provider_keysUpdateManyWithWhereWithoutPlatformsInput>
    deleteMany?: Enumerable<provider_keysScalarWhereInput>
  }

  export type usersUpdateManyWithoutPlatformsNestedInput = {
    create?: XOR<Enumerable<usersCreateWithoutPlatformsInput>, Enumerable<usersUncheckedCreateWithoutPlatformsInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutPlatformsInput>
    upsert?: Enumerable<usersUpsertWithWhereUniqueWithoutPlatformsInput>
    set?: Enumerable<usersWhereUniqueInput>
    disconnect?: Enumerable<usersWhereUniqueInput>
    delete?: Enumerable<usersWhereUniqueInput>
    connect?: Enumerable<usersWhereUniqueInput>
    update?: Enumerable<usersUpdateWithWhereUniqueWithoutPlatformsInput>
    updateMany?: Enumerable<usersUpdateManyWithWhereWithoutPlatformsInput>
    deleteMany?: Enumerable<usersScalarWhereInput>
  }

  export type organizationsUpdateManyWithoutPlatformsNestedInput = {
    create?: XOR<Enumerable<organizationsCreateWithoutPlatformsInput>, Enumerable<organizationsUncheckedCreateWithoutPlatformsInput>>
    connectOrCreate?: Enumerable<organizationsCreateOrConnectWithoutPlatformsInput>
    upsert?: Enumerable<organizationsUpsertWithWhereUniqueWithoutPlatformsInput>
    set?: Enumerable<organizationsWhereUniqueInput>
    disconnect?: Enumerable<organizationsWhereUniqueInput>
    delete?: Enumerable<organizationsWhereUniqueInput>
    connect?: Enumerable<organizationsWhereUniqueInput>
    update?: Enumerable<organizationsUpdateWithWhereUniqueWithoutPlatformsInput>
    updateMany?: Enumerable<organizationsUpdateManyWithWhereWithoutPlatformsInput>
    deleteMany?: Enumerable<organizationsScalarWhereInput>
  }

  export type platformsUpdateprovider_idsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type platformsUpdateprovider_key_idsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type platformsUpdateuser_idsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type platformsUpdateorganization_idsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type providersUncheckedUpdateManyWithoutPlatformsNestedInput = {
    create?: XOR<Enumerable<providersCreateWithoutPlatformsInput>, Enumerable<providersUncheckedCreateWithoutPlatformsInput>>
    connectOrCreate?: Enumerable<providersCreateOrConnectWithoutPlatformsInput>
    upsert?: Enumerable<providersUpsertWithWhereUniqueWithoutPlatformsInput>
    set?: Enumerable<providersWhereUniqueInput>
    disconnect?: Enumerable<providersWhereUniqueInput>
    delete?: Enumerable<providersWhereUniqueInput>
    connect?: Enumerable<providersWhereUniqueInput>
    update?: Enumerable<providersUpdateWithWhereUniqueWithoutPlatformsInput>
    updateMany?: Enumerable<providersUpdateManyWithWhereWithoutPlatformsInput>
    deleteMany?: Enumerable<providersScalarWhereInput>
  }

  export type provider_keysUncheckedUpdateManyWithoutPlatformsNestedInput = {
    create?: XOR<Enumerable<provider_keysCreateWithoutPlatformsInput>, Enumerable<provider_keysUncheckedCreateWithoutPlatformsInput>>
    connectOrCreate?: Enumerable<provider_keysCreateOrConnectWithoutPlatformsInput>
    upsert?: Enumerable<provider_keysUpsertWithWhereUniqueWithoutPlatformsInput>
    set?: Enumerable<provider_keysWhereUniqueInput>
    disconnect?: Enumerable<provider_keysWhereUniqueInput>
    delete?: Enumerable<provider_keysWhereUniqueInput>
    connect?: Enumerable<provider_keysWhereUniqueInput>
    update?: Enumerable<provider_keysUpdateWithWhereUniqueWithoutPlatformsInput>
    updateMany?: Enumerable<provider_keysUpdateManyWithWhereWithoutPlatformsInput>
    deleteMany?: Enumerable<provider_keysScalarWhereInput>
  }

  export type usersUncheckedUpdateManyWithoutPlatformsNestedInput = {
    create?: XOR<Enumerable<usersCreateWithoutPlatformsInput>, Enumerable<usersUncheckedCreateWithoutPlatformsInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutPlatformsInput>
    upsert?: Enumerable<usersUpsertWithWhereUniqueWithoutPlatformsInput>
    set?: Enumerable<usersWhereUniqueInput>
    disconnect?: Enumerable<usersWhereUniqueInput>
    delete?: Enumerable<usersWhereUniqueInput>
    connect?: Enumerable<usersWhereUniqueInput>
    update?: Enumerable<usersUpdateWithWhereUniqueWithoutPlatformsInput>
    updateMany?: Enumerable<usersUpdateManyWithWhereWithoutPlatformsInput>
    deleteMany?: Enumerable<usersScalarWhereInput>
  }

  export type organizationsUncheckedUpdateManyWithoutPlatformsNestedInput = {
    create?: XOR<Enumerable<organizationsCreateWithoutPlatformsInput>, Enumerable<organizationsUncheckedCreateWithoutPlatformsInput>>
    connectOrCreate?: Enumerable<organizationsCreateOrConnectWithoutPlatformsInput>
    upsert?: Enumerable<organizationsUpsertWithWhereUniqueWithoutPlatformsInput>
    set?: Enumerable<organizationsWhereUniqueInput>
    disconnect?: Enumerable<organizationsWhereUniqueInput>
    delete?: Enumerable<organizationsWhereUniqueInput>
    connect?: Enumerable<organizationsWhereUniqueInput>
    update?: Enumerable<organizationsUpdateWithWhereUniqueWithoutPlatformsInput>
    updateMany?: Enumerable<organizationsUpdateManyWithWhereWithoutPlatformsInput>
    deleteMany?: Enumerable<organizationsScalarWhereInput>
  }

  export type providersCreateprovider_key_idsInput = {
    set: Enumerable<string>
  }

  export type imagesCreateNestedOneWithoutProvidersInput = {
    create?: XOR<imagesCreateWithoutProvidersInput, imagesUncheckedCreateWithoutProvidersInput>
    connectOrCreate?: imagesCreateOrConnectWithoutProvidersInput
    connect?: imagesWhereUniqueInput
  }

  export type platformsCreateNestedManyWithoutProvidersInput = {
    create?: XOR<Enumerable<platformsCreateWithoutProvidersInput>, Enumerable<platformsUncheckedCreateWithoutProvidersInput>>
    connectOrCreate?: Enumerable<platformsCreateOrConnectWithoutProvidersInput>
    connect?: Enumerable<platformsWhereUniqueInput>
  }

  export type provider_keysCreateNestedManyWithoutProviderInput = {
    create?: XOR<Enumerable<provider_keysCreateWithoutProviderInput>, Enumerable<provider_keysUncheckedCreateWithoutProviderInput>>
    connectOrCreate?: Enumerable<provider_keysCreateOrConnectWithoutProviderInput>
    createMany?: provider_keysCreateManyProviderInputEnvelope
    connect?: Enumerable<provider_keysWhereUniqueInput>
  }

  export type providersCreateplatform_idsInput = {
    set: Enumerable<string>
  }

  export type platformsUncheckedCreateNestedManyWithoutProvidersInput = {
    create?: XOR<Enumerable<platformsCreateWithoutProvidersInput>, Enumerable<platformsUncheckedCreateWithoutProvidersInput>>
    connectOrCreate?: Enumerable<platformsCreateOrConnectWithoutProvidersInput>
    connect?: Enumerable<platformsWhereUniqueInput>
  }

  export type provider_keysUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<Enumerable<provider_keysCreateWithoutProviderInput>, Enumerable<provider_keysUncheckedCreateWithoutProviderInput>>
    connectOrCreate?: Enumerable<provider_keysCreateOrConnectWithoutProviderInput>
    createMany?: provider_keysCreateManyProviderInputEnvelope
    connect?: Enumerable<provider_keysWhereUniqueInput>
  }

  export type providersUpdateprovider_key_idsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type imagesUpdateOneWithoutProvidersNestedInput = {
    create?: XOR<imagesCreateWithoutProvidersInput, imagesUncheckedCreateWithoutProvidersInput>
    connectOrCreate?: imagesCreateOrConnectWithoutProvidersInput
    upsert?: imagesUpsertWithoutProvidersInput
    disconnect?: boolean
    delete?: boolean
    connect?: imagesWhereUniqueInput
    update?: XOR<imagesUpdateWithoutProvidersInput, imagesUncheckedUpdateWithoutProvidersInput>
  }

  export type platformsUpdateManyWithoutProvidersNestedInput = {
    create?: XOR<Enumerable<platformsCreateWithoutProvidersInput>, Enumerable<platformsUncheckedCreateWithoutProvidersInput>>
    connectOrCreate?: Enumerable<platformsCreateOrConnectWithoutProvidersInput>
    upsert?: Enumerable<platformsUpsertWithWhereUniqueWithoutProvidersInput>
    set?: Enumerable<platformsWhereUniqueInput>
    disconnect?: Enumerable<platformsWhereUniqueInput>
    delete?: Enumerable<platformsWhereUniqueInput>
    connect?: Enumerable<platformsWhereUniqueInput>
    update?: Enumerable<platformsUpdateWithWhereUniqueWithoutProvidersInput>
    updateMany?: Enumerable<platformsUpdateManyWithWhereWithoutProvidersInput>
    deleteMany?: Enumerable<platformsScalarWhereInput>
  }

  export type provider_keysUpdateManyWithoutProviderNestedInput = {
    create?: XOR<Enumerable<provider_keysCreateWithoutProviderInput>, Enumerable<provider_keysUncheckedCreateWithoutProviderInput>>
    connectOrCreate?: Enumerable<provider_keysCreateOrConnectWithoutProviderInput>
    upsert?: Enumerable<provider_keysUpsertWithWhereUniqueWithoutProviderInput>
    createMany?: provider_keysCreateManyProviderInputEnvelope
    set?: Enumerable<provider_keysWhereUniqueInput>
    disconnect?: Enumerable<provider_keysWhereUniqueInput>
    delete?: Enumerable<provider_keysWhereUniqueInput>
    connect?: Enumerable<provider_keysWhereUniqueInput>
    update?: Enumerable<provider_keysUpdateWithWhereUniqueWithoutProviderInput>
    updateMany?: Enumerable<provider_keysUpdateManyWithWhereWithoutProviderInput>
    deleteMany?: Enumerable<provider_keysScalarWhereInput>
  }

  export type providersUpdateplatform_idsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type platformsUncheckedUpdateManyWithoutProvidersNestedInput = {
    create?: XOR<Enumerable<platformsCreateWithoutProvidersInput>, Enumerable<platformsUncheckedCreateWithoutProvidersInput>>
    connectOrCreate?: Enumerable<platformsCreateOrConnectWithoutProvidersInput>
    upsert?: Enumerable<platformsUpsertWithWhereUniqueWithoutProvidersInput>
    set?: Enumerable<platformsWhereUniqueInput>
    disconnect?: Enumerable<platformsWhereUniqueInput>
    delete?: Enumerable<platformsWhereUniqueInput>
    connect?: Enumerable<platformsWhereUniqueInput>
    update?: Enumerable<platformsUpdateWithWhereUniqueWithoutProvidersInput>
    updateMany?: Enumerable<platformsUpdateManyWithWhereWithoutProvidersInput>
    deleteMany?: Enumerable<platformsScalarWhereInput>
  }

  export type provider_keysUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<Enumerable<provider_keysCreateWithoutProviderInput>, Enumerable<provider_keysUncheckedCreateWithoutProviderInput>>
    connectOrCreate?: Enumerable<provider_keysCreateOrConnectWithoutProviderInput>
    upsert?: Enumerable<provider_keysUpsertWithWhereUniqueWithoutProviderInput>
    createMany?: provider_keysCreateManyProviderInputEnvelope
    set?: Enumerable<provider_keysWhereUniqueInput>
    disconnect?: Enumerable<provider_keysWhereUniqueInput>
    delete?: Enumerable<provider_keysWhereUniqueInput>
    connect?: Enumerable<provider_keysWhereUniqueInput>
    update?: Enumerable<provider_keysUpdateWithWhereUniqueWithoutProviderInput>
    updateMany?: Enumerable<provider_keysUpdateManyWithWhereWithoutProviderInput>
    deleteMany?: Enumerable<provider_keysScalarWhereInput>
  }

  export type providersCreateNestedOneWithoutProvider_keysInput = {
    create?: XOR<providersCreateWithoutProvider_keysInput, providersUncheckedCreateWithoutProvider_keysInput>
    connectOrCreate?: providersCreateOrConnectWithoutProvider_keysInput
    connect?: providersWhereUniqueInput
  }

  export type platformsCreateNestedManyWithoutProvider_keysInput = {
    create?: XOR<Enumerable<platformsCreateWithoutProvider_keysInput>, Enumerable<platformsUncheckedCreateWithoutProvider_keysInput>>
    connectOrCreate?: Enumerable<platformsCreateOrConnectWithoutProvider_keysInput>
    connect?: Enumerable<platformsWhereUniqueInput>
  }

  export type provider_keysCreateplatform_idsInput = {
    set: Enumerable<string>
  }

  export type platformsUncheckedCreateNestedManyWithoutProvider_keysInput = {
    create?: XOR<Enumerable<platformsCreateWithoutProvider_keysInput>, Enumerable<platformsUncheckedCreateWithoutProvider_keysInput>>
    connectOrCreate?: Enumerable<platformsCreateOrConnectWithoutProvider_keysInput>
    connect?: Enumerable<platformsWhereUniqueInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type providersUpdateOneRequiredWithoutProvider_keysNestedInput = {
    create?: XOR<providersCreateWithoutProvider_keysInput, providersUncheckedCreateWithoutProvider_keysInput>
    connectOrCreate?: providersCreateOrConnectWithoutProvider_keysInput
    upsert?: providersUpsertWithoutProvider_keysInput
    connect?: providersWhereUniqueInput
    update?: XOR<providersUpdateWithoutProvider_keysInput, providersUncheckedUpdateWithoutProvider_keysInput>
  }

  export type platformsUpdateManyWithoutProvider_keysNestedInput = {
    create?: XOR<Enumerable<platformsCreateWithoutProvider_keysInput>, Enumerable<platformsUncheckedCreateWithoutProvider_keysInput>>
    connectOrCreate?: Enumerable<platformsCreateOrConnectWithoutProvider_keysInput>
    upsert?: Enumerable<platformsUpsertWithWhereUniqueWithoutProvider_keysInput>
    set?: Enumerable<platformsWhereUniqueInput>
    disconnect?: Enumerable<platformsWhereUniqueInput>
    delete?: Enumerable<platformsWhereUniqueInput>
    connect?: Enumerable<platformsWhereUniqueInput>
    update?: Enumerable<platformsUpdateWithWhereUniqueWithoutProvider_keysInput>
    updateMany?: Enumerable<platformsUpdateManyWithWhereWithoutProvider_keysInput>
    deleteMany?: Enumerable<platformsScalarWhereInput>
  }

  export type provider_keysUpdateplatform_idsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type platformsUncheckedUpdateManyWithoutProvider_keysNestedInput = {
    create?: XOR<Enumerable<platformsCreateWithoutProvider_keysInput>, Enumerable<platformsUncheckedCreateWithoutProvider_keysInput>>
    connectOrCreate?: Enumerable<platformsCreateOrConnectWithoutProvider_keysInput>
    upsert?: Enumerable<platformsUpsertWithWhereUniqueWithoutProvider_keysInput>
    set?: Enumerable<platformsWhereUniqueInput>
    disconnect?: Enumerable<platformsWhereUniqueInput>
    delete?: Enumerable<platformsWhereUniqueInput>
    connect?: Enumerable<platformsWhereUniqueInput>
    update?: Enumerable<platformsUpdateWithWhereUniqueWithoutProvider_keysInput>
    updateMany?: Enumerable<platformsUpdateManyWithWhereWithoutProvider_keysInput>
    deleteMany?: Enumerable<platformsScalarWhereInput>
  }

  export type imagesCreateNestedOneWithoutUsersInput = {
    create?: XOR<imagesCreateWithoutUsersInput, imagesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: imagesCreateOrConnectWithoutUsersInput
    connect?: imagesWhereUniqueInput
  }

  export type locationsCreateNestedOneWithoutUsers_preferedInput = {
    create?: XOR<locationsCreateWithoutUsers_preferedInput, locationsUncheckedCreateWithoutUsers_preferedInput>
    connectOrCreate?: locationsCreateOrConnectWithoutUsers_preferedInput
    connect?: locationsWhereUniqueInput
  }

  export type locationsCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<locationsCreateWithoutUsersInput>, Enumerable<locationsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<locationsCreateOrConnectWithoutUsersInput>
    connect?: Enumerable<locationsWhereUniqueInput>
  }

  export type platformsCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<platformsCreateWithoutUsersInput>, Enumerable<platformsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<platformsCreateOrConnectWithoutUsersInput>
    connect?: Enumerable<platformsWhereUniqueInput>
  }

  export type organizationsCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<organizationsCreateWithoutUsersInput>, Enumerable<organizationsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<organizationsCreateOrConnectWithoutUsersInput>
    connect?: Enumerable<organizationsWhereUniqueInput>
  }

  export type storesCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<storesCreateWithoutUsersInput>, Enumerable<storesUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<storesCreateOrConnectWithoutUsersInput>
    connect?: Enumerable<storesWhereUniqueInput>
  }

  export type paymentCreateNestedManyWithoutUser_creatorInput = {
    create?: XOR<Enumerable<paymentCreateWithoutUser_creatorInput>, Enumerable<paymentUncheckedCreateWithoutUser_creatorInput>>
    connectOrCreate?: Enumerable<paymentCreateOrConnectWithoutUser_creatorInput>
    createMany?: paymentCreateManyUser_creatorInputEnvelope
    connect?: Enumerable<paymentWhereUniqueInput>
  }

  export type paymentCreateNestedManyWithoutUser_confirmInput = {
    create?: XOR<Enumerable<paymentCreateWithoutUser_confirmInput>, Enumerable<paymentUncheckedCreateWithoutUser_confirmInput>>
    connectOrCreate?: Enumerable<paymentCreateOrConnectWithoutUser_confirmInput>
    createMany?: paymentCreateManyUser_confirmInputEnvelope
    connect?: Enumerable<paymentWhereUniqueInput>
  }

  export type sessionsCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<sessionsCreateWithoutUserInput>, Enumerable<sessionsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<sessionsCreateOrConnectWithoutUserInput>
    createMany?: sessionsCreateManyUserInputEnvelope
    connect?: Enumerable<sessionsWhereUniqueInput>
  }

  export type usersCreatelocation_idsInput = {
    set: Enumerable<string>
  }

  export type usersCreateplatform_idsInput = {
    set: Enumerable<string>
  }

  export type usersCreateorganization_idsInput = {
    set: Enumerable<string>
  }

  export type usersCreatestore_idsInput = {
    set: Enumerable<string>
  }

  export type locationsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<locationsCreateWithoutUsersInput>, Enumerable<locationsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<locationsCreateOrConnectWithoutUsersInput>
    connect?: Enumerable<locationsWhereUniqueInput>
  }

  export type platformsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<platformsCreateWithoutUsersInput>, Enumerable<platformsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<platformsCreateOrConnectWithoutUsersInput>
    connect?: Enumerable<platformsWhereUniqueInput>
  }

  export type organizationsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<organizationsCreateWithoutUsersInput>, Enumerable<organizationsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<organizationsCreateOrConnectWithoutUsersInput>
    connect?: Enumerable<organizationsWhereUniqueInput>
  }

  export type storesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<storesCreateWithoutUsersInput>, Enumerable<storesUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<storesCreateOrConnectWithoutUsersInput>
    connect?: Enumerable<storesWhereUniqueInput>
  }

  export type paymentUncheckedCreateNestedManyWithoutUser_creatorInput = {
    create?: XOR<Enumerable<paymentCreateWithoutUser_creatorInput>, Enumerable<paymentUncheckedCreateWithoutUser_creatorInput>>
    connectOrCreate?: Enumerable<paymentCreateOrConnectWithoutUser_creatorInput>
    createMany?: paymentCreateManyUser_creatorInputEnvelope
    connect?: Enumerable<paymentWhereUniqueInput>
  }

  export type paymentUncheckedCreateNestedManyWithoutUser_confirmInput = {
    create?: XOR<Enumerable<paymentCreateWithoutUser_confirmInput>, Enumerable<paymentUncheckedCreateWithoutUser_confirmInput>>
    connectOrCreate?: Enumerable<paymentCreateOrConnectWithoutUser_confirmInput>
    createMany?: paymentCreateManyUser_confirmInputEnvelope
    connect?: Enumerable<paymentWhereUniqueInput>
  }

  export type sessionsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<sessionsCreateWithoutUserInput>, Enumerable<sessionsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<sessionsCreateOrConnectWithoutUserInput>
    createMany?: sessionsCreateManyUserInputEnvelope
    connect?: Enumerable<sessionsWhereUniqueInput>
  }

  export type NullableEnumGenderTypeFieldUpdateOperationsInput = {
    set?: GenderType | null
    unset?: boolean
  }

  export type imagesUpdateOneWithoutUsersNestedInput = {
    create?: XOR<imagesCreateWithoutUsersInput, imagesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: imagesCreateOrConnectWithoutUsersInput
    upsert?: imagesUpsertWithoutUsersInput
    disconnect?: boolean
    delete?: boolean
    connect?: imagesWhereUniqueInput
    update?: XOR<imagesUpdateWithoutUsersInput, imagesUncheckedUpdateWithoutUsersInput>
  }

  export type locationsUpdateOneWithoutUsers_preferedNestedInput = {
    create?: XOR<locationsCreateWithoutUsers_preferedInput, locationsUncheckedCreateWithoutUsers_preferedInput>
    connectOrCreate?: locationsCreateOrConnectWithoutUsers_preferedInput
    upsert?: locationsUpsertWithoutUsers_preferedInput
    disconnect?: boolean
    delete?: boolean
    connect?: locationsWhereUniqueInput
    update?: XOR<locationsUpdateWithoutUsers_preferedInput, locationsUncheckedUpdateWithoutUsers_preferedInput>
  }

  export type locationsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<locationsCreateWithoutUsersInput>, Enumerable<locationsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<locationsCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<locationsUpsertWithWhereUniqueWithoutUsersInput>
    set?: Enumerable<locationsWhereUniqueInput>
    disconnect?: Enumerable<locationsWhereUniqueInput>
    delete?: Enumerable<locationsWhereUniqueInput>
    connect?: Enumerable<locationsWhereUniqueInput>
    update?: Enumerable<locationsUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<locationsUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<locationsScalarWhereInput>
  }

  export type platformsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<platformsCreateWithoutUsersInput>, Enumerable<platformsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<platformsCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<platformsUpsertWithWhereUniqueWithoutUsersInput>
    set?: Enumerable<platformsWhereUniqueInput>
    disconnect?: Enumerable<platformsWhereUniqueInput>
    delete?: Enumerable<platformsWhereUniqueInput>
    connect?: Enumerable<platformsWhereUniqueInput>
    update?: Enumerable<platformsUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<platformsUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<platformsScalarWhereInput>
  }

  export type organizationsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<organizationsCreateWithoutUsersInput>, Enumerable<organizationsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<organizationsCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<organizationsUpsertWithWhereUniqueWithoutUsersInput>
    set?: Enumerable<organizationsWhereUniqueInput>
    disconnect?: Enumerable<organizationsWhereUniqueInput>
    delete?: Enumerable<organizationsWhereUniqueInput>
    connect?: Enumerable<organizationsWhereUniqueInput>
    update?: Enumerable<organizationsUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<organizationsUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<organizationsScalarWhereInput>
  }

  export type storesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<storesCreateWithoutUsersInput>, Enumerable<storesUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<storesCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<storesUpsertWithWhereUniqueWithoutUsersInput>
    set?: Enumerable<storesWhereUniqueInput>
    disconnect?: Enumerable<storesWhereUniqueInput>
    delete?: Enumerable<storesWhereUniqueInput>
    connect?: Enumerable<storesWhereUniqueInput>
    update?: Enumerable<storesUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<storesUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<storesScalarWhereInput>
  }

  export type paymentUpdateManyWithoutUser_creatorNestedInput = {
    create?: XOR<Enumerable<paymentCreateWithoutUser_creatorInput>, Enumerable<paymentUncheckedCreateWithoutUser_creatorInput>>
    connectOrCreate?: Enumerable<paymentCreateOrConnectWithoutUser_creatorInput>
    upsert?: Enumerable<paymentUpsertWithWhereUniqueWithoutUser_creatorInput>
    createMany?: paymentCreateManyUser_creatorInputEnvelope
    set?: Enumerable<paymentWhereUniqueInput>
    disconnect?: Enumerable<paymentWhereUniqueInput>
    delete?: Enumerable<paymentWhereUniqueInput>
    connect?: Enumerable<paymentWhereUniqueInput>
    update?: Enumerable<paymentUpdateWithWhereUniqueWithoutUser_creatorInput>
    updateMany?: Enumerable<paymentUpdateManyWithWhereWithoutUser_creatorInput>
    deleteMany?: Enumerable<paymentScalarWhereInput>
  }

  export type paymentUpdateManyWithoutUser_confirmNestedInput = {
    create?: XOR<Enumerable<paymentCreateWithoutUser_confirmInput>, Enumerable<paymentUncheckedCreateWithoutUser_confirmInput>>
    connectOrCreate?: Enumerable<paymentCreateOrConnectWithoutUser_confirmInput>
    upsert?: Enumerable<paymentUpsertWithWhereUniqueWithoutUser_confirmInput>
    createMany?: paymentCreateManyUser_confirmInputEnvelope
    set?: Enumerable<paymentWhereUniqueInput>
    disconnect?: Enumerable<paymentWhereUniqueInput>
    delete?: Enumerable<paymentWhereUniqueInput>
    connect?: Enumerable<paymentWhereUniqueInput>
    update?: Enumerable<paymentUpdateWithWhereUniqueWithoutUser_confirmInput>
    updateMany?: Enumerable<paymentUpdateManyWithWhereWithoutUser_confirmInput>
    deleteMany?: Enumerable<paymentScalarWhereInput>
  }

  export type sessionsUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<sessionsCreateWithoutUserInput>, Enumerable<sessionsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<sessionsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<sessionsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: sessionsCreateManyUserInputEnvelope
    set?: Enumerable<sessionsWhereUniqueInput>
    disconnect?: Enumerable<sessionsWhereUniqueInput>
    delete?: Enumerable<sessionsWhereUniqueInput>
    connect?: Enumerable<sessionsWhereUniqueInput>
    update?: Enumerable<sessionsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<sessionsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<sessionsScalarWhereInput>
  }

  export type usersUpdatelocation_idsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type usersUpdateplatform_idsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type usersUpdateorganization_idsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type usersUpdatestore_idsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type locationsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<locationsCreateWithoutUsersInput>, Enumerable<locationsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<locationsCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<locationsUpsertWithWhereUniqueWithoutUsersInput>
    set?: Enumerable<locationsWhereUniqueInput>
    disconnect?: Enumerable<locationsWhereUniqueInput>
    delete?: Enumerable<locationsWhereUniqueInput>
    connect?: Enumerable<locationsWhereUniqueInput>
    update?: Enumerable<locationsUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<locationsUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<locationsScalarWhereInput>
  }

  export type platformsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<platformsCreateWithoutUsersInput>, Enumerable<platformsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<platformsCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<platformsUpsertWithWhereUniqueWithoutUsersInput>
    set?: Enumerable<platformsWhereUniqueInput>
    disconnect?: Enumerable<platformsWhereUniqueInput>
    delete?: Enumerable<platformsWhereUniqueInput>
    connect?: Enumerable<platformsWhereUniqueInput>
    update?: Enumerable<platformsUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<platformsUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<platformsScalarWhereInput>
  }

  export type organizationsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<organizationsCreateWithoutUsersInput>, Enumerable<organizationsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<organizationsCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<organizationsUpsertWithWhereUniqueWithoutUsersInput>
    set?: Enumerable<organizationsWhereUniqueInput>
    disconnect?: Enumerable<organizationsWhereUniqueInput>
    delete?: Enumerable<organizationsWhereUniqueInput>
    connect?: Enumerable<organizationsWhereUniqueInput>
    update?: Enumerable<organizationsUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<organizationsUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<organizationsScalarWhereInput>
  }

  export type storesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<storesCreateWithoutUsersInput>, Enumerable<storesUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<storesCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<storesUpsertWithWhereUniqueWithoutUsersInput>
    set?: Enumerable<storesWhereUniqueInput>
    disconnect?: Enumerable<storesWhereUniqueInput>
    delete?: Enumerable<storesWhereUniqueInput>
    connect?: Enumerable<storesWhereUniqueInput>
    update?: Enumerable<storesUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<storesUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<storesScalarWhereInput>
  }

  export type paymentUncheckedUpdateManyWithoutUser_creatorNestedInput = {
    create?: XOR<Enumerable<paymentCreateWithoutUser_creatorInput>, Enumerable<paymentUncheckedCreateWithoutUser_creatorInput>>
    connectOrCreate?: Enumerable<paymentCreateOrConnectWithoutUser_creatorInput>
    upsert?: Enumerable<paymentUpsertWithWhereUniqueWithoutUser_creatorInput>
    createMany?: paymentCreateManyUser_creatorInputEnvelope
    set?: Enumerable<paymentWhereUniqueInput>
    disconnect?: Enumerable<paymentWhereUniqueInput>
    delete?: Enumerable<paymentWhereUniqueInput>
    connect?: Enumerable<paymentWhereUniqueInput>
    update?: Enumerable<paymentUpdateWithWhereUniqueWithoutUser_creatorInput>
    updateMany?: Enumerable<paymentUpdateManyWithWhereWithoutUser_creatorInput>
    deleteMany?: Enumerable<paymentScalarWhereInput>
  }

  export type paymentUncheckedUpdateManyWithoutUser_confirmNestedInput = {
    create?: XOR<Enumerable<paymentCreateWithoutUser_confirmInput>, Enumerable<paymentUncheckedCreateWithoutUser_confirmInput>>
    connectOrCreate?: Enumerable<paymentCreateOrConnectWithoutUser_confirmInput>
    upsert?: Enumerable<paymentUpsertWithWhereUniqueWithoutUser_confirmInput>
    createMany?: paymentCreateManyUser_confirmInputEnvelope
    set?: Enumerable<paymentWhereUniqueInput>
    disconnect?: Enumerable<paymentWhereUniqueInput>
    delete?: Enumerable<paymentWhereUniqueInput>
    connect?: Enumerable<paymentWhereUniqueInput>
    update?: Enumerable<paymentUpdateWithWhereUniqueWithoutUser_confirmInput>
    updateMany?: Enumerable<paymentUpdateManyWithWhereWithoutUser_confirmInput>
    deleteMany?: Enumerable<paymentScalarWhereInput>
  }

  export type sessionsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<sessionsCreateWithoutUserInput>, Enumerable<sessionsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<sessionsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<sessionsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: sessionsCreateManyUserInputEnvelope
    set?: Enumerable<sessionsWhereUniqueInput>
    disconnect?: Enumerable<sessionsWhereUniqueInput>
    delete?: Enumerable<sessionsWhereUniqueInput>
    connect?: Enumerable<sessionsWhereUniqueInput>
    update?: Enumerable<sessionsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<sessionsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<sessionsScalarWhereInput>
  }

  export type imagesCreateNestedOneWithoutOrganizationsInput = {
    create?: XOR<imagesCreateWithoutOrganizationsInput, imagesUncheckedCreateWithoutOrganizationsInput>
    connectOrCreate?: imagesCreateOrConnectWithoutOrganizationsInput
    connect?: imagesWhereUniqueInput
  }

  export type platformsCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<Enumerable<platformsCreateWithoutOrganizationsInput>, Enumerable<platformsUncheckedCreateWithoutOrganizationsInput>>
    connectOrCreate?: Enumerable<platformsCreateOrConnectWithoutOrganizationsInput>
    connect?: Enumerable<platformsWhereUniqueInput>
  }

  export type usersCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<Enumerable<usersCreateWithoutOrganizationsInput>, Enumerable<usersUncheckedCreateWithoutOrganizationsInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutOrganizationsInput>
    connect?: Enumerable<usersWhereUniqueInput>
  }

  export type locationsCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<Enumerable<locationsCreateWithoutOrganizationsInput>, Enumerable<locationsUncheckedCreateWithoutOrganizationsInput>>
    connectOrCreate?: Enumerable<locationsCreateOrConnectWithoutOrganizationsInput>
    connect?: Enumerable<locationsWhereUniqueInput>
  }

  export type organizationsCreateplatform_idsInput = {
    set: Enumerable<string>
  }

  export type organizationsCreateuser_idsInput = {
    set: Enumerable<string>
  }

  export type organizationsCreatelocation_idsInput = {
    set: Enumerable<string>
  }

  export type platformsUncheckedCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<Enumerable<platformsCreateWithoutOrganizationsInput>, Enumerable<platformsUncheckedCreateWithoutOrganizationsInput>>
    connectOrCreate?: Enumerable<platformsCreateOrConnectWithoutOrganizationsInput>
    connect?: Enumerable<platformsWhereUniqueInput>
  }

  export type usersUncheckedCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<Enumerable<usersCreateWithoutOrganizationsInput>, Enumerable<usersUncheckedCreateWithoutOrganizationsInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutOrganizationsInput>
    connect?: Enumerable<usersWhereUniqueInput>
  }

  export type locationsUncheckedCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<Enumerable<locationsCreateWithoutOrganizationsInput>, Enumerable<locationsUncheckedCreateWithoutOrganizationsInput>>
    connectOrCreate?: Enumerable<locationsCreateOrConnectWithoutOrganizationsInput>
    connect?: Enumerable<locationsWhereUniqueInput>
  }

  export type imagesUpdateOneWithoutOrganizationsNestedInput = {
    create?: XOR<imagesCreateWithoutOrganizationsInput, imagesUncheckedCreateWithoutOrganizationsInput>
    connectOrCreate?: imagesCreateOrConnectWithoutOrganizationsInput
    upsert?: imagesUpsertWithoutOrganizationsInput
    disconnect?: boolean
    delete?: boolean
    connect?: imagesWhereUniqueInput
    update?: XOR<imagesUpdateWithoutOrganizationsInput, imagesUncheckedUpdateWithoutOrganizationsInput>
  }

  export type platformsUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<Enumerable<platformsCreateWithoutOrganizationsInput>, Enumerable<platformsUncheckedCreateWithoutOrganizationsInput>>
    connectOrCreate?: Enumerable<platformsCreateOrConnectWithoutOrganizationsInput>
    upsert?: Enumerable<platformsUpsertWithWhereUniqueWithoutOrganizationsInput>
    set?: Enumerable<platformsWhereUniqueInput>
    disconnect?: Enumerable<platformsWhereUniqueInput>
    delete?: Enumerable<platformsWhereUniqueInput>
    connect?: Enumerable<platformsWhereUniqueInput>
    update?: Enumerable<platformsUpdateWithWhereUniqueWithoutOrganizationsInput>
    updateMany?: Enumerable<platformsUpdateManyWithWhereWithoutOrganizationsInput>
    deleteMany?: Enumerable<platformsScalarWhereInput>
  }

  export type usersUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<Enumerable<usersCreateWithoutOrganizationsInput>, Enumerable<usersUncheckedCreateWithoutOrganizationsInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutOrganizationsInput>
    upsert?: Enumerable<usersUpsertWithWhereUniqueWithoutOrganizationsInput>
    set?: Enumerable<usersWhereUniqueInput>
    disconnect?: Enumerable<usersWhereUniqueInput>
    delete?: Enumerable<usersWhereUniqueInput>
    connect?: Enumerable<usersWhereUniqueInput>
    update?: Enumerable<usersUpdateWithWhereUniqueWithoutOrganizationsInput>
    updateMany?: Enumerable<usersUpdateManyWithWhereWithoutOrganizationsInput>
    deleteMany?: Enumerable<usersScalarWhereInput>
  }

  export type locationsUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<Enumerable<locationsCreateWithoutOrganizationsInput>, Enumerable<locationsUncheckedCreateWithoutOrganizationsInput>>
    connectOrCreate?: Enumerable<locationsCreateOrConnectWithoutOrganizationsInput>
    upsert?: Enumerable<locationsUpsertWithWhereUniqueWithoutOrganizationsInput>
    set?: Enumerable<locationsWhereUniqueInput>
    disconnect?: Enumerable<locationsWhereUniqueInput>
    delete?: Enumerable<locationsWhereUniqueInput>
    connect?: Enumerable<locationsWhereUniqueInput>
    update?: Enumerable<locationsUpdateWithWhereUniqueWithoutOrganizationsInput>
    updateMany?: Enumerable<locationsUpdateManyWithWhereWithoutOrganizationsInput>
    deleteMany?: Enumerable<locationsScalarWhereInput>
  }

  export type organizationsUpdateplatform_idsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type organizationsUpdateuser_idsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type organizationsUpdatelocation_idsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type platformsUncheckedUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<Enumerable<platformsCreateWithoutOrganizationsInput>, Enumerable<platformsUncheckedCreateWithoutOrganizationsInput>>
    connectOrCreate?: Enumerable<platformsCreateOrConnectWithoutOrganizationsInput>
    upsert?: Enumerable<platformsUpsertWithWhereUniqueWithoutOrganizationsInput>
    set?: Enumerable<platformsWhereUniqueInput>
    disconnect?: Enumerable<platformsWhereUniqueInput>
    delete?: Enumerable<platformsWhereUniqueInput>
    connect?: Enumerable<platformsWhereUniqueInput>
    update?: Enumerable<platformsUpdateWithWhereUniqueWithoutOrganizationsInput>
    updateMany?: Enumerable<platformsUpdateManyWithWhereWithoutOrganizationsInput>
    deleteMany?: Enumerable<platformsScalarWhereInput>
  }

  export type usersUncheckedUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<Enumerable<usersCreateWithoutOrganizationsInput>, Enumerable<usersUncheckedCreateWithoutOrganizationsInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutOrganizationsInput>
    upsert?: Enumerable<usersUpsertWithWhereUniqueWithoutOrganizationsInput>
    set?: Enumerable<usersWhereUniqueInput>
    disconnect?: Enumerable<usersWhereUniqueInput>
    delete?: Enumerable<usersWhereUniqueInput>
    connect?: Enumerable<usersWhereUniqueInput>
    update?: Enumerable<usersUpdateWithWhereUniqueWithoutOrganizationsInput>
    updateMany?: Enumerable<usersUpdateManyWithWhereWithoutOrganizationsInput>
    deleteMany?: Enumerable<usersScalarWhereInput>
  }

  export type locationsUncheckedUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<Enumerable<locationsCreateWithoutOrganizationsInput>, Enumerable<locationsUncheckedCreateWithoutOrganizationsInput>>
    connectOrCreate?: Enumerable<locationsCreateOrConnectWithoutOrganizationsInput>
    upsert?: Enumerable<locationsUpsertWithWhereUniqueWithoutOrganizationsInput>
    set?: Enumerable<locationsWhereUniqueInput>
    disconnect?: Enumerable<locationsWhereUniqueInput>
    delete?: Enumerable<locationsWhereUniqueInput>
    connect?: Enumerable<locationsWhereUniqueInput>
    update?: Enumerable<locationsUpdateWithWhereUniqueWithoutOrganizationsInput>
    updateMany?: Enumerable<locationsUpdateManyWithWhereWithoutOrganizationsInput>
    deleteMany?: Enumerable<locationsScalarWhereInput>
  }

  export type imagesCreateNestedOneWithoutStoresInput = {
    create?: XOR<imagesCreateWithoutStoresInput, imagesUncheckedCreateWithoutStoresInput>
    connectOrCreate?: imagesCreateOrConnectWithoutStoresInput
    connect?: imagesWhereUniqueInput
  }

  export type usersCreateNestedManyWithoutStoresInput = {
    create?: XOR<Enumerable<usersCreateWithoutStoresInput>, Enumerable<usersUncheckedCreateWithoutStoresInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutStoresInput>
    connect?: Enumerable<usersWhereUniqueInput>
  }

  export type locationsCreateNestedManyWithoutStoresInput = {
    create?: XOR<Enumerable<locationsCreateWithoutStoresInput>, Enumerable<locationsUncheckedCreateWithoutStoresInput>>
    connectOrCreate?: Enumerable<locationsCreateOrConnectWithoutStoresInput>
    connect?: Enumerable<locationsWhereUniqueInput>
  }

  export type inventoriesCreateNestedManyWithoutStoresInput = {
    create?: XOR<Enumerable<inventoriesCreateWithoutStoresInput>, Enumerable<inventoriesUncheckedCreateWithoutStoresInput>>
    connectOrCreate?: Enumerable<inventoriesCreateOrConnectWithoutStoresInput>
    connect?: Enumerable<inventoriesWhereUniqueInput>
  }

  export type storesCreateuser_idsInput = {
    set: Enumerable<string>
  }

  export type storesCreatelocation_idsInput = {
    set: Enumerable<string>
  }

  export type storesCreateinventory_idsInput = {
    set: Enumerable<string>
  }

  export type usersUncheckedCreateNestedManyWithoutStoresInput = {
    create?: XOR<Enumerable<usersCreateWithoutStoresInput>, Enumerable<usersUncheckedCreateWithoutStoresInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutStoresInput>
    connect?: Enumerable<usersWhereUniqueInput>
  }

  export type locationsUncheckedCreateNestedManyWithoutStoresInput = {
    create?: XOR<Enumerable<locationsCreateWithoutStoresInput>, Enumerable<locationsUncheckedCreateWithoutStoresInput>>
    connectOrCreate?: Enumerable<locationsCreateOrConnectWithoutStoresInput>
    connect?: Enumerable<locationsWhereUniqueInput>
  }

  export type inventoriesUncheckedCreateNestedManyWithoutStoresInput = {
    create?: XOR<Enumerable<inventoriesCreateWithoutStoresInput>, Enumerable<inventoriesUncheckedCreateWithoutStoresInput>>
    connectOrCreate?: Enumerable<inventoriesCreateOrConnectWithoutStoresInput>
    connect?: Enumerable<inventoriesWhereUniqueInput>
  }

  export type imagesUpdateOneWithoutStoresNestedInput = {
    create?: XOR<imagesCreateWithoutStoresInput, imagesUncheckedCreateWithoutStoresInput>
    connectOrCreate?: imagesCreateOrConnectWithoutStoresInput
    upsert?: imagesUpsertWithoutStoresInput
    disconnect?: boolean
    delete?: boolean
    connect?: imagesWhereUniqueInput
    update?: XOR<imagesUpdateWithoutStoresInput, imagesUncheckedUpdateWithoutStoresInput>
  }

  export type usersUpdateManyWithoutStoresNestedInput = {
    create?: XOR<Enumerable<usersCreateWithoutStoresInput>, Enumerable<usersUncheckedCreateWithoutStoresInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutStoresInput>
    upsert?: Enumerable<usersUpsertWithWhereUniqueWithoutStoresInput>
    set?: Enumerable<usersWhereUniqueInput>
    disconnect?: Enumerable<usersWhereUniqueInput>
    delete?: Enumerable<usersWhereUniqueInput>
    connect?: Enumerable<usersWhereUniqueInput>
    update?: Enumerable<usersUpdateWithWhereUniqueWithoutStoresInput>
    updateMany?: Enumerable<usersUpdateManyWithWhereWithoutStoresInput>
    deleteMany?: Enumerable<usersScalarWhereInput>
  }

  export type locationsUpdateManyWithoutStoresNestedInput = {
    create?: XOR<Enumerable<locationsCreateWithoutStoresInput>, Enumerable<locationsUncheckedCreateWithoutStoresInput>>
    connectOrCreate?: Enumerable<locationsCreateOrConnectWithoutStoresInput>
    upsert?: Enumerable<locationsUpsertWithWhereUniqueWithoutStoresInput>
    set?: Enumerable<locationsWhereUniqueInput>
    disconnect?: Enumerable<locationsWhereUniqueInput>
    delete?: Enumerable<locationsWhereUniqueInput>
    connect?: Enumerable<locationsWhereUniqueInput>
    update?: Enumerable<locationsUpdateWithWhereUniqueWithoutStoresInput>
    updateMany?: Enumerable<locationsUpdateManyWithWhereWithoutStoresInput>
    deleteMany?: Enumerable<locationsScalarWhereInput>
  }

  export type inventoriesUpdateManyWithoutStoresNestedInput = {
    create?: XOR<Enumerable<inventoriesCreateWithoutStoresInput>, Enumerable<inventoriesUncheckedCreateWithoutStoresInput>>
    connectOrCreate?: Enumerable<inventoriesCreateOrConnectWithoutStoresInput>
    upsert?: Enumerable<inventoriesUpsertWithWhereUniqueWithoutStoresInput>
    set?: Enumerable<inventoriesWhereUniqueInput>
    disconnect?: Enumerable<inventoriesWhereUniqueInput>
    delete?: Enumerable<inventoriesWhereUniqueInput>
    connect?: Enumerable<inventoriesWhereUniqueInput>
    update?: Enumerable<inventoriesUpdateWithWhereUniqueWithoutStoresInput>
    updateMany?: Enumerable<inventoriesUpdateManyWithWhereWithoutStoresInput>
    deleteMany?: Enumerable<inventoriesScalarWhereInput>
  }

  export type storesUpdateuser_idsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type storesUpdatelocation_idsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type storesUpdateinventory_idsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type usersUncheckedUpdateManyWithoutStoresNestedInput = {
    create?: XOR<Enumerable<usersCreateWithoutStoresInput>, Enumerable<usersUncheckedCreateWithoutStoresInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutStoresInput>
    upsert?: Enumerable<usersUpsertWithWhereUniqueWithoutStoresInput>
    set?: Enumerable<usersWhereUniqueInput>
    disconnect?: Enumerable<usersWhereUniqueInput>
    delete?: Enumerable<usersWhereUniqueInput>
    connect?: Enumerable<usersWhereUniqueInput>
    update?: Enumerable<usersUpdateWithWhereUniqueWithoutStoresInput>
    updateMany?: Enumerable<usersUpdateManyWithWhereWithoutStoresInput>
    deleteMany?: Enumerable<usersScalarWhereInput>
  }

  export type locationsUncheckedUpdateManyWithoutStoresNestedInput = {
    create?: XOR<Enumerable<locationsCreateWithoutStoresInput>, Enumerable<locationsUncheckedCreateWithoutStoresInput>>
    connectOrCreate?: Enumerable<locationsCreateOrConnectWithoutStoresInput>
    upsert?: Enumerable<locationsUpsertWithWhereUniqueWithoutStoresInput>
    set?: Enumerable<locationsWhereUniqueInput>
    disconnect?: Enumerable<locationsWhereUniqueInput>
    delete?: Enumerable<locationsWhereUniqueInput>
    connect?: Enumerable<locationsWhereUniqueInput>
    update?: Enumerable<locationsUpdateWithWhereUniqueWithoutStoresInput>
    updateMany?: Enumerable<locationsUpdateManyWithWhereWithoutStoresInput>
    deleteMany?: Enumerable<locationsScalarWhereInput>
  }

  export type inventoriesUncheckedUpdateManyWithoutStoresNestedInput = {
    create?: XOR<Enumerable<inventoriesCreateWithoutStoresInput>, Enumerable<inventoriesUncheckedCreateWithoutStoresInput>>
    connectOrCreate?: Enumerable<inventoriesCreateOrConnectWithoutStoresInput>
    upsert?: Enumerable<inventoriesUpsertWithWhereUniqueWithoutStoresInput>
    set?: Enumerable<inventoriesWhereUniqueInput>
    disconnect?: Enumerable<inventoriesWhereUniqueInput>
    delete?: Enumerable<inventoriesWhereUniqueInput>
    connect?: Enumerable<inventoriesWhereUniqueInput>
    update?: Enumerable<inventoriesUpdateWithWhereUniqueWithoutStoresInput>
    updateMany?: Enumerable<inventoriesUpdateManyWithWhereWithoutStoresInput>
    deleteMany?: Enumerable<inventoriesScalarWhereInput>
  }

  export type item_inventoriesCreateNestedManyWithoutInventoriesInput = {
    create?: XOR<Enumerable<item_inventoriesCreateWithoutInventoriesInput>, Enumerable<item_inventoriesUncheckedCreateWithoutInventoriesInput>>
    connectOrCreate?: Enumerable<item_inventoriesCreateOrConnectWithoutInventoriesInput>
    connect?: Enumerable<item_inventoriesWhereUniqueInput>
  }

  export type storesCreateNestedManyWithoutInventoriesInput = {
    create?: XOR<Enumerable<storesCreateWithoutInventoriesInput>, Enumerable<storesUncheckedCreateWithoutInventoriesInput>>
    connectOrCreate?: Enumerable<storesCreateOrConnectWithoutInventoriesInput>
    connect?: Enumerable<storesWhereUniqueInput>
  }

  export type inventoriesCreateitem_iventory_idsInput = {
    set: Enumerable<string>
  }

  export type inventoriesCreatestore_idsInput = {
    set: Enumerable<string>
  }

  export type item_inventoriesUncheckedCreateNestedManyWithoutInventoriesInput = {
    create?: XOR<Enumerable<item_inventoriesCreateWithoutInventoriesInput>, Enumerable<item_inventoriesUncheckedCreateWithoutInventoriesInput>>
    connectOrCreate?: Enumerable<item_inventoriesCreateOrConnectWithoutInventoriesInput>
    connect?: Enumerable<item_inventoriesWhereUniqueInput>
  }

  export type storesUncheckedCreateNestedManyWithoutInventoriesInput = {
    create?: XOR<Enumerable<storesCreateWithoutInventoriesInput>, Enumerable<storesUncheckedCreateWithoutInventoriesInput>>
    connectOrCreate?: Enumerable<storesCreateOrConnectWithoutInventoriesInput>
    connect?: Enumerable<storesWhereUniqueInput>
  }

  export type item_inventoriesUpdateManyWithoutInventoriesNestedInput = {
    create?: XOR<Enumerable<item_inventoriesCreateWithoutInventoriesInput>, Enumerable<item_inventoriesUncheckedCreateWithoutInventoriesInput>>
    connectOrCreate?: Enumerable<item_inventoriesCreateOrConnectWithoutInventoriesInput>
    upsert?: Enumerable<item_inventoriesUpsertWithWhereUniqueWithoutInventoriesInput>
    set?: Enumerable<item_inventoriesWhereUniqueInput>
    disconnect?: Enumerable<item_inventoriesWhereUniqueInput>
    delete?: Enumerable<item_inventoriesWhereUniqueInput>
    connect?: Enumerable<item_inventoriesWhereUniqueInput>
    update?: Enumerable<item_inventoriesUpdateWithWhereUniqueWithoutInventoriesInput>
    updateMany?: Enumerable<item_inventoriesUpdateManyWithWhereWithoutInventoriesInput>
    deleteMany?: Enumerable<item_inventoriesScalarWhereInput>
  }

  export type storesUpdateManyWithoutInventoriesNestedInput = {
    create?: XOR<Enumerable<storesCreateWithoutInventoriesInput>, Enumerable<storesUncheckedCreateWithoutInventoriesInput>>
    connectOrCreate?: Enumerable<storesCreateOrConnectWithoutInventoriesInput>
    upsert?: Enumerable<storesUpsertWithWhereUniqueWithoutInventoriesInput>
    set?: Enumerable<storesWhereUniqueInput>
    disconnect?: Enumerable<storesWhereUniqueInput>
    delete?: Enumerable<storesWhereUniqueInput>
    connect?: Enumerable<storesWhereUniqueInput>
    update?: Enumerable<storesUpdateWithWhereUniqueWithoutInventoriesInput>
    updateMany?: Enumerable<storesUpdateManyWithWhereWithoutInventoriesInput>
    deleteMany?: Enumerable<storesScalarWhereInput>
  }

  export type inventoriesUpdateitem_iventory_idsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type inventoriesUpdatestore_idsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type item_inventoriesUncheckedUpdateManyWithoutInventoriesNestedInput = {
    create?: XOR<Enumerable<item_inventoriesCreateWithoutInventoriesInput>, Enumerable<item_inventoriesUncheckedCreateWithoutInventoriesInput>>
    connectOrCreate?: Enumerable<item_inventoriesCreateOrConnectWithoutInventoriesInput>
    upsert?: Enumerable<item_inventoriesUpsertWithWhereUniqueWithoutInventoriesInput>
    set?: Enumerable<item_inventoriesWhereUniqueInput>
    disconnect?: Enumerable<item_inventoriesWhereUniqueInput>
    delete?: Enumerable<item_inventoriesWhereUniqueInput>
    connect?: Enumerable<item_inventoriesWhereUniqueInput>
    update?: Enumerable<item_inventoriesUpdateWithWhereUniqueWithoutInventoriesInput>
    updateMany?: Enumerable<item_inventoriesUpdateManyWithWhereWithoutInventoriesInput>
    deleteMany?: Enumerable<item_inventoriesScalarWhereInput>
  }

  export type storesUncheckedUpdateManyWithoutInventoriesNestedInput = {
    create?: XOR<Enumerable<storesCreateWithoutInventoriesInput>, Enumerable<storesUncheckedCreateWithoutInventoriesInput>>
    connectOrCreate?: Enumerable<storesCreateOrConnectWithoutInventoriesInput>
    upsert?: Enumerable<storesUpsertWithWhereUniqueWithoutInventoriesInput>
    set?: Enumerable<storesWhereUniqueInput>
    disconnect?: Enumerable<storesWhereUniqueInput>
    delete?: Enumerable<storesWhereUniqueInput>
    connect?: Enumerable<storesWhereUniqueInput>
    update?: Enumerable<storesUpdateWithWhereUniqueWithoutInventoriesInput>
    updateMany?: Enumerable<storesUpdateManyWithWhereWithoutInventoriesInput>
    deleteMany?: Enumerable<storesScalarWhereInput>
  }

  export type itemsCreateNestedOneWithoutItem_inventoriesInput = {
    create?: XOR<itemsCreateWithoutItem_inventoriesInput, itemsUncheckedCreateWithoutItem_inventoriesInput>
    connectOrCreate?: itemsCreateOrConnectWithoutItem_inventoriesInput
    connect?: itemsWhereUniqueInput
  }

  export type inventoriesCreateNestedManyWithoutItem_inventoriesInput = {
    create?: XOR<Enumerable<inventoriesCreateWithoutItem_inventoriesInput>, Enumerable<inventoriesUncheckedCreateWithoutItem_inventoriesInput>>
    connectOrCreate?: Enumerable<inventoriesCreateOrConnectWithoutItem_inventoriesInput>
    connect?: Enumerable<inventoriesWhereUniqueInput>
  }

  export type item_inventoriesCreateiventory_idsInput = {
    set: Enumerable<string>
  }

  export type inventoriesUncheckedCreateNestedManyWithoutItem_inventoriesInput = {
    create?: XOR<Enumerable<inventoriesCreateWithoutItem_inventoriesInput>, Enumerable<inventoriesUncheckedCreateWithoutItem_inventoriesInput>>
    connectOrCreate?: Enumerable<inventoriesCreateOrConnectWithoutItem_inventoriesInput>
    connect?: Enumerable<inventoriesWhereUniqueInput>
  }

  export type EnumItemQualitativeTypeFieldUpdateOperationsInput = {
    set?: ItemQualitativeType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type itemsUpdateOneRequiredWithoutItem_inventoriesNestedInput = {
    create?: XOR<itemsCreateWithoutItem_inventoriesInput, itemsUncheckedCreateWithoutItem_inventoriesInput>
    connectOrCreate?: itemsCreateOrConnectWithoutItem_inventoriesInput
    upsert?: itemsUpsertWithoutItem_inventoriesInput
    connect?: itemsWhereUniqueInput
    update?: XOR<itemsUpdateWithoutItem_inventoriesInput, itemsUncheckedUpdateWithoutItem_inventoriesInput>
  }

  export type inventoriesUpdateManyWithoutItem_inventoriesNestedInput = {
    create?: XOR<Enumerable<inventoriesCreateWithoutItem_inventoriesInput>, Enumerable<inventoriesUncheckedCreateWithoutItem_inventoriesInput>>
    connectOrCreate?: Enumerable<inventoriesCreateOrConnectWithoutItem_inventoriesInput>
    upsert?: Enumerable<inventoriesUpsertWithWhereUniqueWithoutItem_inventoriesInput>
    set?: Enumerable<inventoriesWhereUniqueInput>
    disconnect?: Enumerable<inventoriesWhereUniqueInput>
    delete?: Enumerable<inventoriesWhereUniqueInput>
    connect?: Enumerable<inventoriesWhereUniqueInput>
    update?: Enumerable<inventoriesUpdateWithWhereUniqueWithoutItem_inventoriesInput>
    updateMany?: Enumerable<inventoriesUpdateManyWithWhereWithoutItem_inventoriesInput>
    deleteMany?: Enumerable<inventoriesScalarWhereInput>
  }

  export type item_inventoriesUpdateiventory_idsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type inventoriesUncheckedUpdateManyWithoutItem_inventoriesNestedInput = {
    create?: XOR<Enumerable<inventoriesCreateWithoutItem_inventoriesInput>, Enumerable<inventoriesUncheckedCreateWithoutItem_inventoriesInput>>
    connectOrCreate?: Enumerable<inventoriesCreateOrConnectWithoutItem_inventoriesInput>
    upsert?: Enumerable<inventoriesUpsertWithWhereUniqueWithoutItem_inventoriesInput>
    set?: Enumerable<inventoriesWhereUniqueInput>
    disconnect?: Enumerable<inventoriesWhereUniqueInput>
    delete?: Enumerable<inventoriesWhereUniqueInput>
    connect?: Enumerable<inventoriesWhereUniqueInput>
    update?: Enumerable<inventoriesUpdateWithWhereUniqueWithoutItem_inventoriesInput>
    updateMany?: Enumerable<inventoriesUpdateManyWithWhereWithoutItem_inventoriesInput>
    deleteMany?: Enumerable<inventoriesScalarWhereInput>
  }

  export type item_ordersCreateNestedManyWithoutOrdersInput = {
    create?: XOR<Enumerable<item_ordersCreateWithoutOrdersInput>, Enumerable<item_ordersUncheckedCreateWithoutOrdersInput>>
    connectOrCreate?: Enumerable<item_ordersCreateOrConnectWithoutOrdersInput>
    connect?: Enumerable<item_ordersWhereUniqueInput>
  }

  export type odersCreateitem_order_idsInput = {
    set: Enumerable<string>
  }

  export type item_ordersUncheckedCreateNestedManyWithoutOrdersInput = {
    create?: XOR<Enumerable<item_ordersCreateWithoutOrdersInput>, Enumerable<item_ordersUncheckedCreateWithoutOrdersInput>>
    connectOrCreate?: Enumerable<item_ordersCreateOrConnectWithoutOrdersInput>
    connect?: Enumerable<item_ordersWhereUniqueInput>
  }

  export type item_ordersUpdateManyWithoutOrdersNestedInput = {
    create?: XOR<Enumerable<item_ordersCreateWithoutOrdersInput>, Enumerable<item_ordersUncheckedCreateWithoutOrdersInput>>
    connectOrCreate?: Enumerable<item_ordersCreateOrConnectWithoutOrdersInput>
    upsert?: Enumerable<item_ordersUpsertWithWhereUniqueWithoutOrdersInput>
    set?: Enumerable<item_ordersWhereUniqueInput>
    disconnect?: Enumerable<item_ordersWhereUniqueInput>
    delete?: Enumerable<item_ordersWhereUniqueInput>
    connect?: Enumerable<item_ordersWhereUniqueInput>
    update?: Enumerable<item_ordersUpdateWithWhereUniqueWithoutOrdersInput>
    updateMany?: Enumerable<item_ordersUpdateManyWithWhereWithoutOrdersInput>
    deleteMany?: Enumerable<item_ordersScalarWhereInput>
  }

  export type odersUpdateitem_order_idsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type item_ordersUncheckedUpdateManyWithoutOrdersNestedInput = {
    create?: XOR<Enumerable<item_ordersCreateWithoutOrdersInput>, Enumerable<item_ordersUncheckedCreateWithoutOrdersInput>>
    connectOrCreate?: Enumerable<item_ordersCreateOrConnectWithoutOrdersInput>
    upsert?: Enumerable<item_ordersUpsertWithWhereUniqueWithoutOrdersInput>
    set?: Enumerable<item_ordersWhereUniqueInput>
    disconnect?: Enumerable<item_ordersWhereUniqueInput>
    delete?: Enumerable<item_ordersWhereUniqueInput>
    connect?: Enumerable<item_ordersWhereUniqueInput>
    update?: Enumerable<item_ordersUpdateWithWhereUniqueWithoutOrdersInput>
    updateMany?: Enumerable<item_ordersUpdateManyWithWhereWithoutOrdersInput>
    deleteMany?: Enumerable<item_ordersScalarWhereInput>
  }

  export type itemsCreateNestedOneWithoutItem_ordersInput = {
    create?: XOR<itemsCreateWithoutItem_ordersInput, itemsUncheckedCreateWithoutItem_ordersInput>
    connectOrCreate?: itemsCreateOrConnectWithoutItem_ordersInput
    connect?: itemsWhereUniqueInput
  }

  export type odersCreateNestedManyWithoutItem_ordersInput = {
    create?: XOR<Enumerable<odersCreateWithoutItem_ordersInput>, Enumerable<odersUncheckedCreateWithoutItem_ordersInput>>
    connectOrCreate?: Enumerable<odersCreateOrConnectWithoutItem_ordersInput>
    connect?: Enumerable<odersWhereUniqueInput>
  }

  export type item_ordersCreateorder_idsInput = {
    set: Enumerable<string>
  }

  export type odersUncheckedCreateNestedManyWithoutItem_ordersInput = {
    create?: XOR<Enumerable<odersCreateWithoutItem_ordersInput>, Enumerable<odersUncheckedCreateWithoutItem_ordersInput>>
    connectOrCreate?: Enumerable<odersCreateOrConnectWithoutItem_ordersInput>
    connect?: Enumerable<odersWhereUniqueInput>
  }

  export type itemsUpdateOneRequiredWithoutItem_ordersNestedInput = {
    create?: XOR<itemsCreateWithoutItem_ordersInput, itemsUncheckedCreateWithoutItem_ordersInput>
    connectOrCreate?: itemsCreateOrConnectWithoutItem_ordersInput
    upsert?: itemsUpsertWithoutItem_ordersInput
    connect?: itemsWhereUniqueInput
    update?: XOR<itemsUpdateWithoutItem_ordersInput, itemsUncheckedUpdateWithoutItem_ordersInput>
  }

  export type odersUpdateManyWithoutItem_ordersNestedInput = {
    create?: XOR<Enumerable<odersCreateWithoutItem_ordersInput>, Enumerable<odersUncheckedCreateWithoutItem_ordersInput>>
    connectOrCreate?: Enumerable<odersCreateOrConnectWithoutItem_ordersInput>
    upsert?: Enumerable<odersUpsertWithWhereUniqueWithoutItem_ordersInput>
    set?: Enumerable<odersWhereUniqueInput>
    disconnect?: Enumerable<odersWhereUniqueInput>
    delete?: Enumerable<odersWhereUniqueInput>
    connect?: Enumerable<odersWhereUniqueInput>
    update?: Enumerable<odersUpdateWithWhereUniqueWithoutItem_ordersInput>
    updateMany?: Enumerable<odersUpdateManyWithWhereWithoutItem_ordersInput>
    deleteMany?: Enumerable<odersScalarWhereInput>
  }

  export type item_ordersUpdateorder_idsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type odersUncheckedUpdateManyWithoutItem_ordersNestedInput = {
    create?: XOR<Enumerable<odersCreateWithoutItem_ordersInput>, Enumerable<odersUncheckedCreateWithoutItem_ordersInput>>
    connectOrCreate?: Enumerable<odersCreateOrConnectWithoutItem_ordersInput>
    upsert?: Enumerable<odersUpsertWithWhereUniqueWithoutItem_ordersInput>
    set?: Enumerable<odersWhereUniqueInput>
    disconnect?: Enumerable<odersWhereUniqueInput>
    delete?: Enumerable<odersWhereUniqueInput>
    connect?: Enumerable<odersWhereUniqueInput>
    update?: Enumerable<odersUpdateWithWhereUniqueWithoutItem_ordersInput>
    updateMany?: Enumerable<odersUpdateManyWithWhereWithoutItem_ordersInput>
    deleteMany?: Enumerable<odersScalarWhereInput>
  }

  export type paymentCreateNestedManyWithoutPayment_typeInput = {
    create?: XOR<Enumerable<paymentCreateWithoutPayment_typeInput>, Enumerable<paymentUncheckedCreateWithoutPayment_typeInput>>
    connectOrCreate?: Enumerable<paymentCreateOrConnectWithoutPayment_typeInput>
    createMany?: paymentCreateManyPayment_typeInputEnvelope
    connect?: Enumerable<paymentWhereUniqueInput>
  }

  export type paymentUncheckedCreateNestedManyWithoutPayment_typeInput = {
    create?: XOR<Enumerable<paymentCreateWithoutPayment_typeInput>, Enumerable<paymentUncheckedCreateWithoutPayment_typeInput>>
    connectOrCreate?: Enumerable<paymentCreateOrConnectWithoutPayment_typeInput>
    createMany?: paymentCreateManyPayment_typeInputEnvelope
    connect?: Enumerable<paymentWhereUniqueInput>
  }

  export type paymentUpdateManyWithoutPayment_typeNestedInput = {
    create?: XOR<Enumerable<paymentCreateWithoutPayment_typeInput>, Enumerable<paymentUncheckedCreateWithoutPayment_typeInput>>
    connectOrCreate?: Enumerable<paymentCreateOrConnectWithoutPayment_typeInput>
    upsert?: Enumerable<paymentUpsertWithWhereUniqueWithoutPayment_typeInput>
    createMany?: paymentCreateManyPayment_typeInputEnvelope
    set?: Enumerable<paymentWhereUniqueInput>
    disconnect?: Enumerable<paymentWhereUniqueInput>
    delete?: Enumerable<paymentWhereUniqueInput>
    connect?: Enumerable<paymentWhereUniqueInput>
    update?: Enumerable<paymentUpdateWithWhereUniqueWithoutPayment_typeInput>
    updateMany?: Enumerable<paymentUpdateManyWithWhereWithoutPayment_typeInput>
    deleteMany?: Enumerable<paymentScalarWhereInput>
  }

  export type paymentUncheckedUpdateManyWithoutPayment_typeNestedInput = {
    create?: XOR<Enumerable<paymentCreateWithoutPayment_typeInput>, Enumerable<paymentUncheckedCreateWithoutPayment_typeInput>>
    connectOrCreate?: Enumerable<paymentCreateOrConnectWithoutPayment_typeInput>
    upsert?: Enumerable<paymentUpsertWithWhereUniqueWithoutPayment_typeInput>
    createMany?: paymentCreateManyPayment_typeInputEnvelope
    set?: Enumerable<paymentWhereUniqueInput>
    disconnect?: Enumerable<paymentWhereUniqueInput>
    delete?: Enumerable<paymentWhereUniqueInput>
    connect?: Enumerable<paymentWhereUniqueInput>
    update?: Enumerable<paymentUpdateWithWhereUniqueWithoutPayment_typeInput>
    updateMany?: Enumerable<paymentUpdateManyWithWhereWithoutPayment_typeInput>
    deleteMany?: Enumerable<paymentScalarWhereInput>
  }

  export type CurrencyCreateEnvelopeInput = {
    set?: CurrencyCreateInput
  }

  export type CurrencyCreateInput = {
    amount: number
    currency: CurrencyType
  }

  export type PaymentTypeCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<PaymentTypeCreateWithoutPaymentsInput, PaymentTypeUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: PaymentTypeCreateOrConnectWithoutPaymentsInput
    connect?: PaymentTypeWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutPayments_createdInput = {
    create?: XOR<usersCreateWithoutPayments_createdInput, usersUncheckedCreateWithoutPayments_createdInput>
    connectOrCreate?: usersCreateOrConnectWithoutPayments_createdInput
    connect?: usersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutPayments_confirmedInput = {
    create?: XOR<usersCreateWithoutPayments_confirmedInput, usersUncheckedCreateWithoutPayments_confirmedInput>
    connectOrCreate?: usersCreateOrConnectWithoutPayments_confirmedInput
    connect?: usersWhereUniqueInput
  }

  export type PaymentAccountCreateNestedOneWithoutPayments_receivedInput = {
    create?: XOR<PaymentAccountCreateWithoutPayments_receivedInput, PaymentAccountUncheckedCreateWithoutPayments_receivedInput>
    connectOrCreate?: PaymentAccountCreateOrConnectWithoutPayments_receivedInput
    connect?: PaymentAccountWhereUniqueInput
  }

  export type PaymentAccountCreateNestedOneWithoutPayments_sendedInput = {
    create?: XOR<PaymentAccountCreateWithoutPayments_sendedInput, PaymentAccountUncheckedCreateWithoutPayments_sendedInput>
    connectOrCreate?: PaymentAccountCreateOrConnectWithoutPayments_sendedInput
    connect?: PaymentAccountWhereUniqueInput
  }

  export type CurrencyUpdateEnvelopeInput = {
    set?: CurrencyCreateInput
    update?: CurrencyUpdateInput
  }

  export type PaymentTypeUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<PaymentTypeCreateWithoutPaymentsInput, PaymentTypeUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: PaymentTypeCreateOrConnectWithoutPaymentsInput
    upsert?: PaymentTypeUpsertWithoutPaymentsInput
    connect?: PaymentTypeWhereUniqueInput
    update?: XOR<PaymentTypeUpdateWithoutPaymentsInput, PaymentTypeUncheckedUpdateWithoutPaymentsInput>
  }

  export type usersUpdateOneRequiredWithoutPayments_createdNestedInput = {
    create?: XOR<usersCreateWithoutPayments_createdInput, usersUncheckedCreateWithoutPayments_createdInput>
    connectOrCreate?: usersCreateOrConnectWithoutPayments_createdInput
    upsert?: usersUpsertWithoutPayments_createdInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutPayments_createdInput, usersUncheckedUpdateWithoutPayments_createdInput>
  }

  export type usersUpdateOneRequiredWithoutPayments_confirmedNestedInput = {
    create?: XOR<usersCreateWithoutPayments_confirmedInput, usersUncheckedCreateWithoutPayments_confirmedInput>
    connectOrCreate?: usersCreateOrConnectWithoutPayments_confirmedInput
    upsert?: usersUpsertWithoutPayments_confirmedInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutPayments_confirmedInput, usersUncheckedUpdateWithoutPayments_confirmedInput>
  }

  export type PaymentAccountUpdateOneRequiredWithoutPayments_receivedNestedInput = {
    create?: XOR<PaymentAccountCreateWithoutPayments_receivedInput, PaymentAccountUncheckedCreateWithoutPayments_receivedInput>
    connectOrCreate?: PaymentAccountCreateOrConnectWithoutPayments_receivedInput
    upsert?: PaymentAccountUpsertWithoutPayments_receivedInput
    connect?: PaymentAccountWhereUniqueInput
    update?: XOR<PaymentAccountUpdateWithoutPayments_receivedInput, PaymentAccountUncheckedUpdateWithoutPayments_receivedInput>
  }

  export type PaymentAccountUpdateOneRequiredWithoutPayments_sendedNestedInput = {
    create?: XOR<PaymentAccountCreateWithoutPayments_sendedInput, PaymentAccountUncheckedCreateWithoutPayments_sendedInput>
    connectOrCreate?: PaymentAccountCreateOrConnectWithoutPayments_sendedInput
    upsert?: PaymentAccountUpsertWithoutPayments_sendedInput
    connect?: PaymentAccountWhereUniqueInput
    update?: XOR<PaymentAccountUpdateWithoutPayments_sendedInput, PaymentAccountUncheckedUpdateWithoutPayments_sendedInput>
  }

  export type paymentCreateNestedManyWithoutRecever_accountInput = {
    create?: XOR<Enumerable<paymentCreateWithoutRecever_accountInput>, Enumerable<paymentUncheckedCreateWithoutRecever_accountInput>>
    connectOrCreate?: Enumerable<paymentCreateOrConnectWithoutRecever_accountInput>
    createMany?: paymentCreateManyRecever_accountInputEnvelope
    connect?: Enumerable<paymentWhereUniqueInput>
  }

  export type paymentCreateNestedManyWithoutSender_accountInput = {
    create?: XOR<Enumerable<paymentCreateWithoutSender_accountInput>, Enumerable<paymentUncheckedCreateWithoutSender_accountInput>>
    connectOrCreate?: Enumerable<paymentCreateOrConnectWithoutSender_accountInput>
    createMany?: paymentCreateManySender_accountInputEnvelope
    connect?: Enumerable<paymentWhereUniqueInput>
  }

  export type paymentUncheckedCreateNestedManyWithoutRecever_accountInput = {
    create?: XOR<Enumerable<paymentCreateWithoutRecever_accountInput>, Enumerable<paymentUncheckedCreateWithoutRecever_accountInput>>
    connectOrCreate?: Enumerable<paymentCreateOrConnectWithoutRecever_accountInput>
    createMany?: paymentCreateManyRecever_accountInputEnvelope
    connect?: Enumerable<paymentWhereUniqueInput>
  }

  export type paymentUncheckedCreateNestedManyWithoutSender_accountInput = {
    create?: XOR<Enumerable<paymentCreateWithoutSender_accountInput>, Enumerable<paymentUncheckedCreateWithoutSender_accountInput>>
    connectOrCreate?: Enumerable<paymentCreateOrConnectWithoutSender_accountInput>
    createMany?: paymentCreateManySender_accountInputEnvelope
    connect?: Enumerable<paymentWhereUniqueInput>
  }

  export type paymentUpdateManyWithoutRecever_accountNestedInput = {
    create?: XOR<Enumerable<paymentCreateWithoutRecever_accountInput>, Enumerable<paymentUncheckedCreateWithoutRecever_accountInput>>
    connectOrCreate?: Enumerable<paymentCreateOrConnectWithoutRecever_accountInput>
    upsert?: Enumerable<paymentUpsertWithWhereUniqueWithoutRecever_accountInput>
    createMany?: paymentCreateManyRecever_accountInputEnvelope
    set?: Enumerable<paymentWhereUniqueInput>
    disconnect?: Enumerable<paymentWhereUniqueInput>
    delete?: Enumerable<paymentWhereUniqueInput>
    connect?: Enumerable<paymentWhereUniqueInput>
    update?: Enumerable<paymentUpdateWithWhereUniqueWithoutRecever_accountInput>
    updateMany?: Enumerable<paymentUpdateManyWithWhereWithoutRecever_accountInput>
    deleteMany?: Enumerable<paymentScalarWhereInput>
  }

  export type paymentUpdateManyWithoutSender_accountNestedInput = {
    create?: XOR<Enumerable<paymentCreateWithoutSender_accountInput>, Enumerable<paymentUncheckedCreateWithoutSender_accountInput>>
    connectOrCreate?: Enumerable<paymentCreateOrConnectWithoutSender_accountInput>
    upsert?: Enumerable<paymentUpsertWithWhereUniqueWithoutSender_accountInput>
    createMany?: paymentCreateManySender_accountInputEnvelope
    set?: Enumerable<paymentWhereUniqueInput>
    disconnect?: Enumerable<paymentWhereUniqueInput>
    delete?: Enumerable<paymentWhereUniqueInput>
    connect?: Enumerable<paymentWhereUniqueInput>
    update?: Enumerable<paymentUpdateWithWhereUniqueWithoutSender_accountInput>
    updateMany?: Enumerable<paymentUpdateManyWithWhereWithoutSender_accountInput>
    deleteMany?: Enumerable<paymentScalarWhereInput>
  }

  export type paymentUncheckedUpdateManyWithoutRecever_accountNestedInput = {
    create?: XOR<Enumerable<paymentCreateWithoutRecever_accountInput>, Enumerable<paymentUncheckedCreateWithoutRecever_accountInput>>
    connectOrCreate?: Enumerable<paymentCreateOrConnectWithoutRecever_accountInput>
    upsert?: Enumerable<paymentUpsertWithWhereUniqueWithoutRecever_accountInput>
    createMany?: paymentCreateManyRecever_accountInputEnvelope
    set?: Enumerable<paymentWhereUniqueInput>
    disconnect?: Enumerable<paymentWhereUniqueInput>
    delete?: Enumerable<paymentWhereUniqueInput>
    connect?: Enumerable<paymentWhereUniqueInput>
    update?: Enumerable<paymentUpdateWithWhereUniqueWithoutRecever_accountInput>
    updateMany?: Enumerable<paymentUpdateManyWithWhereWithoutRecever_accountInput>
    deleteMany?: Enumerable<paymentScalarWhereInput>
  }

  export type paymentUncheckedUpdateManyWithoutSender_accountNestedInput = {
    create?: XOR<Enumerable<paymentCreateWithoutSender_accountInput>, Enumerable<paymentUncheckedCreateWithoutSender_accountInput>>
    connectOrCreate?: Enumerable<paymentCreateOrConnectWithoutSender_accountInput>
    upsert?: Enumerable<paymentUpsertWithWhereUniqueWithoutSender_accountInput>
    createMany?: paymentCreateManySender_accountInputEnvelope
    set?: Enumerable<paymentWhereUniqueInput>
    disconnect?: Enumerable<paymentWhereUniqueInput>
    delete?: Enumerable<paymentWhereUniqueInput>
    connect?: Enumerable<paymentWhereUniqueInput>
    update?: Enumerable<paymentUpdateWithWhereUniqueWithoutSender_accountInput>
    updateMany?: Enumerable<paymentUpdateManyWithWhereWithoutSender_accountInput>
    deleteMany?: Enumerable<paymentScalarWhereInput>
  }

  export type itemsCreatetagsInput = {
    set: Enumerable<string>
  }

  export type CurrencyListCreateEnvelopeInput = {
    set?: Enumerable<CurrencyCreateInput>
  }

  export type imagesCreateNestedManyWithoutItemsInput = {
    create?: XOR<Enumerable<imagesCreateWithoutItemsInput>, Enumerable<imagesUncheckedCreateWithoutItemsInput>>
    connectOrCreate?: Enumerable<imagesCreateOrConnectWithoutItemsInput>
    connect?: Enumerable<imagesWhereUniqueInput>
  }

  export type item_inventoriesCreateNestedManyWithoutItemInput = {
    create?: XOR<Enumerable<item_inventoriesCreateWithoutItemInput>, Enumerable<item_inventoriesUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<item_inventoriesCreateOrConnectWithoutItemInput>
    createMany?: item_inventoriesCreateManyItemInputEnvelope
    connect?: Enumerable<item_inventoriesWhereUniqueInput>
  }

  export type item_ordersCreateNestedManyWithoutItemInput = {
    create?: XOR<Enumerable<item_ordersCreateWithoutItemInput>, Enumerable<item_ordersUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<item_ordersCreateOrConnectWithoutItemInput>
    createMany?: item_ordersCreateManyItemInputEnvelope
    connect?: Enumerable<item_ordersWhereUniqueInput>
  }

  export type itemsCreateimage_idsInput = {
    set: Enumerable<string>
  }

  export type imagesUncheckedCreateNestedManyWithoutItemsInput = {
    create?: XOR<Enumerable<imagesCreateWithoutItemsInput>, Enumerable<imagesUncheckedCreateWithoutItemsInput>>
    connectOrCreate?: Enumerable<imagesCreateOrConnectWithoutItemsInput>
    connect?: Enumerable<imagesWhereUniqueInput>
  }

  export type item_inventoriesUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<Enumerable<item_inventoriesCreateWithoutItemInput>, Enumerable<item_inventoriesUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<item_inventoriesCreateOrConnectWithoutItemInput>
    createMany?: item_inventoriesCreateManyItemInputEnvelope
    connect?: Enumerable<item_inventoriesWhereUniqueInput>
  }

  export type item_ordersUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<Enumerable<item_ordersCreateWithoutItemInput>, Enumerable<item_ordersUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<item_ordersCreateOrConnectWithoutItemInput>
    createMany?: item_ordersCreateManyItemInputEnvelope
    connect?: Enumerable<item_ordersWhereUniqueInput>
  }

  export type itemsUpdatetagsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type CurrencyListUpdateEnvelopeInput = {
    set?: Enumerable<CurrencyCreateInput>
    push?: Enumerable<CurrencyCreateInput>
    updateMany?: CurrencyUpdateManyInput
    deleteMany?: CurrencyDeleteManyInput
  }

  export type imagesUpdateManyWithoutItemsNestedInput = {
    create?: XOR<Enumerable<imagesCreateWithoutItemsInput>, Enumerable<imagesUncheckedCreateWithoutItemsInput>>
    connectOrCreate?: Enumerable<imagesCreateOrConnectWithoutItemsInput>
    upsert?: Enumerable<imagesUpsertWithWhereUniqueWithoutItemsInput>
    set?: Enumerable<imagesWhereUniqueInput>
    disconnect?: Enumerable<imagesWhereUniqueInput>
    delete?: Enumerable<imagesWhereUniqueInput>
    connect?: Enumerable<imagesWhereUniqueInput>
    update?: Enumerable<imagesUpdateWithWhereUniqueWithoutItemsInput>
    updateMany?: Enumerable<imagesUpdateManyWithWhereWithoutItemsInput>
    deleteMany?: Enumerable<imagesScalarWhereInput>
  }

  export type item_inventoriesUpdateManyWithoutItemNestedInput = {
    create?: XOR<Enumerable<item_inventoriesCreateWithoutItemInput>, Enumerable<item_inventoriesUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<item_inventoriesCreateOrConnectWithoutItemInput>
    upsert?: Enumerable<item_inventoriesUpsertWithWhereUniqueWithoutItemInput>
    createMany?: item_inventoriesCreateManyItemInputEnvelope
    set?: Enumerable<item_inventoriesWhereUniqueInput>
    disconnect?: Enumerable<item_inventoriesWhereUniqueInput>
    delete?: Enumerable<item_inventoriesWhereUniqueInput>
    connect?: Enumerable<item_inventoriesWhereUniqueInput>
    update?: Enumerable<item_inventoriesUpdateWithWhereUniqueWithoutItemInput>
    updateMany?: Enumerable<item_inventoriesUpdateManyWithWhereWithoutItemInput>
    deleteMany?: Enumerable<item_inventoriesScalarWhereInput>
  }

  export type item_ordersUpdateManyWithoutItemNestedInput = {
    create?: XOR<Enumerable<item_ordersCreateWithoutItemInput>, Enumerable<item_ordersUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<item_ordersCreateOrConnectWithoutItemInput>
    upsert?: Enumerable<item_ordersUpsertWithWhereUniqueWithoutItemInput>
    createMany?: item_ordersCreateManyItemInputEnvelope
    set?: Enumerable<item_ordersWhereUniqueInput>
    disconnect?: Enumerable<item_ordersWhereUniqueInput>
    delete?: Enumerable<item_ordersWhereUniqueInput>
    connect?: Enumerable<item_ordersWhereUniqueInput>
    update?: Enumerable<item_ordersUpdateWithWhereUniqueWithoutItemInput>
    updateMany?: Enumerable<item_ordersUpdateManyWithWhereWithoutItemInput>
    deleteMany?: Enumerable<item_ordersScalarWhereInput>
  }

  export type itemsUpdateimage_idsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type imagesUncheckedUpdateManyWithoutItemsNestedInput = {
    create?: XOR<Enumerable<imagesCreateWithoutItemsInput>, Enumerable<imagesUncheckedCreateWithoutItemsInput>>
    connectOrCreate?: Enumerable<imagesCreateOrConnectWithoutItemsInput>
    upsert?: Enumerable<imagesUpsertWithWhereUniqueWithoutItemsInput>
    set?: Enumerable<imagesWhereUniqueInput>
    disconnect?: Enumerable<imagesWhereUniqueInput>
    delete?: Enumerable<imagesWhereUniqueInput>
    connect?: Enumerable<imagesWhereUniqueInput>
    update?: Enumerable<imagesUpdateWithWhereUniqueWithoutItemsInput>
    updateMany?: Enumerable<imagesUpdateManyWithWhereWithoutItemsInput>
    deleteMany?: Enumerable<imagesScalarWhereInput>
  }

  export type item_inventoriesUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<Enumerable<item_inventoriesCreateWithoutItemInput>, Enumerable<item_inventoriesUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<item_inventoriesCreateOrConnectWithoutItemInput>
    upsert?: Enumerable<item_inventoriesUpsertWithWhereUniqueWithoutItemInput>
    createMany?: item_inventoriesCreateManyItemInputEnvelope
    set?: Enumerable<item_inventoriesWhereUniqueInput>
    disconnect?: Enumerable<item_inventoriesWhereUniqueInput>
    delete?: Enumerable<item_inventoriesWhereUniqueInput>
    connect?: Enumerable<item_inventoriesWhereUniqueInput>
    update?: Enumerable<item_inventoriesUpdateWithWhereUniqueWithoutItemInput>
    updateMany?: Enumerable<item_inventoriesUpdateManyWithWhereWithoutItemInput>
    deleteMany?: Enumerable<item_inventoriesScalarWhereInput>
  }

  export type item_ordersUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<Enumerable<item_ordersCreateWithoutItemInput>, Enumerable<item_ordersUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<item_ordersCreateOrConnectWithoutItemInput>
    upsert?: Enumerable<item_ordersUpsertWithWhereUniqueWithoutItemInput>
    createMany?: item_ordersCreateManyItemInputEnvelope
    set?: Enumerable<item_ordersWhereUniqueInput>
    disconnect?: Enumerable<item_ordersWhereUniqueInput>
    delete?: Enumerable<item_ordersWhereUniqueInput>
    connect?: Enumerable<item_ordersWhereUniqueInput>
    update?: Enumerable<item_ordersUpdateWithWhereUniqueWithoutItemInput>
    updateMany?: Enumerable<item_ordersUpdateManyWithWhereWithoutItemInput>
    deleteMany?: Enumerable<item_ordersScalarWhereInput>
  }

  export type locationsCreatestore_idsInput = {
    set: Enumerable<string>
  }

  export type usersCreateNestedManyWithoutLocationsInput = {
    create?: XOR<Enumerable<usersCreateWithoutLocationsInput>, Enumerable<usersUncheckedCreateWithoutLocationsInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutLocationsInput>
    connect?: Enumerable<usersWhereUniqueInput>
  }

  export type organizationsCreateNestedManyWithoutLocationsInput = {
    create?: XOR<Enumerable<organizationsCreateWithoutLocationsInput>, Enumerable<organizationsUncheckedCreateWithoutLocationsInput>>
    connectOrCreate?: Enumerable<organizationsCreateOrConnectWithoutLocationsInput>
    connect?: Enumerable<organizationsWhereUniqueInput>
  }

  export type storesCreateNestedManyWithoutLocationsInput = {
    create?: XOR<Enumerable<storesCreateWithoutLocationsInput>, Enumerable<storesUncheckedCreateWithoutLocationsInput>>
    connectOrCreate?: Enumerable<storesCreateOrConnectWithoutLocationsInput>
    connect?: Enumerable<storesWhereUniqueInput>
  }

  export type usersCreateNestedManyWithoutPrefered_locationInput = {
    create?: XOR<Enumerable<usersCreateWithoutPrefered_locationInput>, Enumerable<usersUncheckedCreateWithoutPrefered_locationInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutPrefered_locationInput>
    createMany?: usersCreateManyPrefered_locationInputEnvelope
    connect?: Enumerable<usersWhereUniqueInput>
  }

  export type locationsCreateuser_idsInput = {
    set: Enumerable<string>
  }

  export type locationsCreateorganizations_idsInput = {
    set: Enumerable<string>
  }

  export type usersUncheckedCreateNestedManyWithoutLocationsInput = {
    create?: XOR<Enumerable<usersCreateWithoutLocationsInput>, Enumerable<usersUncheckedCreateWithoutLocationsInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutLocationsInput>
    connect?: Enumerable<usersWhereUniqueInput>
  }

  export type organizationsUncheckedCreateNestedManyWithoutLocationsInput = {
    create?: XOR<Enumerable<organizationsCreateWithoutLocationsInput>, Enumerable<organizationsUncheckedCreateWithoutLocationsInput>>
    connectOrCreate?: Enumerable<organizationsCreateOrConnectWithoutLocationsInput>
    connect?: Enumerable<organizationsWhereUniqueInput>
  }

  export type storesUncheckedCreateNestedManyWithoutLocationsInput = {
    create?: XOR<Enumerable<storesCreateWithoutLocationsInput>, Enumerable<storesUncheckedCreateWithoutLocationsInput>>
    connectOrCreate?: Enumerable<storesCreateOrConnectWithoutLocationsInput>
    connect?: Enumerable<storesWhereUniqueInput>
  }

  export type usersUncheckedCreateNestedManyWithoutPrefered_locationInput = {
    create?: XOR<Enumerable<usersCreateWithoutPrefered_locationInput>, Enumerable<usersUncheckedCreateWithoutPrefered_locationInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutPrefered_locationInput>
    createMany?: usersCreateManyPrefered_locationInputEnvelope
    connect?: Enumerable<usersWhereUniqueInput>
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type locationsUpdatestore_idsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type usersUpdateManyWithoutLocationsNestedInput = {
    create?: XOR<Enumerable<usersCreateWithoutLocationsInput>, Enumerable<usersUncheckedCreateWithoutLocationsInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutLocationsInput>
    upsert?: Enumerable<usersUpsertWithWhereUniqueWithoutLocationsInput>
    set?: Enumerable<usersWhereUniqueInput>
    disconnect?: Enumerable<usersWhereUniqueInput>
    delete?: Enumerable<usersWhereUniqueInput>
    connect?: Enumerable<usersWhereUniqueInput>
    update?: Enumerable<usersUpdateWithWhereUniqueWithoutLocationsInput>
    updateMany?: Enumerable<usersUpdateManyWithWhereWithoutLocationsInput>
    deleteMany?: Enumerable<usersScalarWhereInput>
  }

  export type organizationsUpdateManyWithoutLocationsNestedInput = {
    create?: XOR<Enumerable<organizationsCreateWithoutLocationsInput>, Enumerable<organizationsUncheckedCreateWithoutLocationsInput>>
    connectOrCreate?: Enumerable<organizationsCreateOrConnectWithoutLocationsInput>
    upsert?: Enumerable<organizationsUpsertWithWhereUniqueWithoutLocationsInput>
    set?: Enumerable<organizationsWhereUniqueInput>
    disconnect?: Enumerable<organizationsWhereUniqueInput>
    delete?: Enumerable<organizationsWhereUniqueInput>
    connect?: Enumerable<organizationsWhereUniqueInput>
    update?: Enumerable<organizationsUpdateWithWhereUniqueWithoutLocationsInput>
    updateMany?: Enumerable<organizationsUpdateManyWithWhereWithoutLocationsInput>
    deleteMany?: Enumerable<organizationsScalarWhereInput>
  }

  export type storesUpdateManyWithoutLocationsNestedInput = {
    create?: XOR<Enumerable<storesCreateWithoutLocationsInput>, Enumerable<storesUncheckedCreateWithoutLocationsInput>>
    connectOrCreate?: Enumerable<storesCreateOrConnectWithoutLocationsInput>
    upsert?: Enumerable<storesUpsertWithWhereUniqueWithoutLocationsInput>
    set?: Enumerable<storesWhereUniqueInput>
    disconnect?: Enumerable<storesWhereUniqueInput>
    delete?: Enumerable<storesWhereUniqueInput>
    connect?: Enumerable<storesWhereUniqueInput>
    update?: Enumerable<storesUpdateWithWhereUniqueWithoutLocationsInput>
    updateMany?: Enumerable<storesUpdateManyWithWhereWithoutLocationsInput>
    deleteMany?: Enumerable<storesScalarWhereInput>
  }

  export type usersUpdateManyWithoutPrefered_locationNestedInput = {
    create?: XOR<Enumerable<usersCreateWithoutPrefered_locationInput>, Enumerable<usersUncheckedCreateWithoutPrefered_locationInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutPrefered_locationInput>
    upsert?: Enumerable<usersUpsertWithWhereUniqueWithoutPrefered_locationInput>
    createMany?: usersCreateManyPrefered_locationInputEnvelope
    set?: Enumerable<usersWhereUniqueInput>
    disconnect?: Enumerable<usersWhereUniqueInput>
    delete?: Enumerable<usersWhereUniqueInput>
    connect?: Enumerable<usersWhereUniqueInput>
    update?: Enumerable<usersUpdateWithWhereUniqueWithoutPrefered_locationInput>
    updateMany?: Enumerable<usersUpdateManyWithWhereWithoutPrefered_locationInput>
    deleteMany?: Enumerable<usersScalarWhereInput>
  }

  export type locationsUpdateuser_idsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type locationsUpdateorganizations_idsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type usersUncheckedUpdateManyWithoutLocationsNestedInput = {
    create?: XOR<Enumerable<usersCreateWithoutLocationsInput>, Enumerable<usersUncheckedCreateWithoutLocationsInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutLocationsInput>
    upsert?: Enumerable<usersUpsertWithWhereUniqueWithoutLocationsInput>
    set?: Enumerable<usersWhereUniqueInput>
    disconnect?: Enumerable<usersWhereUniqueInput>
    delete?: Enumerable<usersWhereUniqueInput>
    connect?: Enumerable<usersWhereUniqueInput>
    update?: Enumerable<usersUpdateWithWhereUniqueWithoutLocationsInput>
    updateMany?: Enumerable<usersUpdateManyWithWhereWithoutLocationsInput>
    deleteMany?: Enumerable<usersScalarWhereInput>
  }

  export type organizationsUncheckedUpdateManyWithoutLocationsNestedInput = {
    create?: XOR<Enumerable<organizationsCreateWithoutLocationsInput>, Enumerable<organizationsUncheckedCreateWithoutLocationsInput>>
    connectOrCreate?: Enumerable<organizationsCreateOrConnectWithoutLocationsInput>
    upsert?: Enumerable<organizationsUpsertWithWhereUniqueWithoutLocationsInput>
    set?: Enumerable<organizationsWhereUniqueInput>
    disconnect?: Enumerable<organizationsWhereUniqueInput>
    delete?: Enumerable<organizationsWhereUniqueInput>
    connect?: Enumerable<organizationsWhereUniqueInput>
    update?: Enumerable<organizationsUpdateWithWhereUniqueWithoutLocationsInput>
    updateMany?: Enumerable<organizationsUpdateManyWithWhereWithoutLocationsInput>
    deleteMany?: Enumerable<organizationsScalarWhereInput>
  }

  export type storesUncheckedUpdateManyWithoutLocationsNestedInput = {
    create?: XOR<Enumerable<storesCreateWithoutLocationsInput>, Enumerable<storesUncheckedCreateWithoutLocationsInput>>
    connectOrCreate?: Enumerable<storesCreateOrConnectWithoutLocationsInput>
    upsert?: Enumerable<storesUpsertWithWhereUniqueWithoutLocationsInput>
    set?: Enumerable<storesWhereUniqueInput>
    disconnect?: Enumerable<storesWhereUniqueInput>
    delete?: Enumerable<storesWhereUniqueInput>
    connect?: Enumerable<storesWhereUniqueInput>
    update?: Enumerable<storesUpdateWithWhereUniqueWithoutLocationsInput>
    updateMany?: Enumerable<storesUpdateManyWithWhereWithoutLocationsInput>
    deleteMany?: Enumerable<storesScalarWhereInput>
  }

  export type usersUncheckedUpdateManyWithoutPrefered_locationNestedInput = {
    create?: XOR<Enumerable<usersCreateWithoutPrefered_locationInput>, Enumerable<usersUncheckedCreateWithoutPrefered_locationInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutPrefered_locationInput>
    upsert?: Enumerable<usersUpsertWithWhereUniqueWithoutPrefered_locationInput>
    createMany?: usersCreateManyPrefered_locationInputEnvelope
    set?: Enumerable<usersWhereUniqueInput>
    disconnect?: Enumerable<usersWhereUniqueInput>
    delete?: Enumerable<usersWhereUniqueInput>
    connect?: Enumerable<usersWhereUniqueInput>
    update?: Enumerable<usersUpdateWithWhereUniqueWithoutPrefered_locationInput>
    updateMany?: Enumerable<usersUpdateManyWithWhereWithoutPrefered_locationInput>
    deleteMany?: Enumerable<usersScalarWhereInput>
  }

  export type usersCreateNestedOneWithoutSessionInput = {
    create?: XOR<usersCreateWithoutSessionInput, usersUncheckedCreateWithoutSessionInput>
    connectOrCreate?: usersCreateOrConnectWithoutSessionInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutSessionNestedInput = {
    create?: XOR<usersCreateWithoutSessionInput, usersUncheckedCreateWithoutSessionInput>
    connectOrCreate?: usersCreateOrConnectWithoutSessionInput
    upsert?: usersUpsertWithoutSessionInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutSessionInput, usersUncheckedUpdateWithoutSessionInput>
  }

  export type platformsCreateNestedManyWithoutImageInput = {
    create?: XOR<Enumerable<platformsCreateWithoutImageInput>, Enumerable<platformsUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<platformsCreateOrConnectWithoutImageInput>
    createMany?: platformsCreateManyImageInputEnvelope
    connect?: Enumerable<platformsWhereUniqueInput>
  }

  export type providersCreateNestedManyWithoutImageInput = {
    create?: XOR<Enumerable<providersCreateWithoutImageInput>, Enumerable<providersUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<providersCreateOrConnectWithoutImageInput>
    createMany?: providersCreateManyImageInputEnvelope
    connect?: Enumerable<providersWhereUniqueInput>
  }

  export type organizationsCreateNestedManyWithoutImageInput = {
    create?: XOR<Enumerable<organizationsCreateWithoutImageInput>, Enumerable<organizationsUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<organizationsCreateOrConnectWithoutImageInput>
    createMany?: organizationsCreateManyImageInputEnvelope
    connect?: Enumerable<organizationsWhereUniqueInput>
  }

  export type storesCreateNestedManyWithoutImageInput = {
    create?: XOR<Enumerable<storesCreateWithoutImageInput>, Enumerable<storesUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<storesCreateOrConnectWithoutImageInput>
    createMany?: storesCreateManyImageInputEnvelope
    connect?: Enumerable<storesWhereUniqueInput>
  }

  export type usersCreateNestedManyWithoutImageInput = {
    create?: XOR<Enumerable<usersCreateWithoutImageInput>, Enumerable<usersUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutImageInput>
    createMany?: usersCreateManyImageInputEnvelope
    connect?: Enumerable<usersWhereUniqueInput>
  }

  export type itemsCreateNestedManyWithoutImagesInput = {
    create?: XOR<Enumerable<itemsCreateWithoutImagesInput>, Enumerable<itemsUncheckedCreateWithoutImagesInput>>
    connectOrCreate?: Enumerable<itemsCreateOrConnectWithoutImagesInput>
    connect?: Enumerable<itemsWhereUniqueInput>
  }

  export type imagesCreateitem_idsInput = {
    set: Enumerable<string>
  }

  export type platformsUncheckedCreateNestedManyWithoutImageInput = {
    create?: XOR<Enumerable<platformsCreateWithoutImageInput>, Enumerable<platformsUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<platformsCreateOrConnectWithoutImageInput>
    createMany?: platformsCreateManyImageInputEnvelope
    connect?: Enumerable<platformsWhereUniqueInput>
  }

  export type providersUncheckedCreateNestedManyWithoutImageInput = {
    create?: XOR<Enumerable<providersCreateWithoutImageInput>, Enumerable<providersUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<providersCreateOrConnectWithoutImageInput>
    createMany?: providersCreateManyImageInputEnvelope
    connect?: Enumerable<providersWhereUniqueInput>
  }

  export type organizationsUncheckedCreateNestedManyWithoutImageInput = {
    create?: XOR<Enumerable<organizationsCreateWithoutImageInput>, Enumerable<organizationsUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<organizationsCreateOrConnectWithoutImageInput>
    createMany?: organizationsCreateManyImageInputEnvelope
    connect?: Enumerable<organizationsWhereUniqueInput>
  }

  export type storesUncheckedCreateNestedManyWithoutImageInput = {
    create?: XOR<Enumerable<storesCreateWithoutImageInput>, Enumerable<storesUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<storesCreateOrConnectWithoutImageInput>
    createMany?: storesCreateManyImageInputEnvelope
    connect?: Enumerable<storesWhereUniqueInput>
  }

  export type usersUncheckedCreateNestedManyWithoutImageInput = {
    create?: XOR<Enumerable<usersCreateWithoutImageInput>, Enumerable<usersUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutImageInput>
    createMany?: usersCreateManyImageInputEnvelope
    connect?: Enumerable<usersWhereUniqueInput>
  }

  export type itemsUncheckedCreateNestedManyWithoutImagesInput = {
    create?: XOR<Enumerable<itemsCreateWithoutImagesInput>, Enumerable<itemsUncheckedCreateWithoutImagesInput>>
    connectOrCreate?: Enumerable<itemsCreateOrConnectWithoutImagesInput>
    connect?: Enumerable<itemsWhereUniqueInput>
  }

  export type platformsUpdateManyWithoutImageNestedInput = {
    create?: XOR<Enumerable<platformsCreateWithoutImageInput>, Enumerable<platformsUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<platformsCreateOrConnectWithoutImageInput>
    upsert?: Enumerable<platformsUpsertWithWhereUniqueWithoutImageInput>
    createMany?: platformsCreateManyImageInputEnvelope
    set?: Enumerable<platformsWhereUniqueInput>
    disconnect?: Enumerable<platformsWhereUniqueInput>
    delete?: Enumerable<platformsWhereUniqueInput>
    connect?: Enumerable<platformsWhereUniqueInput>
    update?: Enumerable<platformsUpdateWithWhereUniqueWithoutImageInput>
    updateMany?: Enumerable<platformsUpdateManyWithWhereWithoutImageInput>
    deleteMany?: Enumerable<platformsScalarWhereInput>
  }

  export type providersUpdateManyWithoutImageNestedInput = {
    create?: XOR<Enumerable<providersCreateWithoutImageInput>, Enumerable<providersUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<providersCreateOrConnectWithoutImageInput>
    upsert?: Enumerable<providersUpsertWithWhereUniqueWithoutImageInput>
    createMany?: providersCreateManyImageInputEnvelope
    set?: Enumerable<providersWhereUniqueInput>
    disconnect?: Enumerable<providersWhereUniqueInput>
    delete?: Enumerable<providersWhereUniqueInput>
    connect?: Enumerable<providersWhereUniqueInput>
    update?: Enumerable<providersUpdateWithWhereUniqueWithoutImageInput>
    updateMany?: Enumerable<providersUpdateManyWithWhereWithoutImageInput>
    deleteMany?: Enumerable<providersScalarWhereInput>
  }

  export type organizationsUpdateManyWithoutImageNestedInput = {
    create?: XOR<Enumerable<organizationsCreateWithoutImageInput>, Enumerable<organizationsUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<organizationsCreateOrConnectWithoutImageInput>
    upsert?: Enumerable<organizationsUpsertWithWhereUniqueWithoutImageInput>
    createMany?: organizationsCreateManyImageInputEnvelope
    set?: Enumerable<organizationsWhereUniqueInput>
    disconnect?: Enumerable<organizationsWhereUniqueInput>
    delete?: Enumerable<organizationsWhereUniqueInput>
    connect?: Enumerable<organizationsWhereUniqueInput>
    update?: Enumerable<organizationsUpdateWithWhereUniqueWithoutImageInput>
    updateMany?: Enumerable<organizationsUpdateManyWithWhereWithoutImageInput>
    deleteMany?: Enumerable<organizationsScalarWhereInput>
  }

  export type storesUpdateManyWithoutImageNestedInput = {
    create?: XOR<Enumerable<storesCreateWithoutImageInput>, Enumerable<storesUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<storesCreateOrConnectWithoutImageInput>
    upsert?: Enumerable<storesUpsertWithWhereUniqueWithoutImageInput>
    createMany?: storesCreateManyImageInputEnvelope
    set?: Enumerable<storesWhereUniqueInput>
    disconnect?: Enumerable<storesWhereUniqueInput>
    delete?: Enumerable<storesWhereUniqueInput>
    connect?: Enumerable<storesWhereUniqueInput>
    update?: Enumerable<storesUpdateWithWhereUniqueWithoutImageInput>
    updateMany?: Enumerable<storesUpdateManyWithWhereWithoutImageInput>
    deleteMany?: Enumerable<storesScalarWhereInput>
  }

  export type usersUpdateManyWithoutImageNestedInput = {
    create?: XOR<Enumerable<usersCreateWithoutImageInput>, Enumerable<usersUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutImageInput>
    upsert?: Enumerable<usersUpsertWithWhereUniqueWithoutImageInput>
    createMany?: usersCreateManyImageInputEnvelope
    set?: Enumerable<usersWhereUniqueInput>
    disconnect?: Enumerable<usersWhereUniqueInput>
    delete?: Enumerable<usersWhereUniqueInput>
    connect?: Enumerable<usersWhereUniqueInput>
    update?: Enumerable<usersUpdateWithWhereUniqueWithoutImageInput>
    updateMany?: Enumerable<usersUpdateManyWithWhereWithoutImageInput>
    deleteMany?: Enumerable<usersScalarWhereInput>
  }

  export type itemsUpdateManyWithoutImagesNestedInput = {
    create?: XOR<Enumerable<itemsCreateWithoutImagesInput>, Enumerable<itemsUncheckedCreateWithoutImagesInput>>
    connectOrCreate?: Enumerable<itemsCreateOrConnectWithoutImagesInput>
    upsert?: Enumerable<itemsUpsertWithWhereUniqueWithoutImagesInput>
    set?: Enumerable<itemsWhereUniqueInput>
    disconnect?: Enumerable<itemsWhereUniqueInput>
    delete?: Enumerable<itemsWhereUniqueInput>
    connect?: Enumerable<itemsWhereUniqueInput>
    update?: Enumerable<itemsUpdateWithWhereUniqueWithoutImagesInput>
    updateMany?: Enumerable<itemsUpdateManyWithWhereWithoutImagesInput>
    deleteMany?: Enumerable<itemsScalarWhereInput>
  }

  export type imagesUpdateitem_idsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type platformsUncheckedUpdateManyWithoutImageNestedInput = {
    create?: XOR<Enumerable<platformsCreateWithoutImageInput>, Enumerable<platformsUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<platformsCreateOrConnectWithoutImageInput>
    upsert?: Enumerable<platformsUpsertWithWhereUniqueWithoutImageInput>
    createMany?: platformsCreateManyImageInputEnvelope
    set?: Enumerable<platformsWhereUniqueInput>
    disconnect?: Enumerable<platformsWhereUniqueInput>
    delete?: Enumerable<platformsWhereUniqueInput>
    connect?: Enumerable<platformsWhereUniqueInput>
    update?: Enumerable<platformsUpdateWithWhereUniqueWithoutImageInput>
    updateMany?: Enumerable<platformsUpdateManyWithWhereWithoutImageInput>
    deleteMany?: Enumerable<platformsScalarWhereInput>
  }

  export type providersUncheckedUpdateManyWithoutImageNestedInput = {
    create?: XOR<Enumerable<providersCreateWithoutImageInput>, Enumerable<providersUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<providersCreateOrConnectWithoutImageInput>
    upsert?: Enumerable<providersUpsertWithWhereUniqueWithoutImageInput>
    createMany?: providersCreateManyImageInputEnvelope
    set?: Enumerable<providersWhereUniqueInput>
    disconnect?: Enumerable<providersWhereUniqueInput>
    delete?: Enumerable<providersWhereUniqueInput>
    connect?: Enumerable<providersWhereUniqueInput>
    update?: Enumerable<providersUpdateWithWhereUniqueWithoutImageInput>
    updateMany?: Enumerable<providersUpdateManyWithWhereWithoutImageInput>
    deleteMany?: Enumerable<providersScalarWhereInput>
  }

  export type organizationsUncheckedUpdateManyWithoutImageNestedInput = {
    create?: XOR<Enumerable<organizationsCreateWithoutImageInput>, Enumerable<organizationsUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<organizationsCreateOrConnectWithoutImageInput>
    upsert?: Enumerable<organizationsUpsertWithWhereUniqueWithoutImageInput>
    createMany?: organizationsCreateManyImageInputEnvelope
    set?: Enumerable<organizationsWhereUniqueInput>
    disconnect?: Enumerable<organizationsWhereUniqueInput>
    delete?: Enumerable<organizationsWhereUniqueInput>
    connect?: Enumerable<organizationsWhereUniqueInput>
    update?: Enumerable<organizationsUpdateWithWhereUniqueWithoutImageInput>
    updateMany?: Enumerable<organizationsUpdateManyWithWhereWithoutImageInput>
    deleteMany?: Enumerable<organizationsScalarWhereInput>
  }

  export type storesUncheckedUpdateManyWithoutImageNestedInput = {
    create?: XOR<Enumerable<storesCreateWithoutImageInput>, Enumerable<storesUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<storesCreateOrConnectWithoutImageInput>
    upsert?: Enumerable<storesUpsertWithWhereUniqueWithoutImageInput>
    createMany?: storesCreateManyImageInputEnvelope
    set?: Enumerable<storesWhereUniqueInput>
    disconnect?: Enumerable<storesWhereUniqueInput>
    delete?: Enumerable<storesWhereUniqueInput>
    connect?: Enumerable<storesWhereUniqueInput>
    update?: Enumerable<storesUpdateWithWhereUniqueWithoutImageInput>
    updateMany?: Enumerable<storesUpdateManyWithWhereWithoutImageInput>
    deleteMany?: Enumerable<storesScalarWhereInput>
  }

  export type usersUncheckedUpdateManyWithoutImageNestedInput = {
    create?: XOR<Enumerable<usersCreateWithoutImageInput>, Enumerable<usersUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutImageInput>
    upsert?: Enumerable<usersUpsertWithWhereUniqueWithoutImageInput>
    createMany?: usersCreateManyImageInputEnvelope
    set?: Enumerable<usersWhereUniqueInput>
    disconnect?: Enumerable<usersWhereUniqueInput>
    delete?: Enumerable<usersWhereUniqueInput>
    connect?: Enumerable<usersWhereUniqueInput>
    update?: Enumerable<usersUpdateWithWhereUniqueWithoutImageInput>
    updateMany?: Enumerable<usersUpdateManyWithWhereWithoutImageInput>
    deleteMany?: Enumerable<usersScalarWhereInput>
  }

  export type itemsUncheckedUpdateManyWithoutImagesNestedInput = {
    create?: XOR<Enumerable<itemsCreateWithoutImagesInput>, Enumerable<itemsUncheckedCreateWithoutImagesInput>>
    connectOrCreate?: Enumerable<itemsCreateOrConnectWithoutImagesInput>
    upsert?: Enumerable<itemsUpsertWithWhereUniqueWithoutImagesInput>
    set?: Enumerable<itemsWhereUniqueInput>
    disconnect?: Enumerable<itemsWhereUniqueInput>
    delete?: Enumerable<itemsWhereUniqueInput>
    connect?: Enumerable<itemsWhereUniqueInput>
    update?: Enumerable<itemsUpdateWithWhereUniqueWithoutImagesInput>
    updateMany?: Enumerable<itemsUpdateManyWithWhereWithoutImagesInput>
    deleteMany?: Enumerable<itemsScalarWhereInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
    isSet?: boolean
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
    isSet?: boolean
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
    isSet?: boolean
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
    isSet?: boolean
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    isSet?: boolean
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedEnumGenderTypeNullableFilter = {
    equals?: GenderType | null
    in?: Enumerable<GenderType> | null
    notIn?: Enumerable<GenderType> | null
    not?: NestedEnumGenderTypeNullableFilter | GenderType | null
    isSet?: boolean
  }

  export type NestedEnumGenderTypeNullableWithAggregatesFilter = {
    equals?: GenderType | null
    in?: Enumerable<GenderType> | null
    notIn?: Enumerable<GenderType> | null
    not?: NestedEnumGenderTypeNullableWithAggregatesFilter | GenderType | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumGenderTypeNullableFilter
    _max?: NestedEnumGenderTypeNullableFilter
    isSet?: boolean
  }

  export type NestedEnumItemQualitativeTypeFilter = {
    equals?: ItemQualitativeType
    in?: Enumerable<ItemQualitativeType>
    notIn?: Enumerable<ItemQualitativeType>
    not?: NestedEnumItemQualitativeTypeFilter | ItemQualitativeType
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedEnumItemQualitativeTypeWithAggregatesFilter = {
    equals?: ItemQualitativeType
    in?: Enumerable<ItemQualitativeType>
    notIn?: Enumerable<ItemQualitativeType>
    not?: NestedEnumItemQualitativeTypeWithAggregatesFilter | ItemQualitativeType
    _count?: NestedIntFilter
    _min?: NestedEnumItemQualitativeTypeFilter
    _max?: NestedEnumItemQualitativeTypeFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type CurrencyWhereInput = {
    AND?: Enumerable<CurrencyWhereInput>
    OR?: Enumerable<CurrencyWhereInput>
    NOT?: Enumerable<CurrencyWhereInput>
    amount?: FloatFilter | number
    currency?: EnumCurrencyTypeFilter | CurrencyType
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
    isSet?: boolean
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
    isSet?: boolean
  }

  export type imagesCreateWithoutPlatformsInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    key: string
    url?: string | null
    clipped_key?: string | null
    clipped_url?: string | null
    providers?: providersCreateNestedManyWithoutImageInput
    organizations?: organizationsCreateNestedManyWithoutImageInput
    stores?: storesCreateNestedManyWithoutImageInput
    users?: usersCreateNestedManyWithoutImageInput
    items?: itemsCreateNestedManyWithoutImagesInput
  }

  export type imagesUncheckedCreateWithoutPlatformsInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    key: string
    url?: string | null
    clipped_key?: string | null
    clipped_url?: string | null
    item_ids?: imagesCreateitem_idsInput | Enumerable<string>
    providers?: providersUncheckedCreateNestedManyWithoutImageInput
    organizations?: organizationsUncheckedCreateNestedManyWithoutImageInput
    stores?: storesUncheckedCreateNestedManyWithoutImageInput
    users?: usersUncheckedCreateNestedManyWithoutImageInput
    items?: itemsUncheckedCreateNestedManyWithoutImagesInput
  }

  export type imagesCreateOrConnectWithoutPlatformsInput = {
    where: imagesWhereUniqueInput
    create: XOR<imagesCreateWithoutPlatformsInput, imagesUncheckedCreateWithoutPlatformsInput>
  }

  export type providersCreateWithoutPlatformsInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    key: string
    name?: string | null
    provider_key_ids?: providersCreateprovider_key_idsInput | Enumerable<string>
    image?: imagesCreateNestedOneWithoutProvidersInput
    provider_keys?: provider_keysCreateNestedManyWithoutProviderInput
  }

  export type providersUncheckedCreateWithoutPlatformsInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    key: string
    name?: string | null
    image_id?: string | null
    platform_ids?: providersCreateplatform_idsInput | Enumerable<string>
    provider_key_ids?: providersCreateprovider_key_idsInput | Enumerable<string>
    provider_keys?: provider_keysUncheckedCreateNestedManyWithoutProviderInput
  }

  export type providersCreateOrConnectWithoutPlatformsInput = {
    where: providersWhereUniqueInput
    create: XOR<providersCreateWithoutPlatformsInput, providersUncheckedCreateWithoutPlatformsInput>
  }

  export type provider_keysCreateWithoutPlatformsInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    public_key: string
    private_key: string
    secret: boolean
    description?: string | null
    provider: providersCreateNestedOneWithoutProvider_keysInput
  }

  export type provider_keysUncheckedCreateWithoutPlatformsInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    public_key: string
    private_key: string
    secret: boolean
    description?: string | null
    provider_id: string
    platform_ids?: provider_keysCreateplatform_idsInput | Enumerable<string>
  }

  export type provider_keysCreateOrConnectWithoutPlatformsInput = {
    where: provider_keysWhereUniqueInput
    create: XOR<provider_keysCreateWithoutPlatformsInput, provider_keysUncheckedCreateWithoutPlatformsInput>
  }

  export type usersCreateWithoutPlatformsInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    email?: string | null
    phone?: string | null
    name?: string | null
    birthDate?: Date | string | null
    gender?: GenderType | null
    image?: imagesCreateNestedOneWithoutUsersInput
    prefered_location?: locationsCreateNestedOneWithoutUsers_preferedInput
    locations?: locationsCreateNestedManyWithoutUsersInput
    organizations?: organizationsCreateNestedManyWithoutUsersInput
    stores?: storesCreateNestedManyWithoutUsersInput
    payments_created?: paymentCreateNestedManyWithoutUser_creatorInput
    payments_confirmed?: paymentCreateNestedManyWithoutUser_confirmInput
    session?: sessionsCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutPlatformsInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    email?: string | null
    phone?: string | null
    name?: string | null
    birthDate?: Date | string | null
    gender?: GenderType | null
    image_id?: string | null
    prefered_location_id?: string | null
    location_ids?: usersCreatelocation_idsInput | Enumerable<string>
    platform_ids?: usersCreateplatform_idsInput | Enumerable<string>
    organization_ids?: usersCreateorganization_idsInput | Enumerable<string>
    store_ids?: usersCreatestore_idsInput | Enumerable<string>
    locations?: locationsUncheckedCreateNestedManyWithoutUsersInput
    organizations?: organizationsUncheckedCreateNestedManyWithoutUsersInput
    stores?: storesUncheckedCreateNestedManyWithoutUsersInput
    payments_created?: paymentUncheckedCreateNestedManyWithoutUser_creatorInput
    payments_confirmed?: paymentUncheckedCreateNestedManyWithoutUser_confirmInput
    session?: sessionsUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutPlatformsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutPlatformsInput, usersUncheckedCreateWithoutPlatformsInput>
  }

  export type organizationsCreateWithoutPlatformsInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    name?: string | null
    image?: imagesCreateNestedOneWithoutOrganizationsInput
    users?: usersCreateNestedManyWithoutOrganizationsInput
    locations?: locationsCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsUncheckedCreateWithoutPlatformsInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    name?: string | null
    image_id?: string | null
    platform_ids?: organizationsCreateplatform_idsInput | Enumerable<string>
    user_ids?: organizationsCreateuser_idsInput | Enumerable<string>
    location_ids?: organizationsCreatelocation_idsInput | Enumerable<string>
    users?: usersUncheckedCreateNestedManyWithoutOrganizationsInput
    locations?: locationsUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsCreateOrConnectWithoutPlatformsInput = {
    where: organizationsWhereUniqueInput
    create: XOR<organizationsCreateWithoutPlatformsInput, organizationsUncheckedCreateWithoutPlatformsInput>
  }

  export type imagesUpsertWithoutPlatformsInput = {
    update: XOR<imagesUpdateWithoutPlatformsInput, imagesUncheckedUpdateWithoutPlatformsInput>
    create: XOR<imagesCreateWithoutPlatformsInput, imagesUncheckedCreateWithoutPlatformsInput>
  }

  export type imagesUpdateWithoutPlatformsInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_key?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_url?: NullableStringFieldUpdateOperationsInput | string | null
    providers?: providersUpdateManyWithoutImageNestedInput
    organizations?: organizationsUpdateManyWithoutImageNestedInput
    stores?: storesUpdateManyWithoutImageNestedInput
    users?: usersUpdateManyWithoutImageNestedInput
    items?: itemsUpdateManyWithoutImagesNestedInput
  }

  export type imagesUncheckedUpdateWithoutPlatformsInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_key?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_url?: NullableStringFieldUpdateOperationsInput | string | null
    item_ids?: imagesUpdateitem_idsInput | Enumerable<string>
    providers?: providersUncheckedUpdateManyWithoutImageNestedInput
    organizations?: organizationsUncheckedUpdateManyWithoutImageNestedInput
    stores?: storesUncheckedUpdateManyWithoutImageNestedInput
    users?: usersUncheckedUpdateManyWithoutImageNestedInput
    items?: itemsUncheckedUpdateManyWithoutImagesNestedInput
  }

  export type providersUpsertWithWhereUniqueWithoutPlatformsInput = {
    where: providersWhereUniqueInput
    update: XOR<providersUpdateWithoutPlatformsInput, providersUncheckedUpdateWithoutPlatformsInput>
    create: XOR<providersCreateWithoutPlatformsInput, providersUncheckedCreateWithoutPlatformsInput>
  }

  export type providersUpdateWithWhereUniqueWithoutPlatformsInput = {
    where: providersWhereUniqueInput
    data: XOR<providersUpdateWithoutPlatformsInput, providersUncheckedUpdateWithoutPlatformsInput>
  }

  export type providersUpdateManyWithWhereWithoutPlatformsInput = {
    where: providersScalarWhereInput
    data: XOR<providersUpdateManyMutationInput, providersUncheckedUpdateManyWithoutProvidersInput>
  }

  export type providersScalarWhereInput = {
    AND?: Enumerable<providersScalarWhereInput>
    OR?: Enumerable<providersScalarWhereInput>
    NOT?: Enumerable<providersScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
    key?: StringFilter | string
    name?: StringNullableFilter | string | null
    image_id?: StringNullableFilter | string | null
    platform_ids?: StringNullableListFilter
    provider_key_ids?: StringNullableListFilter
  }

  export type provider_keysUpsertWithWhereUniqueWithoutPlatformsInput = {
    where: provider_keysWhereUniqueInput
    update: XOR<provider_keysUpdateWithoutPlatformsInput, provider_keysUncheckedUpdateWithoutPlatformsInput>
    create: XOR<provider_keysCreateWithoutPlatformsInput, provider_keysUncheckedCreateWithoutPlatformsInput>
  }

  export type provider_keysUpdateWithWhereUniqueWithoutPlatformsInput = {
    where: provider_keysWhereUniqueInput
    data: XOR<provider_keysUpdateWithoutPlatformsInput, provider_keysUncheckedUpdateWithoutPlatformsInput>
  }

  export type provider_keysUpdateManyWithWhereWithoutPlatformsInput = {
    where: provider_keysScalarWhereInput
    data: XOR<provider_keysUpdateManyMutationInput, provider_keysUncheckedUpdateManyWithoutProvider_keysInput>
  }

  export type provider_keysScalarWhereInput = {
    AND?: Enumerable<provider_keysScalarWhereInput>
    OR?: Enumerable<provider_keysScalarWhereInput>
    NOT?: Enumerable<provider_keysScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
    public_key?: StringFilter | string
    private_key?: StringFilter | string
    secret?: BoolFilter | boolean
    description?: StringNullableFilter | string | null
    provider_id?: StringFilter | string
    platform_ids?: StringNullableListFilter
  }

  export type usersUpsertWithWhereUniqueWithoutPlatformsInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutPlatformsInput, usersUncheckedUpdateWithoutPlatformsInput>
    create: XOR<usersCreateWithoutPlatformsInput, usersUncheckedCreateWithoutPlatformsInput>
  }

  export type usersUpdateWithWhereUniqueWithoutPlatformsInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutPlatformsInput, usersUncheckedUpdateWithoutPlatformsInput>
  }

  export type usersUpdateManyWithWhereWithoutPlatformsInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutUsersInput>
  }

  export type usersScalarWhereInput = {
    AND?: Enumerable<usersScalarWhereInput>
    OR?: Enumerable<usersScalarWhereInput>
    NOT?: Enumerable<usersScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
    username?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    birthDate?: DateTimeNullableFilter | Date | string | null
    gender?: EnumGenderTypeNullableFilter | GenderType | null
    image_id?: StringNullableFilter | string | null
    prefered_location_id?: StringNullableFilter | string | null
    location_ids?: StringNullableListFilter
    platform_ids?: StringNullableListFilter
    organization_ids?: StringNullableListFilter
    store_ids?: StringNullableListFilter
  }

  export type organizationsUpsertWithWhereUniqueWithoutPlatformsInput = {
    where: organizationsWhereUniqueInput
    update: XOR<organizationsUpdateWithoutPlatformsInput, organizationsUncheckedUpdateWithoutPlatformsInput>
    create: XOR<organizationsCreateWithoutPlatformsInput, organizationsUncheckedCreateWithoutPlatformsInput>
  }

  export type organizationsUpdateWithWhereUniqueWithoutPlatformsInput = {
    where: organizationsWhereUniqueInput
    data: XOR<organizationsUpdateWithoutPlatformsInput, organizationsUncheckedUpdateWithoutPlatformsInput>
  }

  export type organizationsUpdateManyWithWhereWithoutPlatformsInput = {
    where: organizationsScalarWhereInput
    data: XOR<organizationsUpdateManyMutationInput, organizationsUncheckedUpdateManyWithoutOrganizationsInput>
  }

  export type organizationsScalarWhereInput = {
    AND?: Enumerable<organizationsScalarWhereInput>
    OR?: Enumerable<organizationsScalarWhereInput>
    NOT?: Enumerable<organizationsScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
    username?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    image_id?: StringNullableFilter | string | null
    platform_ids?: StringNullableListFilter
    user_ids?: StringNullableListFilter
    location_ids?: StringNullableListFilter
  }

  export type imagesCreateWithoutProvidersInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    key: string
    url?: string | null
    clipped_key?: string | null
    clipped_url?: string | null
    platforms?: platformsCreateNestedManyWithoutImageInput
    organizations?: organizationsCreateNestedManyWithoutImageInput
    stores?: storesCreateNestedManyWithoutImageInput
    users?: usersCreateNestedManyWithoutImageInput
    items?: itemsCreateNestedManyWithoutImagesInput
  }

  export type imagesUncheckedCreateWithoutProvidersInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    key: string
    url?: string | null
    clipped_key?: string | null
    clipped_url?: string | null
    item_ids?: imagesCreateitem_idsInput | Enumerable<string>
    platforms?: platformsUncheckedCreateNestedManyWithoutImageInput
    organizations?: organizationsUncheckedCreateNestedManyWithoutImageInput
    stores?: storesUncheckedCreateNestedManyWithoutImageInput
    users?: usersUncheckedCreateNestedManyWithoutImageInput
    items?: itemsUncheckedCreateNestedManyWithoutImagesInput
  }

  export type imagesCreateOrConnectWithoutProvidersInput = {
    where: imagesWhereUniqueInput
    create: XOR<imagesCreateWithoutProvidersInput, imagesUncheckedCreateWithoutProvidersInput>
  }

  export type platformsCreateWithoutProvidersInput = {
    id?: string
    uuid?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    key: string
    username?: string | null
    name?: string | null
    image?: imagesCreateNestedOneWithoutPlatformsInput
    provider_keys?: provider_keysCreateNestedManyWithoutPlatformsInput
    users?: usersCreateNestedManyWithoutPlatformsInput
    organizations?: organizationsCreateNestedManyWithoutPlatformsInput
  }

  export type platformsUncheckedCreateWithoutProvidersInput = {
    id?: string
    uuid?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    key: string
    username?: string | null
    name?: string | null
    image_id?: string | null
    provider_ids?: platformsCreateprovider_idsInput | Enumerable<string>
    provider_key_ids?: platformsCreateprovider_key_idsInput | Enumerable<string>
    user_ids?: platformsCreateuser_idsInput | Enumerable<string>
    organization_ids?: platformsCreateorganization_idsInput | Enumerable<string>
    provider_keys?: provider_keysUncheckedCreateNestedManyWithoutPlatformsInput
    users?: usersUncheckedCreateNestedManyWithoutPlatformsInput
    organizations?: organizationsUncheckedCreateNestedManyWithoutPlatformsInput
  }

  export type platformsCreateOrConnectWithoutProvidersInput = {
    where: platformsWhereUniqueInput
    create: XOR<platformsCreateWithoutProvidersInput, platformsUncheckedCreateWithoutProvidersInput>
  }

  export type provider_keysCreateWithoutProviderInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    public_key: string
    private_key: string
    secret: boolean
    description?: string | null
    platforms?: platformsCreateNestedManyWithoutProvider_keysInput
  }

  export type provider_keysUncheckedCreateWithoutProviderInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    public_key: string
    private_key: string
    secret: boolean
    description?: string | null
    platform_ids?: provider_keysCreateplatform_idsInput | Enumerable<string>
    platforms?: platformsUncheckedCreateNestedManyWithoutProvider_keysInput
  }

  export type provider_keysCreateOrConnectWithoutProviderInput = {
    where: provider_keysWhereUniqueInput
    create: XOR<provider_keysCreateWithoutProviderInput, provider_keysUncheckedCreateWithoutProviderInput>
  }

  export type provider_keysCreateManyProviderInputEnvelope = {
    data: Enumerable<provider_keysCreateManyProviderInput>
  }

  export type imagesUpsertWithoutProvidersInput = {
    update: XOR<imagesUpdateWithoutProvidersInput, imagesUncheckedUpdateWithoutProvidersInput>
    create: XOR<imagesCreateWithoutProvidersInput, imagesUncheckedCreateWithoutProvidersInput>
  }

  export type imagesUpdateWithoutProvidersInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_key?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_url?: NullableStringFieldUpdateOperationsInput | string | null
    platforms?: platformsUpdateManyWithoutImageNestedInput
    organizations?: organizationsUpdateManyWithoutImageNestedInput
    stores?: storesUpdateManyWithoutImageNestedInput
    users?: usersUpdateManyWithoutImageNestedInput
    items?: itemsUpdateManyWithoutImagesNestedInput
  }

  export type imagesUncheckedUpdateWithoutProvidersInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_key?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_url?: NullableStringFieldUpdateOperationsInput | string | null
    item_ids?: imagesUpdateitem_idsInput | Enumerable<string>
    platforms?: platformsUncheckedUpdateManyWithoutImageNestedInput
    organizations?: organizationsUncheckedUpdateManyWithoutImageNestedInput
    stores?: storesUncheckedUpdateManyWithoutImageNestedInput
    users?: usersUncheckedUpdateManyWithoutImageNestedInput
    items?: itemsUncheckedUpdateManyWithoutImagesNestedInput
  }

  export type platformsUpsertWithWhereUniqueWithoutProvidersInput = {
    where: platformsWhereUniqueInput
    update: XOR<platformsUpdateWithoutProvidersInput, platformsUncheckedUpdateWithoutProvidersInput>
    create: XOR<platformsCreateWithoutProvidersInput, platformsUncheckedCreateWithoutProvidersInput>
  }

  export type platformsUpdateWithWhereUniqueWithoutProvidersInput = {
    where: platformsWhereUniqueInput
    data: XOR<platformsUpdateWithoutProvidersInput, platformsUncheckedUpdateWithoutProvidersInput>
  }

  export type platformsUpdateManyWithWhereWithoutProvidersInput = {
    where: platformsScalarWhereInput
    data: XOR<platformsUpdateManyMutationInput, platformsUncheckedUpdateManyWithoutPlatformsInput>
  }

  export type platformsScalarWhereInput = {
    AND?: Enumerable<platformsScalarWhereInput>
    OR?: Enumerable<platformsScalarWhereInput>
    NOT?: Enumerable<platformsScalarWhereInput>
    id?: StringFilter | string
    uuid?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    key?: StringFilter | string
    username?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    image_id?: StringNullableFilter | string | null
    provider_ids?: StringNullableListFilter
    provider_key_ids?: StringNullableListFilter
    user_ids?: StringNullableListFilter
    organization_ids?: StringNullableListFilter
  }

  export type provider_keysUpsertWithWhereUniqueWithoutProviderInput = {
    where: provider_keysWhereUniqueInput
    update: XOR<provider_keysUpdateWithoutProviderInput, provider_keysUncheckedUpdateWithoutProviderInput>
    create: XOR<provider_keysCreateWithoutProviderInput, provider_keysUncheckedCreateWithoutProviderInput>
  }

  export type provider_keysUpdateWithWhereUniqueWithoutProviderInput = {
    where: provider_keysWhereUniqueInput
    data: XOR<provider_keysUpdateWithoutProviderInput, provider_keysUncheckedUpdateWithoutProviderInput>
  }

  export type provider_keysUpdateManyWithWhereWithoutProviderInput = {
    where: provider_keysScalarWhereInput
    data: XOR<provider_keysUpdateManyMutationInput, provider_keysUncheckedUpdateManyWithoutProvider_keysInput>
  }

  export type providersCreateWithoutProvider_keysInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    key: string
    name?: string | null
    provider_key_ids?: providersCreateprovider_key_idsInput | Enumerable<string>
    image?: imagesCreateNestedOneWithoutProvidersInput
    platforms?: platformsCreateNestedManyWithoutProvidersInput
  }

  export type providersUncheckedCreateWithoutProvider_keysInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    key: string
    name?: string | null
    image_id?: string | null
    platform_ids?: providersCreateplatform_idsInput | Enumerable<string>
    provider_key_ids?: providersCreateprovider_key_idsInput | Enumerable<string>
    platforms?: platformsUncheckedCreateNestedManyWithoutProvidersInput
  }

  export type providersCreateOrConnectWithoutProvider_keysInput = {
    where: providersWhereUniqueInput
    create: XOR<providersCreateWithoutProvider_keysInput, providersUncheckedCreateWithoutProvider_keysInput>
  }

  export type platformsCreateWithoutProvider_keysInput = {
    id?: string
    uuid?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    key: string
    username?: string | null
    name?: string | null
    image?: imagesCreateNestedOneWithoutPlatformsInput
    providers?: providersCreateNestedManyWithoutPlatformsInput
    users?: usersCreateNestedManyWithoutPlatformsInput
    organizations?: organizationsCreateNestedManyWithoutPlatformsInput
  }

  export type platformsUncheckedCreateWithoutProvider_keysInput = {
    id?: string
    uuid?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    key: string
    username?: string | null
    name?: string | null
    image_id?: string | null
    provider_ids?: platformsCreateprovider_idsInput | Enumerable<string>
    provider_key_ids?: platformsCreateprovider_key_idsInput | Enumerable<string>
    user_ids?: platformsCreateuser_idsInput | Enumerable<string>
    organization_ids?: platformsCreateorganization_idsInput | Enumerable<string>
    providers?: providersUncheckedCreateNestedManyWithoutPlatformsInput
    users?: usersUncheckedCreateNestedManyWithoutPlatformsInput
    organizations?: organizationsUncheckedCreateNestedManyWithoutPlatformsInput
  }

  export type platformsCreateOrConnectWithoutProvider_keysInput = {
    where: platformsWhereUniqueInput
    create: XOR<platformsCreateWithoutProvider_keysInput, platformsUncheckedCreateWithoutProvider_keysInput>
  }

  export type providersUpsertWithoutProvider_keysInput = {
    update: XOR<providersUpdateWithoutProvider_keysInput, providersUncheckedUpdateWithoutProvider_keysInput>
    create: XOR<providersCreateWithoutProvider_keysInput, providersUncheckedCreateWithoutProvider_keysInput>
  }

  export type providersUpdateWithoutProvider_keysInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    provider_key_ids?: providersUpdateprovider_key_idsInput | Enumerable<string>
    image?: imagesUpdateOneWithoutProvidersNestedInput
    platforms?: platformsUpdateManyWithoutProvidersNestedInput
  }

  export type providersUncheckedUpdateWithoutProvider_keysInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    platform_ids?: providersUpdateplatform_idsInput | Enumerable<string>
    provider_key_ids?: providersUpdateprovider_key_idsInput | Enumerable<string>
    platforms?: platformsUncheckedUpdateManyWithoutProvidersNestedInput
  }

  export type platformsUpsertWithWhereUniqueWithoutProvider_keysInput = {
    where: platformsWhereUniqueInput
    update: XOR<platformsUpdateWithoutProvider_keysInput, platformsUncheckedUpdateWithoutProvider_keysInput>
    create: XOR<platformsCreateWithoutProvider_keysInput, platformsUncheckedCreateWithoutProvider_keysInput>
  }

  export type platformsUpdateWithWhereUniqueWithoutProvider_keysInput = {
    where: platformsWhereUniqueInput
    data: XOR<platformsUpdateWithoutProvider_keysInput, platformsUncheckedUpdateWithoutProvider_keysInput>
  }

  export type platformsUpdateManyWithWhereWithoutProvider_keysInput = {
    where: platformsScalarWhereInput
    data: XOR<platformsUpdateManyMutationInput, platformsUncheckedUpdateManyWithoutPlatformsInput>
  }

  export type imagesCreateWithoutUsersInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    key: string
    url?: string | null
    clipped_key?: string | null
    clipped_url?: string | null
    platforms?: platformsCreateNestedManyWithoutImageInput
    providers?: providersCreateNestedManyWithoutImageInput
    organizations?: organizationsCreateNestedManyWithoutImageInput
    stores?: storesCreateNestedManyWithoutImageInput
    items?: itemsCreateNestedManyWithoutImagesInput
  }

  export type imagesUncheckedCreateWithoutUsersInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    key: string
    url?: string | null
    clipped_key?: string | null
    clipped_url?: string | null
    item_ids?: imagesCreateitem_idsInput | Enumerable<string>
    platforms?: platformsUncheckedCreateNestedManyWithoutImageInput
    providers?: providersUncheckedCreateNestedManyWithoutImageInput
    organizations?: organizationsUncheckedCreateNestedManyWithoutImageInput
    stores?: storesUncheckedCreateNestedManyWithoutImageInput
    items?: itemsUncheckedCreateNestedManyWithoutImagesInput
  }

  export type imagesCreateOrConnectWithoutUsersInput = {
    where: imagesWhereUniqueInput
    create: XOR<imagesCreateWithoutUsersInput, imagesUncheckedCreateWithoutUsersInput>
  }

  export type locationsCreateWithoutUsers_preferedInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    name?: string | null
    latitude?: number | null
    longitude?: number | null
    store_ids?: locationsCreatestore_idsInput | Enumerable<string>
    users?: usersCreateNestedManyWithoutLocationsInput
    organizations?: organizationsCreateNestedManyWithoutLocationsInput
    stores?: storesCreateNestedManyWithoutLocationsInput
  }

  export type locationsUncheckedCreateWithoutUsers_preferedInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    name?: string | null
    latitude?: number | null
    longitude?: number | null
    user_ids?: locationsCreateuser_idsInput | Enumerable<string>
    organizations_ids?: locationsCreateorganizations_idsInput | Enumerable<string>
    store_ids?: locationsCreatestore_idsInput | Enumerable<string>
    users?: usersUncheckedCreateNestedManyWithoutLocationsInput
    organizations?: organizationsUncheckedCreateNestedManyWithoutLocationsInput
    stores?: storesUncheckedCreateNestedManyWithoutLocationsInput
  }

  export type locationsCreateOrConnectWithoutUsers_preferedInput = {
    where: locationsWhereUniqueInput
    create: XOR<locationsCreateWithoutUsers_preferedInput, locationsUncheckedCreateWithoutUsers_preferedInput>
  }

  export type locationsCreateWithoutUsersInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    name?: string | null
    latitude?: number | null
    longitude?: number | null
    store_ids?: locationsCreatestore_idsInput | Enumerable<string>
    organizations?: organizationsCreateNestedManyWithoutLocationsInput
    stores?: storesCreateNestedManyWithoutLocationsInput
    users_prefered?: usersCreateNestedManyWithoutPrefered_locationInput
  }

  export type locationsUncheckedCreateWithoutUsersInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    name?: string | null
    latitude?: number | null
    longitude?: number | null
    user_ids?: locationsCreateuser_idsInput | Enumerable<string>
    organizations_ids?: locationsCreateorganizations_idsInput | Enumerable<string>
    store_ids?: locationsCreatestore_idsInput | Enumerable<string>
    organizations?: organizationsUncheckedCreateNestedManyWithoutLocationsInput
    stores?: storesUncheckedCreateNestedManyWithoutLocationsInput
    users_prefered?: usersUncheckedCreateNestedManyWithoutPrefered_locationInput
  }

  export type locationsCreateOrConnectWithoutUsersInput = {
    where: locationsWhereUniqueInput
    create: XOR<locationsCreateWithoutUsersInput, locationsUncheckedCreateWithoutUsersInput>
  }

  export type platformsCreateWithoutUsersInput = {
    id?: string
    uuid?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    key: string
    username?: string | null
    name?: string | null
    image?: imagesCreateNestedOneWithoutPlatformsInput
    providers?: providersCreateNestedManyWithoutPlatformsInput
    provider_keys?: provider_keysCreateNestedManyWithoutPlatformsInput
    organizations?: organizationsCreateNestedManyWithoutPlatformsInput
  }

  export type platformsUncheckedCreateWithoutUsersInput = {
    id?: string
    uuid?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    key: string
    username?: string | null
    name?: string | null
    image_id?: string | null
    provider_ids?: platformsCreateprovider_idsInput | Enumerable<string>
    provider_key_ids?: platformsCreateprovider_key_idsInput | Enumerable<string>
    user_ids?: platformsCreateuser_idsInput | Enumerable<string>
    organization_ids?: platformsCreateorganization_idsInput | Enumerable<string>
    providers?: providersUncheckedCreateNestedManyWithoutPlatformsInput
    provider_keys?: provider_keysUncheckedCreateNestedManyWithoutPlatformsInput
    organizations?: organizationsUncheckedCreateNestedManyWithoutPlatformsInput
  }

  export type platformsCreateOrConnectWithoutUsersInput = {
    where: platformsWhereUniqueInput
    create: XOR<platformsCreateWithoutUsersInput, platformsUncheckedCreateWithoutUsersInput>
  }

  export type organizationsCreateWithoutUsersInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    name?: string | null
    image?: imagesCreateNestedOneWithoutOrganizationsInput
    platforms?: platformsCreateNestedManyWithoutOrganizationsInput
    locations?: locationsCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsUncheckedCreateWithoutUsersInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    name?: string | null
    image_id?: string | null
    platform_ids?: organizationsCreateplatform_idsInput | Enumerable<string>
    user_ids?: organizationsCreateuser_idsInput | Enumerable<string>
    location_ids?: organizationsCreatelocation_idsInput | Enumerable<string>
    platforms?: platformsUncheckedCreateNestedManyWithoutOrganizationsInput
    locations?: locationsUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsCreateOrConnectWithoutUsersInput = {
    where: organizationsWhereUniqueInput
    create: XOR<organizationsCreateWithoutUsersInput, organizationsUncheckedCreateWithoutUsersInput>
  }

  export type storesCreateWithoutUsersInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    name?: string | null
    image?: imagesCreateNestedOneWithoutStoresInput
    locations?: locationsCreateNestedManyWithoutStoresInput
    inventories?: inventoriesCreateNestedManyWithoutStoresInput
  }

  export type storesUncheckedCreateWithoutUsersInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    name?: string | null
    image_id?: string | null
    user_ids?: storesCreateuser_idsInput | Enumerable<string>
    location_ids?: storesCreatelocation_idsInput | Enumerable<string>
    inventory_ids?: storesCreateinventory_idsInput | Enumerable<string>
    locations?: locationsUncheckedCreateNestedManyWithoutStoresInput
    inventories?: inventoriesUncheckedCreateNestedManyWithoutStoresInput
  }

  export type storesCreateOrConnectWithoutUsersInput = {
    where: storesWhereUniqueInput
    create: XOR<storesCreateWithoutUsersInput, storesUncheckedCreateWithoutUsersInput>
  }

  export type paymentCreateWithoutUser_creatorInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    title?: string | null
    description?: string | null
    amount: XOR<CurrencyCreateEnvelopeInput, CurrencyCreateInput>
    payment_type: PaymentTypeCreateNestedOneWithoutPaymentsInput
    user_confirm: usersCreateNestedOneWithoutPayments_confirmedInput
    recever_account: PaymentAccountCreateNestedOneWithoutPayments_receivedInput
    sender_account: PaymentAccountCreateNestedOneWithoutPayments_sendedInput
  }

  export type paymentUncheckedCreateWithoutUser_creatorInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    title?: string | null
    description?: string | null
    payment_type_id: string
    user_confirm_id: string
    receiver_account_id: string
    sender_account_id: string
    amount: XOR<CurrencyCreateEnvelopeInput, CurrencyCreateInput>
  }

  export type paymentCreateOrConnectWithoutUser_creatorInput = {
    where: paymentWhereUniqueInput
    create: XOR<paymentCreateWithoutUser_creatorInput, paymentUncheckedCreateWithoutUser_creatorInput>
  }

  export type paymentCreateManyUser_creatorInputEnvelope = {
    data: Enumerable<paymentCreateManyUser_creatorInput>
  }

  export type paymentCreateWithoutUser_confirmInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    title?: string | null
    description?: string | null
    amount: XOR<CurrencyCreateEnvelopeInput, CurrencyCreateInput>
    payment_type: PaymentTypeCreateNestedOneWithoutPaymentsInput
    user_creator: usersCreateNestedOneWithoutPayments_createdInput
    recever_account: PaymentAccountCreateNestedOneWithoutPayments_receivedInput
    sender_account: PaymentAccountCreateNestedOneWithoutPayments_sendedInput
  }

  export type paymentUncheckedCreateWithoutUser_confirmInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    title?: string | null
    description?: string | null
    payment_type_id: string
    user_creator_id: string
    receiver_account_id: string
    sender_account_id: string
    amount: XOR<CurrencyCreateEnvelopeInput, CurrencyCreateInput>
  }

  export type paymentCreateOrConnectWithoutUser_confirmInput = {
    where: paymentWhereUniqueInput
    create: XOR<paymentCreateWithoutUser_confirmInput, paymentUncheckedCreateWithoutUser_confirmInput>
  }

  export type paymentCreateManyUser_confirmInputEnvelope = {
    data: Enumerable<paymentCreateManyUser_confirmInput>
  }

  export type sessionsCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    jwt: string
    user_uuid: string
  }

  export type sessionsUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    jwt: string
    user_uuid: string
  }

  export type sessionsCreateOrConnectWithoutUserInput = {
    where: sessionsWhereUniqueInput
    create: XOR<sessionsCreateWithoutUserInput, sessionsUncheckedCreateWithoutUserInput>
  }

  export type sessionsCreateManyUserInputEnvelope = {
    data: Enumerable<sessionsCreateManyUserInput>
  }

  export type imagesUpsertWithoutUsersInput = {
    update: XOR<imagesUpdateWithoutUsersInput, imagesUncheckedUpdateWithoutUsersInput>
    create: XOR<imagesCreateWithoutUsersInput, imagesUncheckedCreateWithoutUsersInput>
  }

  export type imagesUpdateWithoutUsersInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_key?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_url?: NullableStringFieldUpdateOperationsInput | string | null
    platforms?: platformsUpdateManyWithoutImageNestedInput
    providers?: providersUpdateManyWithoutImageNestedInput
    organizations?: organizationsUpdateManyWithoutImageNestedInput
    stores?: storesUpdateManyWithoutImageNestedInput
    items?: itemsUpdateManyWithoutImagesNestedInput
  }

  export type imagesUncheckedUpdateWithoutUsersInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_key?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_url?: NullableStringFieldUpdateOperationsInput | string | null
    item_ids?: imagesUpdateitem_idsInput | Enumerable<string>
    platforms?: platformsUncheckedUpdateManyWithoutImageNestedInput
    providers?: providersUncheckedUpdateManyWithoutImageNestedInput
    organizations?: organizationsUncheckedUpdateManyWithoutImageNestedInput
    stores?: storesUncheckedUpdateManyWithoutImageNestedInput
    items?: itemsUncheckedUpdateManyWithoutImagesNestedInput
  }

  export type locationsUpsertWithoutUsers_preferedInput = {
    update: XOR<locationsUpdateWithoutUsers_preferedInput, locationsUncheckedUpdateWithoutUsers_preferedInput>
    create: XOR<locationsCreateWithoutUsers_preferedInput, locationsUncheckedCreateWithoutUsers_preferedInput>
  }

  export type locationsUpdateWithoutUsers_preferedInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    store_ids?: locationsUpdatestore_idsInput | Enumerable<string>
    users?: usersUpdateManyWithoutLocationsNestedInput
    organizations?: organizationsUpdateManyWithoutLocationsNestedInput
    stores?: storesUpdateManyWithoutLocationsNestedInput
  }

  export type locationsUncheckedUpdateWithoutUsers_preferedInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    user_ids?: locationsUpdateuser_idsInput | Enumerable<string>
    organizations_ids?: locationsUpdateorganizations_idsInput | Enumerable<string>
    store_ids?: locationsUpdatestore_idsInput | Enumerable<string>
    users?: usersUncheckedUpdateManyWithoutLocationsNestedInput
    organizations?: organizationsUncheckedUpdateManyWithoutLocationsNestedInput
    stores?: storesUncheckedUpdateManyWithoutLocationsNestedInput
  }

  export type locationsUpsertWithWhereUniqueWithoutUsersInput = {
    where: locationsWhereUniqueInput
    update: XOR<locationsUpdateWithoutUsersInput, locationsUncheckedUpdateWithoutUsersInput>
    create: XOR<locationsCreateWithoutUsersInput, locationsUncheckedCreateWithoutUsersInput>
  }

  export type locationsUpdateWithWhereUniqueWithoutUsersInput = {
    where: locationsWhereUniqueInput
    data: XOR<locationsUpdateWithoutUsersInput, locationsUncheckedUpdateWithoutUsersInput>
  }

  export type locationsUpdateManyWithWhereWithoutUsersInput = {
    where: locationsScalarWhereInput
    data: XOR<locationsUpdateManyMutationInput, locationsUncheckedUpdateManyWithoutLocationsInput>
  }

  export type locationsScalarWhereInput = {
    AND?: Enumerable<locationsScalarWhereInput>
    OR?: Enumerable<locationsScalarWhereInput>
    NOT?: Enumerable<locationsScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
    name?: StringNullableFilter | string | null
    latitude?: FloatNullableFilter | number | null
    longitude?: FloatNullableFilter | number | null
    user_ids?: StringNullableListFilter
    organizations_ids?: StringNullableListFilter
    store_ids?: StringNullableListFilter
  }

  export type platformsUpsertWithWhereUniqueWithoutUsersInput = {
    where: platformsWhereUniqueInput
    update: XOR<platformsUpdateWithoutUsersInput, platformsUncheckedUpdateWithoutUsersInput>
    create: XOR<platformsCreateWithoutUsersInput, platformsUncheckedCreateWithoutUsersInput>
  }

  export type platformsUpdateWithWhereUniqueWithoutUsersInput = {
    where: platformsWhereUniqueInput
    data: XOR<platformsUpdateWithoutUsersInput, platformsUncheckedUpdateWithoutUsersInput>
  }

  export type platformsUpdateManyWithWhereWithoutUsersInput = {
    where: platformsScalarWhereInput
    data: XOR<platformsUpdateManyMutationInput, platformsUncheckedUpdateManyWithoutPlatformsInput>
  }

  export type organizationsUpsertWithWhereUniqueWithoutUsersInput = {
    where: organizationsWhereUniqueInput
    update: XOR<organizationsUpdateWithoutUsersInput, organizationsUncheckedUpdateWithoutUsersInput>
    create: XOR<organizationsCreateWithoutUsersInput, organizationsUncheckedCreateWithoutUsersInput>
  }

  export type organizationsUpdateWithWhereUniqueWithoutUsersInput = {
    where: organizationsWhereUniqueInput
    data: XOR<organizationsUpdateWithoutUsersInput, organizationsUncheckedUpdateWithoutUsersInput>
  }

  export type organizationsUpdateManyWithWhereWithoutUsersInput = {
    where: organizationsScalarWhereInput
    data: XOR<organizationsUpdateManyMutationInput, organizationsUncheckedUpdateManyWithoutOrganizationsInput>
  }

  export type storesUpsertWithWhereUniqueWithoutUsersInput = {
    where: storesWhereUniqueInput
    update: XOR<storesUpdateWithoutUsersInput, storesUncheckedUpdateWithoutUsersInput>
    create: XOR<storesCreateWithoutUsersInput, storesUncheckedCreateWithoutUsersInput>
  }

  export type storesUpdateWithWhereUniqueWithoutUsersInput = {
    where: storesWhereUniqueInput
    data: XOR<storesUpdateWithoutUsersInput, storesUncheckedUpdateWithoutUsersInput>
  }

  export type storesUpdateManyWithWhereWithoutUsersInput = {
    where: storesScalarWhereInput
    data: XOR<storesUpdateManyMutationInput, storesUncheckedUpdateManyWithoutStoresInput>
  }

  export type storesScalarWhereInput = {
    AND?: Enumerable<storesScalarWhereInput>
    OR?: Enumerable<storesScalarWhereInput>
    NOT?: Enumerable<storesScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
    username?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    image_id?: StringNullableFilter | string | null
    user_ids?: StringNullableListFilter
    location_ids?: StringNullableListFilter
    inventory_ids?: StringNullableListFilter
  }

  export type paymentUpsertWithWhereUniqueWithoutUser_creatorInput = {
    where: paymentWhereUniqueInput
    update: XOR<paymentUpdateWithoutUser_creatorInput, paymentUncheckedUpdateWithoutUser_creatorInput>
    create: XOR<paymentCreateWithoutUser_creatorInput, paymentUncheckedCreateWithoutUser_creatorInput>
  }

  export type paymentUpdateWithWhereUniqueWithoutUser_creatorInput = {
    where: paymentWhereUniqueInput
    data: XOR<paymentUpdateWithoutUser_creatorInput, paymentUncheckedUpdateWithoutUser_creatorInput>
  }

  export type paymentUpdateManyWithWhereWithoutUser_creatorInput = {
    where: paymentScalarWhereInput
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyWithoutPayments_createdInput>
  }

  export type paymentScalarWhereInput = {
    AND?: Enumerable<paymentScalarWhereInput>
    OR?: Enumerable<paymentScalarWhereInput>
    NOT?: Enumerable<paymentScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
    title?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    payment_type_id?: StringFilter | string
    user_creator_id?: StringFilter | string
    user_confirm_id?: StringFilter | string
    receiver_account_id?: StringFilter | string
    sender_account_id?: StringFilter | string
  }

  export type paymentUpsertWithWhereUniqueWithoutUser_confirmInput = {
    where: paymentWhereUniqueInput
    update: XOR<paymentUpdateWithoutUser_confirmInput, paymentUncheckedUpdateWithoutUser_confirmInput>
    create: XOR<paymentCreateWithoutUser_confirmInput, paymentUncheckedCreateWithoutUser_confirmInput>
  }

  export type paymentUpdateWithWhereUniqueWithoutUser_confirmInput = {
    where: paymentWhereUniqueInput
    data: XOR<paymentUpdateWithoutUser_confirmInput, paymentUncheckedUpdateWithoutUser_confirmInput>
  }

  export type paymentUpdateManyWithWhereWithoutUser_confirmInput = {
    where: paymentScalarWhereInput
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyWithoutPayments_confirmedInput>
  }

  export type sessionsUpsertWithWhereUniqueWithoutUserInput = {
    where: sessionsWhereUniqueInput
    update: XOR<sessionsUpdateWithoutUserInput, sessionsUncheckedUpdateWithoutUserInput>
    create: XOR<sessionsCreateWithoutUserInput, sessionsUncheckedCreateWithoutUserInput>
  }

  export type sessionsUpdateWithWhereUniqueWithoutUserInput = {
    where: sessionsWhereUniqueInput
    data: XOR<sessionsUpdateWithoutUserInput, sessionsUncheckedUpdateWithoutUserInput>
  }

  export type sessionsUpdateManyWithWhereWithoutUserInput = {
    where: sessionsScalarWhereInput
    data: XOR<sessionsUpdateManyMutationInput, sessionsUncheckedUpdateManyWithoutSessionInput>
  }

  export type sessionsScalarWhereInput = {
    AND?: Enumerable<sessionsScalarWhereInput>
    OR?: Enumerable<sessionsScalarWhereInput>
    NOT?: Enumerable<sessionsScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
    jwt?: StringFilter | string
    user_uuid?: StringFilter | string
    user_id?: StringFilter | string
  }

  export type imagesCreateWithoutOrganizationsInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    key: string
    url?: string | null
    clipped_key?: string | null
    clipped_url?: string | null
    platforms?: platformsCreateNestedManyWithoutImageInput
    providers?: providersCreateNestedManyWithoutImageInput
    stores?: storesCreateNestedManyWithoutImageInput
    users?: usersCreateNestedManyWithoutImageInput
    items?: itemsCreateNestedManyWithoutImagesInput
  }

  export type imagesUncheckedCreateWithoutOrganizationsInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    key: string
    url?: string | null
    clipped_key?: string | null
    clipped_url?: string | null
    item_ids?: imagesCreateitem_idsInput | Enumerable<string>
    platforms?: platformsUncheckedCreateNestedManyWithoutImageInput
    providers?: providersUncheckedCreateNestedManyWithoutImageInput
    stores?: storesUncheckedCreateNestedManyWithoutImageInput
    users?: usersUncheckedCreateNestedManyWithoutImageInput
    items?: itemsUncheckedCreateNestedManyWithoutImagesInput
  }

  export type imagesCreateOrConnectWithoutOrganizationsInput = {
    where: imagesWhereUniqueInput
    create: XOR<imagesCreateWithoutOrganizationsInput, imagesUncheckedCreateWithoutOrganizationsInput>
  }

  export type platformsCreateWithoutOrganizationsInput = {
    id?: string
    uuid?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    key: string
    username?: string | null
    name?: string | null
    image?: imagesCreateNestedOneWithoutPlatformsInput
    providers?: providersCreateNestedManyWithoutPlatformsInput
    provider_keys?: provider_keysCreateNestedManyWithoutPlatformsInput
    users?: usersCreateNestedManyWithoutPlatformsInput
  }

  export type platformsUncheckedCreateWithoutOrganizationsInput = {
    id?: string
    uuid?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    key: string
    username?: string | null
    name?: string | null
    image_id?: string | null
    provider_ids?: platformsCreateprovider_idsInput | Enumerable<string>
    provider_key_ids?: platformsCreateprovider_key_idsInput | Enumerable<string>
    user_ids?: platformsCreateuser_idsInput | Enumerable<string>
    organization_ids?: platformsCreateorganization_idsInput | Enumerable<string>
    providers?: providersUncheckedCreateNestedManyWithoutPlatformsInput
    provider_keys?: provider_keysUncheckedCreateNestedManyWithoutPlatformsInput
    users?: usersUncheckedCreateNestedManyWithoutPlatformsInput
  }

  export type platformsCreateOrConnectWithoutOrganizationsInput = {
    where: platformsWhereUniqueInput
    create: XOR<platformsCreateWithoutOrganizationsInput, platformsUncheckedCreateWithoutOrganizationsInput>
  }

  export type usersCreateWithoutOrganizationsInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    email?: string | null
    phone?: string | null
    name?: string | null
    birthDate?: Date | string | null
    gender?: GenderType | null
    image?: imagesCreateNestedOneWithoutUsersInput
    prefered_location?: locationsCreateNestedOneWithoutUsers_preferedInput
    locations?: locationsCreateNestedManyWithoutUsersInput
    platforms?: platformsCreateNestedManyWithoutUsersInput
    stores?: storesCreateNestedManyWithoutUsersInput
    payments_created?: paymentCreateNestedManyWithoutUser_creatorInput
    payments_confirmed?: paymentCreateNestedManyWithoutUser_confirmInput
    session?: sessionsCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutOrganizationsInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    email?: string | null
    phone?: string | null
    name?: string | null
    birthDate?: Date | string | null
    gender?: GenderType | null
    image_id?: string | null
    prefered_location_id?: string | null
    location_ids?: usersCreatelocation_idsInput | Enumerable<string>
    platform_ids?: usersCreateplatform_idsInput | Enumerable<string>
    organization_ids?: usersCreateorganization_idsInput | Enumerable<string>
    store_ids?: usersCreatestore_idsInput | Enumerable<string>
    locations?: locationsUncheckedCreateNestedManyWithoutUsersInput
    platforms?: platformsUncheckedCreateNestedManyWithoutUsersInput
    stores?: storesUncheckedCreateNestedManyWithoutUsersInput
    payments_created?: paymentUncheckedCreateNestedManyWithoutUser_creatorInput
    payments_confirmed?: paymentUncheckedCreateNestedManyWithoutUser_confirmInput
    session?: sessionsUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutOrganizationsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutOrganizationsInput, usersUncheckedCreateWithoutOrganizationsInput>
  }

  export type locationsCreateWithoutOrganizationsInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    name?: string | null
    latitude?: number | null
    longitude?: number | null
    store_ids?: locationsCreatestore_idsInput | Enumerable<string>
    users?: usersCreateNestedManyWithoutLocationsInput
    stores?: storesCreateNestedManyWithoutLocationsInput
    users_prefered?: usersCreateNestedManyWithoutPrefered_locationInput
  }

  export type locationsUncheckedCreateWithoutOrganizationsInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    name?: string | null
    latitude?: number | null
    longitude?: number | null
    user_ids?: locationsCreateuser_idsInput | Enumerable<string>
    organizations_ids?: locationsCreateorganizations_idsInput | Enumerable<string>
    store_ids?: locationsCreatestore_idsInput | Enumerable<string>
    users?: usersUncheckedCreateNestedManyWithoutLocationsInput
    stores?: storesUncheckedCreateNestedManyWithoutLocationsInput
    users_prefered?: usersUncheckedCreateNestedManyWithoutPrefered_locationInput
  }

  export type locationsCreateOrConnectWithoutOrganizationsInput = {
    where: locationsWhereUniqueInput
    create: XOR<locationsCreateWithoutOrganizationsInput, locationsUncheckedCreateWithoutOrganizationsInput>
  }

  export type imagesUpsertWithoutOrganizationsInput = {
    update: XOR<imagesUpdateWithoutOrganizationsInput, imagesUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<imagesCreateWithoutOrganizationsInput, imagesUncheckedCreateWithoutOrganizationsInput>
  }

  export type imagesUpdateWithoutOrganizationsInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_key?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_url?: NullableStringFieldUpdateOperationsInput | string | null
    platforms?: platformsUpdateManyWithoutImageNestedInput
    providers?: providersUpdateManyWithoutImageNestedInput
    stores?: storesUpdateManyWithoutImageNestedInput
    users?: usersUpdateManyWithoutImageNestedInput
    items?: itemsUpdateManyWithoutImagesNestedInput
  }

  export type imagesUncheckedUpdateWithoutOrganizationsInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_key?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_url?: NullableStringFieldUpdateOperationsInput | string | null
    item_ids?: imagesUpdateitem_idsInput | Enumerable<string>
    platforms?: platformsUncheckedUpdateManyWithoutImageNestedInput
    providers?: providersUncheckedUpdateManyWithoutImageNestedInput
    stores?: storesUncheckedUpdateManyWithoutImageNestedInput
    users?: usersUncheckedUpdateManyWithoutImageNestedInput
    items?: itemsUncheckedUpdateManyWithoutImagesNestedInput
  }

  export type platformsUpsertWithWhereUniqueWithoutOrganizationsInput = {
    where: platformsWhereUniqueInput
    update: XOR<platformsUpdateWithoutOrganizationsInput, platformsUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<platformsCreateWithoutOrganizationsInput, platformsUncheckedCreateWithoutOrganizationsInput>
  }

  export type platformsUpdateWithWhereUniqueWithoutOrganizationsInput = {
    where: platformsWhereUniqueInput
    data: XOR<platformsUpdateWithoutOrganizationsInput, platformsUncheckedUpdateWithoutOrganizationsInput>
  }

  export type platformsUpdateManyWithWhereWithoutOrganizationsInput = {
    where: platformsScalarWhereInput
    data: XOR<platformsUpdateManyMutationInput, platformsUncheckedUpdateManyWithoutPlatformsInput>
  }

  export type usersUpsertWithWhereUniqueWithoutOrganizationsInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutOrganizationsInput, usersUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<usersCreateWithoutOrganizationsInput, usersUncheckedCreateWithoutOrganizationsInput>
  }

  export type usersUpdateWithWhereUniqueWithoutOrganizationsInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutOrganizationsInput, usersUncheckedUpdateWithoutOrganizationsInput>
  }

  export type usersUpdateManyWithWhereWithoutOrganizationsInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutUsersInput>
  }

  export type locationsUpsertWithWhereUniqueWithoutOrganizationsInput = {
    where: locationsWhereUniqueInput
    update: XOR<locationsUpdateWithoutOrganizationsInput, locationsUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<locationsCreateWithoutOrganizationsInput, locationsUncheckedCreateWithoutOrganizationsInput>
  }

  export type locationsUpdateWithWhereUniqueWithoutOrganizationsInput = {
    where: locationsWhereUniqueInput
    data: XOR<locationsUpdateWithoutOrganizationsInput, locationsUncheckedUpdateWithoutOrganizationsInput>
  }

  export type locationsUpdateManyWithWhereWithoutOrganizationsInput = {
    where: locationsScalarWhereInput
    data: XOR<locationsUpdateManyMutationInput, locationsUncheckedUpdateManyWithoutLocationsInput>
  }

  export type imagesCreateWithoutStoresInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    key: string
    url?: string | null
    clipped_key?: string | null
    clipped_url?: string | null
    platforms?: platformsCreateNestedManyWithoutImageInput
    providers?: providersCreateNestedManyWithoutImageInput
    organizations?: organizationsCreateNestedManyWithoutImageInput
    users?: usersCreateNestedManyWithoutImageInput
    items?: itemsCreateNestedManyWithoutImagesInput
  }

  export type imagesUncheckedCreateWithoutStoresInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    key: string
    url?: string | null
    clipped_key?: string | null
    clipped_url?: string | null
    item_ids?: imagesCreateitem_idsInput | Enumerable<string>
    platforms?: platformsUncheckedCreateNestedManyWithoutImageInput
    providers?: providersUncheckedCreateNestedManyWithoutImageInput
    organizations?: organizationsUncheckedCreateNestedManyWithoutImageInput
    users?: usersUncheckedCreateNestedManyWithoutImageInput
    items?: itemsUncheckedCreateNestedManyWithoutImagesInput
  }

  export type imagesCreateOrConnectWithoutStoresInput = {
    where: imagesWhereUniqueInput
    create: XOR<imagesCreateWithoutStoresInput, imagesUncheckedCreateWithoutStoresInput>
  }

  export type usersCreateWithoutStoresInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    email?: string | null
    phone?: string | null
    name?: string | null
    birthDate?: Date | string | null
    gender?: GenderType | null
    image?: imagesCreateNestedOneWithoutUsersInput
    prefered_location?: locationsCreateNestedOneWithoutUsers_preferedInput
    locations?: locationsCreateNestedManyWithoutUsersInput
    platforms?: platformsCreateNestedManyWithoutUsersInput
    organizations?: organizationsCreateNestedManyWithoutUsersInput
    payments_created?: paymentCreateNestedManyWithoutUser_creatorInput
    payments_confirmed?: paymentCreateNestedManyWithoutUser_confirmInput
    session?: sessionsCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutStoresInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    email?: string | null
    phone?: string | null
    name?: string | null
    birthDate?: Date | string | null
    gender?: GenderType | null
    image_id?: string | null
    prefered_location_id?: string | null
    location_ids?: usersCreatelocation_idsInput | Enumerable<string>
    platform_ids?: usersCreateplatform_idsInput | Enumerable<string>
    organization_ids?: usersCreateorganization_idsInput | Enumerable<string>
    store_ids?: usersCreatestore_idsInput | Enumerable<string>
    locations?: locationsUncheckedCreateNestedManyWithoutUsersInput
    platforms?: platformsUncheckedCreateNestedManyWithoutUsersInput
    organizations?: organizationsUncheckedCreateNestedManyWithoutUsersInput
    payments_created?: paymentUncheckedCreateNestedManyWithoutUser_creatorInput
    payments_confirmed?: paymentUncheckedCreateNestedManyWithoutUser_confirmInput
    session?: sessionsUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutStoresInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutStoresInput, usersUncheckedCreateWithoutStoresInput>
  }

  export type locationsCreateWithoutStoresInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    name?: string | null
    latitude?: number | null
    longitude?: number | null
    store_ids?: locationsCreatestore_idsInput | Enumerable<string>
    users?: usersCreateNestedManyWithoutLocationsInput
    organizations?: organizationsCreateNestedManyWithoutLocationsInput
    users_prefered?: usersCreateNestedManyWithoutPrefered_locationInput
  }

  export type locationsUncheckedCreateWithoutStoresInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    name?: string | null
    latitude?: number | null
    longitude?: number | null
    user_ids?: locationsCreateuser_idsInput | Enumerable<string>
    organizations_ids?: locationsCreateorganizations_idsInput | Enumerable<string>
    store_ids?: locationsCreatestore_idsInput | Enumerable<string>
    users?: usersUncheckedCreateNestedManyWithoutLocationsInput
    organizations?: organizationsUncheckedCreateNestedManyWithoutLocationsInput
    users_prefered?: usersUncheckedCreateNestedManyWithoutPrefered_locationInput
  }

  export type locationsCreateOrConnectWithoutStoresInput = {
    where: locationsWhereUniqueInput
    create: XOR<locationsCreateWithoutStoresInput, locationsUncheckedCreateWithoutStoresInput>
  }

  export type inventoriesCreateWithoutStoresInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    name?: string | null
    description?: string | null
    item_inventories?: item_inventoriesCreateNestedManyWithoutInventoriesInput
  }

  export type inventoriesUncheckedCreateWithoutStoresInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    name?: string | null
    description?: string | null
    item_iventory_ids?: inventoriesCreateitem_iventory_idsInput | Enumerable<string>
    store_ids?: inventoriesCreatestore_idsInput | Enumerable<string>
    item_inventories?: item_inventoriesUncheckedCreateNestedManyWithoutInventoriesInput
  }

  export type inventoriesCreateOrConnectWithoutStoresInput = {
    where: inventoriesWhereUniqueInput
    create: XOR<inventoriesCreateWithoutStoresInput, inventoriesUncheckedCreateWithoutStoresInput>
  }

  export type imagesUpsertWithoutStoresInput = {
    update: XOR<imagesUpdateWithoutStoresInput, imagesUncheckedUpdateWithoutStoresInput>
    create: XOR<imagesCreateWithoutStoresInput, imagesUncheckedCreateWithoutStoresInput>
  }

  export type imagesUpdateWithoutStoresInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_key?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_url?: NullableStringFieldUpdateOperationsInput | string | null
    platforms?: platformsUpdateManyWithoutImageNestedInput
    providers?: providersUpdateManyWithoutImageNestedInput
    organizations?: organizationsUpdateManyWithoutImageNestedInput
    users?: usersUpdateManyWithoutImageNestedInput
    items?: itemsUpdateManyWithoutImagesNestedInput
  }

  export type imagesUncheckedUpdateWithoutStoresInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_key?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_url?: NullableStringFieldUpdateOperationsInput | string | null
    item_ids?: imagesUpdateitem_idsInput | Enumerable<string>
    platforms?: platformsUncheckedUpdateManyWithoutImageNestedInput
    providers?: providersUncheckedUpdateManyWithoutImageNestedInput
    organizations?: organizationsUncheckedUpdateManyWithoutImageNestedInput
    users?: usersUncheckedUpdateManyWithoutImageNestedInput
    items?: itemsUncheckedUpdateManyWithoutImagesNestedInput
  }

  export type usersUpsertWithWhereUniqueWithoutStoresInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutStoresInput, usersUncheckedUpdateWithoutStoresInput>
    create: XOR<usersCreateWithoutStoresInput, usersUncheckedCreateWithoutStoresInput>
  }

  export type usersUpdateWithWhereUniqueWithoutStoresInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutStoresInput, usersUncheckedUpdateWithoutStoresInput>
  }

  export type usersUpdateManyWithWhereWithoutStoresInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutUsersInput>
  }

  export type locationsUpsertWithWhereUniqueWithoutStoresInput = {
    where: locationsWhereUniqueInput
    update: XOR<locationsUpdateWithoutStoresInput, locationsUncheckedUpdateWithoutStoresInput>
    create: XOR<locationsCreateWithoutStoresInput, locationsUncheckedCreateWithoutStoresInput>
  }

  export type locationsUpdateWithWhereUniqueWithoutStoresInput = {
    where: locationsWhereUniqueInput
    data: XOR<locationsUpdateWithoutStoresInput, locationsUncheckedUpdateWithoutStoresInput>
  }

  export type locationsUpdateManyWithWhereWithoutStoresInput = {
    where: locationsScalarWhereInput
    data: XOR<locationsUpdateManyMutationInput, locationsUncheckedUpdateManyWithoutLocationsInput>
  }

  export type inventoriesUpsertWithWhereUniqueWithoutStoresInput = {
    where: inventoriesWhereUniqueInput
    update: XOR<inventoriesUpdateWithoutStoresInput, inventoriesUncheckedUpdateWithoutStoresInput>
    create: XOR<inventoriesCreateWithoutStoresInput, inventoriesUncheckedCreateWithoutStoresInput>
  }

  export type inventoriesUpdateWithWhereUniqueWithoutStoresInput = {
    where: inventoriesWhereUniqueInput
    data: XOR<inventoriesUpdateWithoutStoresInput, inventoriesUncheckedUpdateWithoutStoresInput>
  }

  export type inventoriesUpdateManyWithWhereWithoutStoresInput = {
    where: inventoriesScalarWhereInput
    data: XOR<inventoriesUpdateManyMutationInput, inventoriesUncheckedUpdateManyWithoutInventoriesInput>
  }

  export type inventoriesScalarWhereInput = {
    AND?: Enumerable<inventoriesScalarWhereInput>
    OR?: Enumerable<inventoriesScalarWhereInput>
    NOT?: Enumerable<inventoriesScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
    name?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    item_iventory_ids?: StringNullableListFilter
    store_ids?: StringNullableListFilter
  }

  export type item_inventoriesCreateWithoutInventoriesInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    type: ItemQualitativeType
    value: number
    item: itemsCreateNestedOneWithoutItem_inventoriesInput
  }

  export type item_inventoriesUncheckedCreateWithoutInventoriesInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    item_id: string
    type: ItemQualitativeType
    value: number
    iventory_ids?: item_inventoriesCreateiventory_idsInput | Enumerable<string>
  }

  export type item_inventoriesCreateOrConnectWithoutInventoriesInput = {
    where: item_inventoriesWhereUniqueInput
    create: XOR<item_inventoriesCreateWithoutInventoriesInput, item_inventoriesUncheckedCreateWithoutInventoriesInput>
  }

  export type storesCreateWithoutInventoriesInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    name?: string | null
    image?: imagesCreateNestedOneWithoutStoresInput
    users?: usersCreateNestedManyWithoutStoresInput
    locations?: locationsCreateNestedManyWithoutStoresInput
  }

  export type storesUncheckedCreateWithoutInventoriesInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    name?: string | null
    image_id?: string | null
    user_ids?: storesCreateuser_idsInput | Enumerable<string>
    location_ids?: storesCreatelocation_idsInput | Enumerable<string>
    inventory_ids?: storesCreateinventory_idsInput | Enumerable<string>
    users?: usersUncheckedCreateNestedManyWithoutStoresInput
    locations?: locationsUncheckedCreateNestedManyWithoutStoresInput
  }

  export type storesCreateOrConnectWithoutInventoriesInput = {
    where: storesWhereUniqueInput
    create: XOR<storesCreateWithoutInventoriesInput, storesUncheckedCreateWithoutInventoriesInput>
  }

  export type item_inventoriesUpsertWithWhereUniqueWithoutInventoriesInput = {
    where: item_inventoriesWhereUniqueInput
    update: XOR<item_inventoriesUpdateWithoutInventoriesInput, item_inventoriesUncheckedUpdateWithoutInventoriesInput>
    create: XOR<item_inventoriesCreateWithoutInventoriesInput, item_inventoriesUncheckedCreateWithoutInventoriesInput>
  }

  export type item_inventoriesUpdateWithWhereUniqueWithoutInventoriesInput = {
    where: item_inventoriesWhereUniqueInput
    data: XOR<item_inventoriesUpdateWithoutInventoriesInput, item_inventoriesUncheckedUpdateWithoutInventoriesInput>
  }

  export type item_inventoriesUpdateManyWithWhereWithoutInventoriesInput = {
    where: item_inventoriesScalarWhereInput
    data: XOR<item_inventoriesUpdateManyMutationInput, item_inventoriesUncheckedUpdateManyWithoutItem_inventoriesInput>
  }

  export type item_inventoriesScalarWhereInput = {
    AND?: Enumerable<item_inventoriesScalarWhereInput>
    OR?: Enumerable<item_inventoriesScalarWhereInput>
    NOT?: Enumerable<item_inventoriesScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
    item_id?: StringFilter | string
    type?: EnumItemQualitativeTypeFilter | ItemQualitativeType
    value?: FloatFilter | number
    iventory_ids?: StringNullableListFilter
  }

  export type storesUpsertWithWhereUniqueWithoutInventoriesInput = {
    where: storesWhereUniqueInput
    update: XOR<storesUpdateWithoutInventoriesInput, storesUncheckedUpdateWithoutInventoriesInput>
    create: XOR<storesCreateWithoutInventoriesInput, storesUncheckedCreateWithoutInventoriesInput>
  }

  export type storesUpdateWithWhereUniqueWithoutInventoriesInput = {
    where: storesWhereUniqueInput
    data: XOR<storesUpdateWithoutInventoriesInput, storesUncheckedUpdateWithoutInventoriesInput>
  }

  export type storesUpdateManyWithWhereWithoutInventoriesInput = {
    where: storesScalarWhereInput
    data: XOR<storesUpdateManyMutationInput, storesUncheckedUpdateManyWithoutStoresInput>
  }

  export type itemsCreateWithoutItem_inventoriesInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    name?: string | null
    description?: string | null
    tags?: itemsCreatetagsInput | Enumerable<string>
    prices?: XOR<CurrencyListCreateEnvelopeInput, Enumerable<CurrencyCreateInput>>
    images?: imagesCreateNestedManyWithoutItemsInput
    item_orders?: item_ordersCreateNestedManyWithoutItemInput
  }

  export type itemsUncheckedCreateWithoutItem_inventoriesInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    name?: string | null
    description?: string | null
    tags?: itemsCreatetagsInput | Enumerable<string>
    image_ids?: itemsCreateimage_idsInput | Enumerable<string>
    prices?: XOR<CurrencyListCreateEnvelopeInput, Enumerable<CurrencyCreateInput>>
    images?: imagesUncheckedCreateNestedManyWithoutItemsInput
    item_orders?: item_ordersUncheckedCreateNestedManyWithoutItemInput
  }

  export type itemsCreateOrConnectWithoutItem_inventoriesInput = {
    where: itemsWhereUniqueInput
    create: XOR<itemsCreateWithoutItem_inventoriesInput, itemsUncheckedCreateWithoutItem_inventoriesInput>
  }

  export type inventoriesCreateWithoutItem_inventoriesInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    name?: string | null
    description?: string | null
    stores?: storesCreateNestedManyWithoutInventoriesInput
  }

  export type inventoriesUncheckedCreateWithoutItem_inventoriesInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    name?: string | null
    description?: string | null
    item_iventory_ids?: inventoriesCreateitem_iventory_idsInput | Enumerable<string>
    store_ids?: inventoriesCreatestore_idsInput | Enumerable<string>
    stores?: storesUncheckedCreateNestedManyWithoutInventoriesInput
  }

  export type inventoriesCreateOrConnectWithoutItem_inventoriesInput = {
    where: inventoriesWhereUniqueInput
    create: XOR<inventoriesCreateWithoutItem_inventoriesInput, inventoriesUncheckedCreateWithoutItem_inventoriesInput>
  }

  export type itemsUpsertWithoutItem_inventoriesInput = {
    update: XOR<itemsUpdateWithoutItem_inventoriesInput, itemsUncheckedUpdateWithoutItem_inventoriesInput>
    create: XOR<itemsCreateWithoutItem_inventoriesInput, itemsUncheckedCreateWithoutItem_inventoriesInput>
  }

  export type itemsUpdateWithoutItem_inventoriesInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: itemsUpdatetagsInput | Enumerable<string>
    prices?: XOR<CurrencyListUpdateEnvelopeInput, Enumerable<CurrencyCreateInput>>
    images?: imagesUpdateManyWithoutItemsNestedInput
    item_orders?: item_ordersUpdateManyWithoutItemNestedInput
  }

  export type itemsUncheckedUpdateWithoutItem_inventoriesInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: itemsUpdatetagsInput | Enumerable<string>
    image_ids?: itemsUpdateimage_idsInput | Enumerable<string>
    prices?: XOR<CurrencyListUpdateEnvelopeInput, Enumerable<CurrencyCreateInput>>
    images?: imagesUncheckedUpdateManyWithoutItemsNestedInput
    item_orders?: item_ordersUncheckedUpdateManyWithoutItemNestedInput
  }

  export type inventoriesUpsertWithWhereUniqueWithoutItem_inventoriesInput = {
    where: inventoriesWhereUniqueInput
    update: XOR<inventoriesUpdateWithoutItem_inventoriesInput, inventoriesUncheckedUpdateWithoutItem_inventoriesInput>
    create: XOR<inventoriesCreateWithoutItem_inventoriesInput, inventoriesUncheckedCreateWithoutItem_inventoriesInput>
  }

  export type inventoriesUpdateWithWhereUniqueWithoutItem_inventoriesInput = {
    where: inventoriesWhereUniqueInput
    data: XOR<inventoriesUpdateWithoutItem_inventoriesInput, inventoriesUncheckedUpdateWithoutItem_inventoriesInput>
  }

  export type inventoriesUpdateManyWithWhereWithoutItem_inventoriesInput = {
    where: inventoriesScalarWhereInput
    data: XOR<inventoriesUpdateManyMutationInput, inventoriesUncheckedUpdateManyWithoutInventoriesInput>
  }

  export type item_ordersCreateWithoutOrdersInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    type: ItemQualitativeType
    value: number
    item: itemsCreateNestedOneWithoutItem_ordersInput
  }

  export type item_ordersUncheckedCreateWithoutOrdersInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    item_id: string
    type: ItemQualitativeType
    value: number
    order_ids?: item_ordersCreateorder_idsInput | Enumerable<string>
  }

  export type item_ordersCreateOrConnectWithoutOrdersInput = {
    where: item_ordersWhereUniqueInput
    create: XOR<item_ordersCreateWithoutOrdersInput, item_ordersUncheckedCreateWithoutOrdersInput>
  }

  export type item_ordersUpsertWithWhereUniqueWithoutOrdersInput = {
    where: item_ordersWhereUniqueInput
    update: XOR<item_ordersUpdateWithoutOrdersInput, item_ordersUncheckedUpdateWithoutOrdersInput>
    create: XOR<item_ordersCreateWithoutOrdersInput, item_ordersUncheckedCreateWithoutOrdersInput>
  }

  export type item_ordersUpdateWithWhereUniqueWithoutOrdersInput = {
    where: item_ordersWhereUniqueInput
    data: XOR<item_ordersUpdateWithoutOrdersInput, item_ordersUncheckedUpdateWithoutOrdersInput>
  }

  export type item_ordersUpdateManyWithWhereWithoutOrdersInput = {
    where: item_ordersScalarWhereInput
    data: XOR<item_ordersUpdateManyMutationInput, item_ordersUncheckedUpdateManyWithoutItem_ordersInput>
  }

  export type item_ordersScalarWhereInput = {
    AND?: Enumerable<item_ordersScalarWhereInput>
    OR?: Enumerable<item_ordersScalarWhereInput>
    NOT?: Enumerable<item_ordersScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
    item_id?: StringFilter | string
    type?: EnumItemQualitativeTypeFilter | ItemQualitativeType
    value?: FloatFilter | number
    order_ids?: StringNullableListFilter
  }

  export type itemsCreateWithoutItem_ordersInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    name?: string | null
    description?: string | null
    tags?: itemsCreatetagsInput | Enumerable<string>
    prices?: XOR<CurrencyListCreateEnvelopeInput, Enumerable<CurrencyCreateInput>>
    images?: imagesCreateNestedManyWithoutItemsInput
    item_inventories?: item_inventoriesCreateNestedManyWithoutItemInput
  }

  export type itemsUncheckedCreateWithoutItem_ordersInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    name?: string | null
    description?: string | null
    tags?: itemsCreatetagsInput | Enumerable<string>
    image_ids?: itemsCreateimage_idsInput | Enumerable<string>
    prices?: XOR<CurrencyListCreateEnvelopeInput, Enumerable<CurrencyCreateInput>>
    images?: imagesUncheckedCreateNestedManyWithoutItemsInput
    item_inventories?: item_inventoriesUncheckedCreateNestedManyWithoutItemInput
  }

  export type itemsCreateOrConnectWithoutItem_ordersInput = {
    where: itemsWhereUniqueInput
    create: XOR<itemsCreateWithoutItem_ordersInput, itemsUncheckedCreateWithoutItem_ordersInput>
  }

  export type odersCreateWithoutItem_ordersInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    total: number
  }

  export type odersUncheckedCreateWithoutItem_ordersInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    total: number
    item_order_ids?: odersCreateitem_order_idsInput | Enumerable<string>
  }

  export type odersCreateOrConnectWithoutItem_ordersInput = {
    where: odersWhereUniqueInput
    create: XOR<odersCreateWithoutItem_ordersInput, odersUncheckedCreateWithoutItem_ordersInput>
  }

  export type itemsUpsertWithoutItem_ordersInput = {
    update: XOR<itemsUpdateWithoutItem_ordersInput, itemsUncheckedUpdateWithoutItem_ordersInput>
    create: XOR<itemsCreateWithoutItem_ordersInput, itemsUncheckedCreateWithoutItem_ordersInput>
  }

  export type itemsUpdateWithoutItem_ordersInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: itemsUpdatetagsInput | Enumerable<string>
    prices?: XOR<CurrencyListUpdateEnvelopeInput, Enumerable<CurrencyCreateInput>>
    images?: imagesUpdateManyWithoutItemsNestedInput
    item_inventories?: item_inventoriesUpdateManyWithoutItemNestedInput
  }

  export type itemsUncheckedUpdateWithoutItem_ordersInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: itemsUpdatetagsInput | Enumerable<string>
    image_ids?: itemsUpdateimage_idsInput | Enumerable<string>
    prices?: XOR<CurrencyListUpdateEnvelopeInput, Enumerable<CurrencyCreateInput>>
    images?: imagesUncheckedUpdateManyWithoutItemsNestedInput
    item_inventories?: item_inventoriesUncheckedUpdateManyWithoutItemNestedInput
  }

  export type odersUpsertWithWhereUniqueWithoutItem_ordersInput = {
    where: odersWhereUniqueInput
    update: XOR<odersUpdateWithoutItem_ordersInput, odersUncheckedUpdateWithoutItem_ordersInput>
    create: XOR<odersCreateWithoutItem_ordersInput, odersUncheckedCreateWithoutItem_ordersInput>
  }

  export type odersUpdateWithWhereUniqueWithoutItem_ordersInput = {
    where: odersWhereUniqueInput
    data: XOR<odersUpdateWithoutItem_ordersInput, odersUncheckedUpdateWithoutItem_ordersInput>
  }

  export type odersUpdateManyWithWhereWithoutItem_ordersInput = {
    where: odersScalarWhereInput
    data: XOR<odersUpdateManyMutationInput, odersUncheckedUpdateManyWithoutOrdersInput>
  }

  export type odersScalarWhereInput = {
    AND?: Enumerable<odersScalarWhereInput>
    OR?: Enumerable<odersScalarWhereInput>
    NOT?: Enumerable<odersScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
    total?: FloatFilter | number
    item_order_ids?: StringNullableListFilter
  }

  export type paymentCreateWithoutPayment_typeInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    title?: string | null
    description?: string | null
    amount: XOR<CurrencyCreateEnvelopeInput, CurrencyCreateInput>
    user_creator: usersCreateNestedOneWithoutPayments_createdInput
    user_confirm: usersCreateNestedOneWithoutPayments_confirmedInput
    recever_account: PaymentAccountCreateNestedOneWithoutPayments_receivedInput
    sender_account: PaymentAccountCreateNestedOneWithoutPayments_sendedInput
  }

  export type paymentUncheckedCreateWithoutPayment_typeInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    title?: string | null
    description?: string | null
    user_creator_id: string
    user_confirm_id: string
    receiver_account_id: string
    sender_account_id: string
    amount: XOR<CurrencyCreateEnvelopeInput, CurrencyCreateInput>
  }

  export type paymentCreateOrConnectWithoutPayment_typeInput = {
    where: paymentWhereUniqueInput
    create: XOR<paymentCreateWithoutPayment_typeInput, paymentUncheckedCreateWithoutPayment_typeInput>
  }

  export type paymentCreateManyPayment_typeInputEnvelope = {
    data: Enumerable<paymentCreateManyPayment_typeInput>
  }

  export type paymentUpsertWithWhereUniqueWithoutPayment_typeInput = {
    where: paymentWhereUniqueInput
    update: XOR<paymentUpdateWithoutPayment_typeInput, paymentUncheckedUpdateWithoutPayment_typeInput>
    create: XOR<paymentCreateWithoutPayment_typeInput, paymentUncheckedCreateWithoutPayment_typeInput>
  }

  export type paymentUpdateWithWhereUniqueWithoutPayment_typeInput = {
    where: paymentWhereUniqueInput
    data: XOR<paymentUpdateWithoutPayment_typeInput, paymentUncheckedUpdateWithoutPayment_typeInput>
  }

  export type paymentUpdateManyWithWhereWithoutPayment_typeInput = {
    where: paymentScalarWhereInput
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyWithoutPaymentsInput>
  }

  export type PaymentTypeCreateWithoutPaymentsInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    title?: string | null
    description?: string | null
  }

  export type PaymentTypeUncheckedCreateWithoutPaymentsInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    title?: string | null
    description?: string | null
  }

  export type PaymentTypeCreateOrConnectWithoutPaymentsInput = {
    where: PaymentTypeWhereUniqueInput
    create: XOR<PaymentTypeCreateWithoutPaymentsInput, PaymentTypeUncheckedCreateWithoutPaymentsInput>
  }

  export type usersCreateWithoutPayments_createdInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    email?: string | null
    phone?: string | null
    name?: string | null
    birthDate?: Date | string | null
    gender?: GenderType | null
    image?: imagesCreateNestedOneWithoutUsersInput
    prefered_location?: locationsCreateNestedOneWithoutUsers_preferedInput
    locations?: locationsCreateNestedManyWithoutUsersInput
    platforms?: platformsCreateNestedManyWithoutUsersInput
    organizations?: organizationsCreateNestedManyWithoutUsersInput
    stores?: storesCreateNestedManyWithoutUsersInput
    payments_confirmed?: paymentCreateNestedManyWithoutUser_confirmInput
    session?: sessionsCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutPayments_createdInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    email?: string | null
    phone?: string | null
    name?: string | null
    birthDate?: Date | string | null
    gender?: GenderType | null
    image_id?: string | null
    prefered_location_id?: string | null
    location_ids?: usersCreatelocation_idsInput | Enumerable<string>
    platform_ids?: usersCreateplatform_idsInput | Enumerable<string>
    organization_ids?: usersCreateorganization_idsInput | Enumerable<string>
    store_ids?: usersCreatestore_idsInput | Enumerable<string>
    locations?: locationsUncheckedCreateNestedManyWithoutUsersInput
    platforms?: platformsUncheckedCreateNestedManyWithoutUsersInput
    organizations?: organizationsUncheckedCreateNestedManyWithoutUsersInput
    stores?: storesUncheckedCreateNestedManyWithoutUsersInput
    payments_confirmed?: paymentUncheckedCreateNestedManyWithoutUser_confirmInput
    session?: sessionsUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutPayments_createdInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutPayments_createdInput, usersUncheckedCreateWithoutPayments_createdInput>
  }

  export type usersCreateWithoutPayments_confirmedInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    email?: string | null
    phone?: string | null
    name?: string | null
    birthDate?: Date | string | null
    gender?: GenderType | null
    image?: imagesCreateNestedOneWithoutUsersInput
    prefered_location?: locationsCreateNestedOneWithoutUsers_preferedInput
    locations?: locationsCreateNestedManyWithoutUsersInput
    platforms?: platformsCreateNestedManyWithoutUsersInput
    organizations?: organizationsCreateNestedManyWithoutUsersInput
    stores?: storesCreateNestedManyWithoutUsersInput
    payments_created?: paymentCreateNestedManyWithoutUser_creatorInput
    session?: sessionsCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutPayments_confirmedInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    email?: string | null
    phone?: string | null
    name?: string | null
    birthDate?: Date | string | null
    gender?: GenderType | null
    image_id?: string | null
    prefered_location_id?: string | null
    location_ids?: usersCreatelocation_idsInput | Enumerable<string>
    platform_ids?: usersCreateplatform_idsInput | Enumerable<string>
    organization_ids?: usersCreateorganization_idsInput | Enumerable<string>
    store_ids?: usersCreatestore_idsInput | Enumerable<string>
    locations?: locationsUncheckedCreateNestedManyWithoutUsersInput
    platforms?: platformsUncheckedCreateNestedManyWithoutUsersInput
    organizations?: organizationsUncheckedCreateNestedManyWithoutUsersInput
    stores?: storesUncheckedCreateNestedManyWithoutUsersInput
    payments_created?: paymentUncheckedCreateNestedManyWithoutUser_creatorInput
    session?: sessionsUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutPayments_confirmedInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutPayments_confirmedInput, usersUncheckedCreateWithoutPayments_confirmedInput>
  }

  export type PaymentAccountCreateWithoutPayments_receivedInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    amount: XOR<CurrencyCreateEnvelopeInput, CurrencyCreateInput>
    payments_sended?: paymentCreateNestedManyWithoutSender_accountInput
  }

  export type PaymentAccountUncheckedCreateWithoutPayments_receivedInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    amount: XOR<CurrencyCreateEnvelopeInput, CurrencyCreateInput>
    payments_sended?: paymentUncheckedCreateNestedManyWithoutSender_accountInput
  }

  export type PaymentAccountCreateOrConnectWithoutPayments_receivedInput = {
    where: PaymentAccountWhereUniqueInput
    create: XOR<PaymentAccountCreateWithoutPayments_receivedInput, PaymentAccountUncheckedCreateWithoutPayments_receivedInput>
  }

  export type PaymentAccountCreateWithoutPayments_sendedInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    amount: XOR<CurrencyCreateEnvelopeInput, CurrencyCreateInput>
    payments_received?: paymentCreateNestedManyWithoutRecever_accountInput
  }

  export type PaymentAccountUncheckedCreateWithoutPayments_sendedInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    amount: XOR<CurrencyCreateEnvelopeInput, CurrencyCreateInput>
    payments_received?: paymentUncheckedCreateNestedManyWithoutRecever_accountInput
  }

  export type PaymentAccountCreateOrConnectWithoutPayments_sendedInput = {
    where: PaymentAccountWhereUniqueInput
    create: XOR<PaymentAccountCreateWithoutPayments_sendedInput, PaymentAccountUncheckedCreateWithoutPayments_sendedInput>
  }

  export type CurrencyUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyTypeFieldUpdateOperationsInput | CurrencyType
  }

  export type PaymentTypeUpsertWithoutPaymentsInput = {
    update: XOR<PaymentTypeUpdateWithoutPaymentsInput, PaymentTypeUncheckedUpdateWithoutPaymentsInput>
    create: XOR<PaymentTypeCreateWithoutPaymentsInput, PaymentTypeUncheckedCreateWithoutPaymentsInput>
  }

  export type PaymentTypeUpdateWithoutPaymentsInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentTypeUncheckedUpdateWithoutPaymentsInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usersUpsertWithoutPayments_createdInput = {
    update: XOR<usersUpdateWithoutPayments_createdInput, usersUncheckedUpdateWithoutPayments_createdInput>
    create: XOR<usersCreateWithoutPayments_createdInput, usersUncheckedCreateWithoutPayments_createdInput>
  }

  export type usersUpdateWithoutPayments_createdInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    image?: imagesUpdateOneWithoutUsersNestedInput
    prefered_location?: locationsUpdateOneWithoutUsers_preferedNestedInput
    locations?: locationsUpdateManyWithoutUsersNestedInput
    platforms?: platformsUpdateManyWithoutUsersNestedInput
    organizations?: organizationsUpdateManyWithoutUsersNestedInput
    stores?: storesUpdateManyWithoutUsersNestedInput
    payments_confirmed?: paymentUpdateManyWithoutUser_confirmNestedInput
    session?: sessionsUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutPayments_createdInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    prefered_location_id?: NullableStringFieldUpdateOperationsInput | string | null
    location_ids?: usersUpdatelocation_idsInput | Enumerable<string>
    platform_ids?: usersUpdateplatform_idsInput | Enumerable<string>
    organization_ids?: usersUpdateorganization_idsInput | Enumerable<string>
    store_ids?: usersUpdatestore_idsInput | Enumerable<string>
    locations?: locationsUncheckedUpdateManyWithoutUsersNestedInput
    platforms?: platformsUncheckedUpdateManyWithoutUsersNestedInput
    organizations?: organizationsUncheckedUpdateManyWithoutUsersNestedInput
    stores?: storesUncheckedUpdateManyWithoutUsersNestedInput
    payments_confirmed?: paymentUncheckedUpdateManyWithoutUser_confirmNestedInput
    session?: sessionsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersUpsertWithoutPayments_confirmedInput = {
    update: XOR<usersUpdateWithoutPayments_confirmedInput, usersUncheckedUpdateWithoutPayments_confirmedInput>
    create: XOR<usersCreateWithoutPayments_confirmedInput, usersUncheckedCreateWithoutPayments_confirmedInput>
  }

  export type usersUpdateWithoutPayments_confirmedInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    image?: imagesUpdateOneWithoutUsersNestedInput
    prefered_location?: locationsUpdateOneWithoutUsers_preferedNestedInput
    locations?: locationsUpdateManyWithoutUsersNestedInput
    platforms?: platformsUpdateManyWithoutUsersNestedInput
    organizations?: organizationsUpdateManyWithoutUsersNestedInput
    stores?: storesUpdateManyWithoutUsersNestedInput
    payments_created?: paymentUpdateManyWithoutUser_creatorNestedInput
    session?: sessionsUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutPayments_confirmedInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    prefered_location_id?: NullableStringFieldUpdateOperationsInput | string | null
    location_ids?: usersUpdatelocation_idsInput | Enumerable<string>
    platform_ids?: usersUpdateplatform_idsInput | Enumerable<string>
    organization_ids?: usersUpdateorganization_idsInput | Enumerable<string>
    store_ids?: usersUpdatestore_idsInput | Enumerable<string>
    locations?: locationsUncheckedUpdateManyWithoutUsersNestedInput
    platforms?: platformsUncheckedUpdateManyWithoutUsersNestedInput
    organizations?: organizationsUncheckedUpdateManyWithoutUsersNestedInput
    stores?: storesUncheckedUpdateManyWithoutUsersNestedInput
    payments_created?: paymentUncheckedUpdateManyWithoutUser_creatorNestedInput
    session?: sessionsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PaymentAccountUpsertWithoutPayments_receivedInput = {
    update: XOR<PaymentAccountUpdateWithoutPayments_receivedInput, PaymentAccountUncheckedUpdateWithoutPayments_receivedInput>
    create: XOR<PaymentAccountCreateWithoutPayments_receivedInput, PaymentAccountUncheckedCreateWithoutPayments_receivedInput>
  }

  export type PaymentAccountUpdateWithoutPayments_receivedInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    amount?: XOR<CurrencyUpdateEnvelopeInput, CurrencyCreateInput>
    payments_sended?: paymentUpdateManyWithoutSender_accountNestedInput
  }

  export type PaymentAccountUncheckedUpdateWithoutPayments_receivedInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    amount?: XOR<CurrencyUpdateEnvelopeInput, CurrencyCreateInput>
    payments_sended?: paymentUncheckedUpdateManyWithoutSender_accountNestedInput
  }

  export type PaymentAccountUpsertWithoutPayments_sendedInput = {
    update: XOR<PaymentAccountUpdateWithoutPayments_sendedInput, PaymentAccountUncheckedUpdateWithoutPayments_sendedInput>
    create: XOR<PaymentAccountCreateWithoutPayments_sendedInput, PaymentAccountUncheckedCreateWithoutPayments_sendedInput>
  }

  export type PaymentAccountUpdateWithoutPayments_sendedInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    amount?: XOR<CurrencyUpdateEnvelopeInput, CurrencyCreateInput>
    payments_received?: paymentUpdateManyWithoutRecever_accountNestedInput
  }

  export type PaymentAccountUncheckedUpdateWithoutPayments_sendedInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    amount?: XOR<CurrencyUpdateEnvelopeInput, CurrencyCreateInput>
    payments_received?: paymentUncheckedUpdateManyWithoutRecever_accountNestedInput
  }

  export type paymentCreateWithoutRecever_accountInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    title?: string | null
    description?: string | null
    amount: XOR<CurrencyCreateEnvelopeInput, CurrencyCreateInput>
    payment_type: PaymentTypeCreateNestedOneWithoutPaymentsInput
    user_creator: usersCreateNestedOneWithoutPayments_createdInput
    user_confirm: usersCreateNestedOneWithoutPayments_confirmedInput
    sender_account: PaymentAccountCreateNestedOneWithoutPayments_sendedInput
  }

  export type paymentUncheckedCreateWithoutRecever_accountInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    title?: string | null
    description?: string | null
    payment_type_id: string
    user_creator_id: string
    user_confirm_id: string
    sender_account_id: string
    amount: XOR<CurrencyCreateEnvelopeInput, CurrencyCreateInput>
  }

  export type paymentCreateOrConnectWithoutRecever_accountInput = {
    where: paymentWhereUniqueInput
    create: XOR<paymentCreateWithoutRecever_accountInput, paymentUncheckedCreateWithoutRecever_accountInput>
  }

  export type paymentCreateManyRecever_accountInputEnvelope = {
    data: Enumerable<paymentCreateManyRecever_accountInput>
  }

  export type paymentCreateWithoutSender_accountInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    title?: string | null
    description?: string | null
    amount: XOR<CurrencyCreateEnvelopeInput, CurrencyCreateInput>
    payment_type: PaymentTypeCreateNestedOneWithoutPaymentsInput
    user_creator: usersCreateNestedOneWithoutPayments_createdInput
    user_confirm: usersCreateNestedOneWithoutPayments_confirmedInput
    recever_account: PaymentAccountCreateNestedOneWithoutPayments_receivedInput
  }

  export type paymentUncheckedCreateWithoutSender_accountInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    title?: string | null
    description?: string | null
    payment_type_id: string
    user_creator_id: string
    user_confirm_id: string
    receiver_account_id: string
    amount: XOR<CurrencyCreateEnvelopeInput, CurrencyCreateInput>
  }

  export type paymentCreateOrConnectWithoutSender_accountInput = {
    where: paymentWhereUniqueInput
    create: XOR<paymentCreateWithoutSender_accountInput, paymentUncheckedCreateWithoutSender_accountInput>
  }

  export type paymentCreateManySender_accountInputEnvelope = {
    data: Enumerable<paymentCreateManySender_accountInput>
  }

  export type paymentUpsertWithWhereUniqueWithoutRecever_accountInput = {
    where: paymentWhereUniqueInput
    update: XOR<paymentUpdateWithoutRecever_accountInput, paymentUncheckedUpdateWithoutRecever_accountInput>
    create: XOR<paymentCreateWithoutRecever_accountInput, paymentUncheckedCreateWithoutRecever_accountInput>
  }

  export type paymentUpdateWithWhereUniqueWithoutRecever_accountInput = {
    where: paymentWhereUniqueInput
    data: XOR<paymentUpdateWithoutRecever_accountInput, paymentUncheckedUpdateWithoutRecever_accountInput>
  }

  export type paymentUpdateManyWithWhereWithoutRecever_accountInput = {
    where: paymentScalarWhereInput
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyWithoutPayments_receivedInput>
  }

  export type paymentUpsertWithWhereUniqueWithoutSender_accountInput = {
    where: paymentWhereUniqueInput
    update: XOR<paymentUpdateWithoutSender_accountInput, paymentUncheckedUpdateWithoutSender_accountInput>
    create: XOR<paymentCreateWithoutSender_accountInput, paymentUncheckedCreateWithoutSender_accountInput>
  }

  export type paymentUpdateWithWhereUniqueWithoutSender_accountInput = {
    where: paymentWhereUniqueInput
    data: XOR<paymentUpdateWithoutSender_accountInput, paymentUncheckedUpdateWithoutSender_accountInput>
  }

  export type paymentUpdateManyWithWhereWithoutSender_accountInput = {
    where: paymentScalarWhereInput
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyWithoutPayments_sendedInput>
  }

  export type imagesCreateWithoutItemsInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    key: string
    url?: string | null
    clipped_key?: string | null
    clipped_url?: string | null
    platforms?: platformsCreateNestedManyWithoutImageInput
    providers?: providersCreateNestedManyWithoutImageInput
    organizations?: organizationsCreateNestedManyWithoutImageInput
    stores?: storesCreateNestedManyWithoutImageInput
    users?: usersCreateNestedManyWithoutImageInput
  }

  export type imagesUncheckedCreateWithoutItemsInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    key: string
    url?: string | null
    clipped_key?: string | null
    clipped_url?: string | null
    item_ids?: imagesCreateitem_idsInput | Enumerable<string>
    platforms?: platformsUncheckedCreateNestedManyWithoutImageInput
    providers?: providersUncheckedCreateNestedManyWithoutImageInput
    organizations?: organizationsUncheckedCreateNestedManyWithoutImageInput
    stores?: storesUncheckedCreateNestedManyWithoutImageInput
    users?: usersUncheckedCreateNestedManyWithoutImageInput
  }

  export type imagesCreateOrConnectWithoutItemsInput = {
    where: imagesWhereUniqueInput
    create: XOR<imagesCreateWithoutItemsInput, imagesUncheckedCreateWithoutItemsInput>
  }

  export type item_inventoriesCreateWithoutItemInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    type: ItemQualitativeType
    value: number
    inventories?: inventoriesCreateNestedManyWithoutItem_inventoriesInput
  }

  export type item_inventoriesUncheckedCreateWithoutItemInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    type: ItemQualitativeType
    value: number
    iventory_ids?: item_inventoriesCreateiventory_idsInput | Enumerable<string>
    inventories?: inventoriesUncheckedCreateNestedManyWithoutItem_inventoriesInput
  }

  export type item_inventoriesCreateOrConnectWithoutItemInput = {
    where: item_inventoriesWhereUniqueInput
    create: XOR<item_inventoriesCreateWithoutItemInput, item_inventoriesUncheckedCreateWithoutItemInput>
  }

  export type item_inventoriesCreateManyItemInputEnvelope = {
    data: Enumerable<item_inventoriesCreateManyItemInput>
  }

  export type item_ordersCreateWithoutItemInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    type: ItemQualitativeType
    value: number
    orders?: odersCreateNestedManyWithoutItem_ordersInput
  }

  export type item_ordersUncheckedCreateWithoutItemInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    type: ItemQualitativeType
    value: number
    order_ids?: item_ordersCreateorder_idsInput | Enumerable<string>
    orders?: odersUncheckedCreateNestedManyWithoutItem_ordersInput
  }

  export type item_ordersCreateOrConnectWithoutItemInput = {
    where: item_ordersWhereUniqueInput
    create: XOR<item_ordersCreateWithoutItemInput, item_ordersUncheckedCreateWithoutItemInput>
  }

  export type item_ordersCreateManyItemInputEnvelope = {
    data: Enumerable<item_ordersCreateManyItemInput>
  }

  export type CurrencyUpdateManyInput = {
    where: CurrencyWhereInput
    data: CurrencyUpdateInput
  }

  export type CurrencyDeleteManyInput = {
    where: CurrencyWhereInput
  }

  export type imagesUpsertWithWhereUniqueWithoutItemsInput = {
    where: imagesWhereUniqueInput
    update: XOR<imagesUpdateWithoutItemsInput, imagesUncheckedUpdateWithoutItemsInput>
    create: XOR<imagesCreateWithoutItemsInput, imagesUncheckedCreateWithoutItemsInput>
  }

  export type imagesUpdateWithWhereUniqueWithoutItemsInput = {
    where: imagesWhereUniqueInput
    data: XOR<imagesUpdateWithoutItemsInput, imagesUncheckedUpdateWithoutItemsInput>
  }

  export type imagesUpdateManyWithWhereWithoutItemsInput = {
    where: imagesScalarWhereInput
    data: XOR<imagesUpdateManyMutationInput, imagesUncheckedUpdateManyWithoutImagesInput>
  }

  export type imagesScalarWhereInput = {
    AND?: Enumerable<imagesScalarWhereInput>
    OR?: Enumerable<imagesScalarWhereInput>
    NOT?: Enumerable<imagesScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
    key?: StringFilter | string
    url?: StringNullableFilter | string | null
    clipped_key?: StringNullableFilter | string | null
    clipped_url?: StringNullableFilter | string | null
    item_ids?: StringNullableListFilter
  }

  export type item_inventoriesUpsertWithWhereUniqueWithoutItemInput = {
    where: item_inventoriesWhereUniqueInput
    update: XOR<item_inventoriesUpdateWithoutItemInput, item_inventoriesUncheckedUpdateWithoutItemInput>
    create: XOR<item_inventoriesCreateWithoutItemInput, item_inventoriesUncheckedCreateWithoutItemInput>
  }

  export type item_inventoriesUpdateWithWhereUniqueWithoutItemInput = {
    where: item_inventoriesWhereUniqueInput
    data: XOR<item_inventoriesUpdateWithoutItemInput, item_inventoriesUncheckedUpdateWithoutItemInput>
  }

  export type item_inventoriesUpdateManyWithWhereWithoutItemInput = {
    where: item_inventoriesScalarWhereInput
    data: XOR<item_inventoriesUpdateManyMutationInput, item_inventoriesUncheckedUpdateManyWithoutItem_inventoriesInput>
  }

  export type item_ordersUpsertWithWhereUniqueWithoutItemInput = {
    where: item_ordersWhereUniqueInput
    update: XOR<item_ordersUpdateWithoutItemInput, item_ordersUncheckedUpdateWithoutItemInput>
    create: XOR<item_ordersCreateWithoutItemInput, item_ordersUncheckedCreateWithoutItemInput>
  }

  export type item_ordersUpdateWithWhereUniqueWithoutItemInput = {
    where: item_ordersWhereUniqueInput
    data: XOR<item_ordersUpdateWithoutItemInput, item_ordersUncheckedUpdateWithoutItemInput>
  }

  export type item_ordersUpdateManyWithWhereWithoutItemInput = {
    where: item_ordersScalarWhereInput
    data: XOR<item_ordersUpdateManyMutationInput, item_ordersUncheckedUpdateManyWithoutItem_ordersInput>
  }

  export type usersCreateWithoutLocationsInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    email?: string | null
    phone?: string | null
    name?: string | null
    birthDate?: Date | string | null
    gender?: GenderType | null
    image?: imagesCreateNestedOneWithoutUsersInput
    prefered_location?: locationsCreateNestedOneWithoutUsers_preferedInput
    platforms?: platformsCreateNestedManyWithoutUsersInput
    organizations?: organizationsCreateNestedManyWithoutUsersInput
    stores?: storesCreateNestedManyWithoutUsersInput
    payments_created?: paymentCreateNestedManyWithoutUser_creatorInput
    payments_confirmed?: paymentCreateNestedManyWithoutUser_confirmInput
    session?: sessionsCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutLocationsInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    email?: string | null
    phone?: string | null
    name?: string | null
    birthDate?: Date | string | null
    gender?: GenderType | null
    image_id?: string | null
    prefered_location_id?: string | null
    location_ids?: usersCreatelocation_idsInput | Enumerable<string>
    platform_ids?: usersCreateplatform_idsInput | Enumerable<string>
    organization_ids?: usersCreateorganization_idsInput | Enumerable<string>
    store_ids?: usersCreatestore_idsInput | Enumerable<string>
    platforms?: platformsUncheckedCreateNestedManyWithoutUsersInput
    organizations?: organizationsUncheckedCreateNestedManyWithoutUsersInput
    stores?: storesUncheckedCreateNestedManyWithoutUsersInput
    payments_created?: paymentUncheckedCreateNestedManyWithoutUser_creatorInput
    payments_confirmed?: paymentUncheckedCreateNestedManyWithoutUser_confirmInput
    session?: sessionsUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutLocationsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutLocationsInput, usersUncheckedCreateWithoutLocationsInput>
  }

  export type organizationsCreateWithoutLocationsInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    name?: string | null
    image?: imagesCreateNestedOneWithoutOrganizationsInput
    platforms?: platformsCreateNestedManyWithoutOrganizationsInput
    users?: usersCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsUncheckedCreateWithoutLocationsInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    name?: string | null
    image_id?: string | null
    platform_ids?: organizationsCreateplatform_idsInput | Enumerable<string>
    user_ids?: organizationsCreateuser_idsInput | Enumerable<string>
    location_ids?: organizationsCreatelocation_idsInput | Enumerable<string>
    platforms?: platformsUncheckedCreateNestedManyWithoutOrganizationsInput
    users?: usersUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsCreateOrConnectWithoutLocationsInput = {
    where: organizationsWhereUniqueInput
    create: XOR<organizationsCreateWithoutLocationsInput, organizationsUncheckedCreateWithoutLocationsInput>
  }

  export type storesCreateWithoutLocationsInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    name?: string | null
    image?: imagesCreateNestedOneWithoutStoresInput
    users?: usersCreateNestedManyWithoutStoresInput
    inventories?: inventoriesCreateNestedManyWithoutStoresInput
  }

  export type storesUncheckedCreateWithoutLocationsInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    name?: string | null
    image_id?: string | null
    user_ids?: storesCreateuser_idsInput | Enumerable<string>
    location_ids?: storesCreatelocation_idsInput | Enumerable<string>
    inventory_ids?: storesCreateinventory_idsInput | Enumerable<string>
    users?: usersUncheckedCreateNestedManyWithoutStoresInput
    inventories?: inventoriesUncheckedCreateNestedManyWithoutStoresInput
  }

  export type storesCreateOrConnectWithoutLocationsInput = {
    where: storesWhereUniqueInput
    create: XOR<storesCreateWithoutLocationsInput, storesUncheckedCreateWithoutLocationsInput>
  }

  export type usersCreateWithoutPrefered_locationInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    email?: string | null
    phone?: string | null
    name?: string | null
    birthDate?: Date | string | null
    gender?: GenderType | null
    image?: imagesCreateNestedOneWithoutUsersInput
    locations?: locationsCreateNestedManyWithoutUsersInput
    platforms?: platformsCreateNestedManyWithoutUsersInput
    organizations?: organizationsCreateNestedManyWithoutUsersInput
    stores?: storesCreateNestedManyWithoutUsersInput
    payments_created?: paymentCreateNestedManyWithoutUser_creatorInput
    payments_confirmed?: paymentCreateNestedManyWithoutUser_confirmInput
    session?: sessionsCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutPrefered_locationInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    email?: string | null
    phone?: string | null
    name?: string | null
    birthDate?: Date | string | null
    gender?: GenderType | null
    image_id?: string | null
    location_ids?: usersCreatelocation_idsInput | Enumerable<string>
    platform_ids?: usersCreateplatform_idsInput | Enumerable<string>
    organization_ids?: usersCreateorganization_idsInput | Enumerable<string>
    store_ids?: usersCreatestore_idsInput | Enumerable<string>
    locations?: locationsUncheckedCreateNestedManyWithoutUsersInput
    platforms?: platformsUncheckedCreateNestedManyWithoutUsersInput
    organizations?: organizationsUncheckedCreateNestedManyWithoutUsersInput
    stores?: storesUncheckedCreateNestedManyWithoutUsersInput
    payments_created?: paymentUncheckedCreateNestedManyWithoutUser_creatorInput
    payments_confirmed?: paymentUncheckedCreateNestedManyWithoutUser_confirmInput
    session?: sessionsUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutPrefered_locationInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutPrefered_locationInput, usersUncheckedCreateWithoutPrefered_locationInput>
  }

  export type usersCreateManyPrefered_locationInputEnvelope = {
    data: Enumerable<usersCreateManyPrefered_locationInput>
  }

  export type usersUpsertWithWhereUniqueWithoutLocationsInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutLocationsInput, usersUncheckedUpdateWithoutLocationsInput>
    create: XOR<usersCreateWithoutLocationsInput, usersUncheckedCreateWithoutLocationsInput>
  }

  export type usersUpdateWithWhereUniqueWithoutLocationsInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutLocationsInput, usersUncheckedUpdateWithoutLocationsInput>
  }

  export type usersUpdateManyWithWhereWithoutLocationsInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutUsersInput>
  }

  export type organizationsUpsertWithWhereUniqueWithoutLocationsInput = {
    where: organizationsWhereUniqueInput
    update: XOR<organizationsUpdateWithoutLocationsInput, organizationsUncheckedUpdateWithoutLocationsInput>
    create: XOR<organizationsCreateWithoutLocationsInput, organizationsUncheckedCreateWithoutLocationsInput>
  }

  export type organizationsUpdateWithWhereUniqueWithoutLocationsInput = {
    where: organizationsWhereUniqueInput
    data: XOR<organizationsUpdateWithoutLocationsInput, organizationsUncheckedUpdateWithoutLocationsInput>
  }

  export type organizationsUpdateManyWithWhereWithoutLocationsInput = {
    where: organizationsScalarWhereInput
    data: XOR<organizationsUpdateManyMutationInput, organizationsUncheckedUpdateManyWithoutOrganizationsInput>
  }

  export type storesUpsertWithWhereUniqueWithoutLocationsInput = {
    where: storesWhereUniqueInput
    update: XOR<storesUpdateWithoutLocationsInput, storesUncheckedUpdateWithoutLocationsInput>
    create: XOR<storesCreateWithoutLocationsInput, storesUncheckedCreateWithoutLocationsInput>
  }

  export type storesUpdateWithWhereUniqueWithoutLocationsInput = {
    where: storesWhereUniqueInput
    data: XOR<storesUpdateWithoutLocationsInput, storesUncheckedUpdateWithoutLocationsInput>
  }

  export type storesUpdateManyWithWhereWithoutLocationsInput = {
    where: storesScalarWhereInput
    data: XOR<storesUpdateManyMutationInput, storesUncheckedUpdateManyWithoutStoresInput>
  }

  export type usersUpsertWithWhereUniqueWithoutPrefered_locationInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutPrefered_locationInput, usersUncheckedUpdateWithoutPrefered_locationInput>
    create: XOR<usersCreateWithoutPrefered_locationInput, usersUncheckedCreateWithoutPrefered_locationInput>
  }

  export type usersUpdateWithWhereUniqueWithoutPrefered_locationInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutPrefered_locationInput, usersUncheckedUpdateWithoutPrefered_locationInput>
  }

  export type usersUpdateManyWithWhereWithoutPrefered_locationInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutUsers_preferedInput>
  }

  export type usersCreateWithoutSessionInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    email?: string | null
    phone?: string | null
    name?: string | null
    birthDate?: Date | string | null
    gender?: GenderType | null
    image?: imagesCreateNestedOneWithoutUsersInput
    prefered_location?: locationsCreateNestedOneWithoutUsers_preferedInput
    locations?: locationsCreateNestedManyWithoutUsersInput
    platforms?: platformsCreateNestedManyWithoutUsersInput
    organizations?: organizationsCreateNestedManyWithoutUsersInput
    stores?: storesCreateNestedManyWithoutUsersInput
    payments_created?: paymentCreateNestedManyWithoutUser_creatorInput
    payments_confirmed?: paymentCreateNestedManyWithoutUser_confirmInput
  }

  export type usersUncheckedCreateWithoutSessionInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    email?: string | null
    phone?: string | null
    name?: string | null
    birthDate?: Date | string | null
    gender?: GenderType | null
    image_id?: string | null
    prefered_location_id?: string | null
    location_ids?: usersCreatelocation_idsInput | Enumerable<string>
    platform_ids?: usersCreateplatform_idsInput | Enumerable<string>
    organization_ids?: usersCreateorganization_idsInput | Enumerable<string>
    store_ids?: usersCreatestore_idsInput | Enumerable<string>
    locations?: locationsUncheckedCreateNestedManyWithoutUsersInput
    platforms?: platformsUncheckedCreateNestedManyWithoutUsersInput
    organizations?: organizationsUncheckedCreateNestedManyWithoutUsersInput
    stores?: storesUncheckedCreateNestedManyWithoutUsersInput
    payments_created?: paymentUncheckedCreateNestedManyWithoutUser_creatorInput
    payments_confirmed?: paymentUncheckedCreateNestedManyWithoutUser_confirmInput
  }

  export type usersCreateOrConnectWithoutSessionInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSessionInput, usersUncheckedCreateWithoutSessionInput>
  }

  export type usersUpsertWithoutSessionInput = {
    update: XOR<usersUpdateWithoutSessionInput, usersUncheckedUpdateWithoutSessionInput>
    create: XOR<usersCreateWithoutSessionInput, usersUncheckedCreateWithoutSessionInput>
  }

  export type usersUpdateWithoutSessionInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    image?: imagesUpdateOneWithoutUsersNestedInput
    prefered_location?: locationsUpdateOneWithoutUsers_preferedNestedInput
    locations?: locationsUpdateManyWithoutUsersNestedInput
    platforms?: platformsUpdateManyWithoutUsersNestedInput
    organizations?: organizationsUpdateManyWithoutUsersNestedInput
    stores?: storesUpdateManyWithoutUsersNestedInput
    payments_created?: paymentUpdateManyWithoutUser_creatorNestedInput
    payments_confirmed?: paymentUpdateManyWithoutUser_confirmNestedInput
  }

  export type usersUncheckedUpdateWithoutSessionInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    prefered_location_id?: NullableStringFieldUpdateOperationsInput | string | null
    location_ids?: usersUpdatelocation_idsInput | Enumerable<string>
    platform_ids?: usersUpdateplatform_idsInput | Enumerable<string>
    organization_ids?: usersUpdateorganization_idsInput | Enumerable<string>
    store_ids?: usersUpdatestore_idsInput | Enumerable<string>
    locations?: locationsUncheckedUpdateManyWithoutUsersNestedInput
    platforms?: platformsUncheckedUpdateManyWithoutUsersNestedInput
    organizations?: organizationsUncheckedUpdateManyWithoutUsersNestedInput
    stores?: storesUncheckedUpdateManyWithoutUsersNestedInput
    payments_created?: paymentUncheckedUpdateManyWithoutUser_creatorNestedInput
    payments_confirmed?: paymentUncheckedUpdateManyWithoutUser_confirmNestedInput
  }

  export type platformsCreateWithoutImageInput = {
    id?: string
    uuid?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    key: string
    username?: string | null
    name?: string | null
    providers?: providersCreateNestedManyWithoutPlatformsInput
    provider_keys?: provider_keysCreateNestedManyWithoutPlatformsInput
    users?: usersCreateNestedManyWithoutPlatformsInput
    organizations?: organizationsCreateNestedManyWithoutPlatformsInput
  }

  export type platformsUncheckedCreateWithoutImageInput = {
    id?: string
    uuid?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    key: string
    username?: string | null
    name?: string | null
    provider_ids?: platformsCreateprovider_idsInput | Enumerable<string>
    provider_key_ids?: platformsCreateprovider_key_idsInput | Enumerable<string>
    user_ids?: platformsCreateuser_idsInput | Enumerable<string>
    organization_ids?: platformsCreateorganization_idsInput | Enumerable<string>
    providers?: providersUncheckedCreateNestedManyWithoutPlatformsInput
    provider_keys?: provider_keysUncheckedCreateNestedManyWithoutPlatformsInput
    users?: usersUncheckedCreateNestedManyWithoutPlatformsInput
    organizations?: organizationsUncheckedCreateNestedManyWithoutPlatformsInput
  }

  export type platformsCreateOrConnectWithoutImageInput = {
    where: platformsWhereUniqueInput
    create: XOR<platformsCreateWithoutImageInput, platformsUncheckedCreateWithoutImageInput>
  }

  export type platformsCreateManyImageInputEnvelope = {
    data: Enumerable<platformsCreateManyImageInput>
  }

  export type providersCreateWithoutImageInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    key: string
    name?: string | null
    provider_key_ids?: providersCreateprovider_key_idsInput | Enumerable<string>
    platforms?: platformsCreateNestedManyWithoutProvidersInput
    provider_keys?: provider_keysCreateNestedManyWithoutProviderInput
  }

  export type providersUncheckedCreateWithoutImageInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    key: string
    name?: string | null
    platform_ids?: providersCreateplatform_idsInput | Enumerable<string>
    provider_key_ids?: providersCreateprovider_key_idsInput | Enumerable<string>
    platforms?: platformsUncheckedCreateNestedManyWithoutProvidersInput
    provider_keys?: provider_keysUncheckedCreateNestedManyWithoutProviderInput
  }

  export type providersCreateOrConnectWithoutImageInput = {
    where: providersWhereUniqueInput
    create: XOR<providersCreateWithoutImageInput, providersUncheckedCreateWithoutImageInput>
  }

  export type providersCreateManyImageInputEnvelope = {
    data: Enumerable<providersCreateManyImageInput>
  }

  export type organizationsCreateWithoutImageInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    name?: string | null
    platforms?: platformsCreateNestedManyWithoutOrganizationsInput
    users?: usersCreateNestedManyWithoutOrganizationsInput
    locations?: locationsCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsUncheckedCreateWithoutImageInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    name?: string | null
    platform_ids?: organizationsCreateplatform_idsInput | Enumerable<string>
    user_ids?: organizationsCreateuser_idsInput | Enumerable<string>
    location_ids?: organizationsCreatelocation_idsInput | Enumerable<string>
    platforms?: platformsUncheckedCreateNestedManyWithoutOrganizationsInput
    users?: usersUncheckedCreateNestedManyWithoutOrganizationsInput
    locations?: locationsUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsCreateOrConnectWithoutImageInput = {
    where: organizationsWhereUniqueInput
    create: XOR<organizationsCreateWithoutImageInput, organizationsUncheckedCreateWithoutImageInput>
  }

  export type organizationsCreateManyImageInputEnvelope = {
    data: Enumerable<organizationsCreateManyImageInput>
  }

  export type storesCreateWithoutImageInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    name?: string | null
    users?: usersCreateNestedManyWithoutStoresInput
    locations?: locationsCreateNestedManyWithoutStoresInput
    inventories?: inventoriesCreateNestedManyWithoutStoresInput
  }

  export type storesUncheckedCreateWithoutImageInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    name?: string | null
    user_ids?: storesCreateuser_idsInput | Enumerable<string>
    location_ids?: storesCreatelocation_idsInput | Enumerable<string>
    inventory_ids?: storesCreateinventory_idsInput | Enumerable<string>
    users?: usersUncheckedCreateNestedManyWithoutStoresInput
    locations?: locationsUncheckedCreateNestedManyWithoutStoresInput
    inventories?: inventoriesUncheckedCreateNestedManyWithoutStoresInput
  }

  export type storesCreateOrConnectWithoutImageInput = {
    where: storesWhereUniqueInput
    create: XOR<storesCreateWithoutImageInput, storesUncheckedCreateWithoutImageInput>
  }

  export type storesCreateManyImageInputEnvelope = {
    data: Enumerable<storesCreateManyImageInput>
  }

  export type usersCreateWithoutImageInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    email?: string | null
    phone?: string | null
    name?: string | null
    birthDate?: Date | string | null
    gender?: GenderType | null
    prefered_location?: locationsCreateNestedOneWithoutUsers_preferedInput
    locations?: locationsCreateNestedManyWithoutUsersInput
    platforms?: platformsCreateNestedManyWithoutUsersInput
    organizations?: organizationsCreateNestedManyWithoutUsersInput
    stores?: storesCreateNestedManyWithoutUsersInput
    payments_created?: paymentCreateNestedManyWithoutUser_creatorInput
    payments_confirmed?: paymentCreateNestedManyWithoutUser_confirmInput
    session?: sessionsCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutImageInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    email?: string | null
    phone?: string | null
    name?: string | null
    birthDate?: Date | string | null
    gender?: GenderType | null
    prefered_location_id?: string | null
    location_ids?: usersCreatelocation_idsInput | Enumerable<string>
    platform_ids?: usersCreateplatform_idsInput | Enumerable<string>
    organization_ids?: usersCreateorganization_idsInput | Enumerable<string>
    store_ids?: usersCreatestore_idsInput | Enumerable<string>
    locations?: locationsUncheckedCreateNestedManyWithoutUsersInput
    platforms?: platformsUncheckedCreateNestedManyWithoutUsersInput
    organizations?: organizationsUncheckedCreateNestedManyWithoutUsersInput
    stores?: storesUncheckedCreateNestedManyWithoutUsersInput
    payments_created?: paymentUncheckedCreateNestedManyWithoutUser_creatorInput
    payments_confirmed?: paymentUncheckedCreateNestedManyWithoutUser_confirmInput
    session?: sessionsUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutImageInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutImageInput, usersUncheckedCreateWithoutImageInput>
  }

  export type usersCreateManyImageInputEnvelope = {
    data: Enumerable<usersCreateManyImageInput>
  }

  export type itemsCreateWithoutImagesInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    name?: string | null
    description?: string | null
    tags?: itemsCreatetagsInput | Enumerable<string>
    prices?: XOR<CurrencyListCreateEnvelopeInput, Enumerable<CurrencyCreateInput>>
    item_inventories?: item_inventoriesCreateNestedManyWithoutItemInput
    item_orders?: item_ordersCreateNestedManyWithoutItemInput
  }

  export type itemsUncheckedCreateWithoutImagesInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    name?: string | null
    description?: string | null
    tags?: itemsCreatetagsInput | Enumerable<string>
    image_ids?: itemsCreateimage_idsInput | Enumerable<string>
    prices?: XOR<CurrencyListCreateEnvelopeInput, Enumerable<CurrencyCreateInput>>
    item_inventories?: item_inventoriesUncheckedCreateNestedManyWithoutItemInput
    item_orders?: item_ordersUncheckedCreateNestedManyWithoutItemInput
  }

  export type itemsCreateOrConnectWithoutImagesInput = {
    where: itemsWhereUniqueInput
    create: XOR<itemsCreateWithoutImagesInput, itemsUncheckedCreateWithoutImagesInput>
  }

  export type platformsUpsertWithWhereUniqueWithoutImageInput = {
    where: platformsWhereUniqueInput
    update: XOR<platformsUpdateWithoutImageInput, platformsUncheckedUpdateWithoutImageInput>
    create: XOR<platformsCreateWithoutImageInput, platformsUncheckedCreateWithoutImageInput>
  }

  export type platformsUpdateWithWhereUniqueWithoutImageInput = {
    where: platformsWhereUniqueInput
    data: XOR<platformsUpdateWithoutImageInput, platformsUncheckedUpdateWithoutImageInput>
  }

  export type platformsUpdateManyWithWhereWithoutImageInput = {
    where: platformsScalarWhereInput
    data: XOR<platformsUpdateManyMutationInput, platformsUncheckedUpdateManyWithoutPlatformsInput>
  }

  export type providersUpsertWithWhereUniqueWithoutImageInput = {
    where: providersWhereUniqueInput
    update: XOR<providersUpdateWithoutImageInput, providersUncheckedUpdateWithoutImageInput>
    create: XOR<providersCreateWithoutImageInput, providersUncheckedCreateWithoutImageInput>
  }

  export type providersUpdateWithWhereUniqueWithoutImageInput = {
    where: providersWhereUniqueInput
    data: XOR<providersUpdateWithoutImageInput, providersUncheckedUpdateWithoutImageInput>
  }

  export type providersUpdateManyWithWhereWithoutImageInput = {
    where: providersScalarWhereInput
    data: XOR<providersUpdateManyMutationInput, providersUncheckedUpdateManyWithoutProvidersInput>
  }

  export type organizationsUpsertWithWhereUniqueWithoutImageInput = {
    where: organizationsWhereUniqueInput
    update: XOR<organizationsUpdateWithoutImageInput, organizationsUncheckedUpdateWithoutImageInput>
    create: XOR<organizationsCreateWithoutImageInput, organizationsUncheckedCreateWithoutImageInput>
  }

  export type organizationsUpdateWithWhereUniqueWithoutImageInput = {
    where: organizationsWhereUniqueInput
    data: XOR<organizationsUpdateWithoutImageInput, organizationsUncheckedUpdateWithoutImageInput>
  }

  export type organizationsUpdateManyWithWhereWithoutImageInput = {
    where: organizationsScalarWhereInput
    data: XOR<organizationsUpdateManyMutationInput, organizationsUncheckedUpdateManyWithoutOrganizationsInput>
  }

  export type storesUpsertWithWhereUniqueWithoutImageInput = {
    where: storesWhereUniqueInput
    update: XOR<storesUpdateWithoutImageInput, storesUncheckedUpdateWithoutImageInput>
    create: XOR<storesCreateWithoutImageInput, storesUncheckedCreateWithoutImageInput>
  }

  export type storesUpdateWithWhereUniqueWithoutImageInput = {
    where: storesWhereUniqueInput
    data: XOR<storesUpdateWithoutImageInput, storesUncheckedUpdateWithoutImageInput>
  }

  export type storesUpdateManyWithWhereWithoutImageInput = {
    where: storesScalarWhereInput
    data: XOR<storesUpdateManyMutationInput, storesUncheckedUpdateManyWithoutStoresInput>
  }

  export type usersUpsertWithWhereUniqueWithoutImageInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutImageInput, usersUncheckedUpdateWithoutImageInput>
    create: XOR<usersCreateWithoutImageInput, usersUncheckedCreateWithoutImageInput>
  }

  export type usersUpdateWithWhereUniqueWithoutImageInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutImageInput, usersUncheckedUpdateWithoutImageInput>
  }

  export type usersUpdateManyWithWhereWithoutImageInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutUsersInput>
  }

  export type itemsUpsertWithWhereUniqueWithoutImagesInput = {
    where: itemsWhereUniqueInput
    update: XOR<itemsUpdateWithoutImagesInput, itemsUncheckedUpdateWithoutImagesInput>
    create: XOR<itemsCreateWithoutImagesInput, itemsUncheckedCreateWithoutImagesInput>
  }

  export type itemsUpdateWithWhereUniqueWithoutImagesInput = {
    where: itemsWhereUniqueInput
    data: XOR<itemsUpdateWithoutImagesInput, itemsUncheckedUpdateWithoutImagesInput>
  }

  export type itemsUpdateManyWithWhereWithoutImagesInput = {
    where: itemsScalarWhereInput
    data: XOR<itemsUpdateManyMutationInput, itemsUncheckedUpdateManyWithoutItemsInput>
  }

  export type itemsScalarWhereInput = {
    AND?: Enumerable<itemsScalarWhereInput>
    OR?: Enumerable<itemsScalarWhereInput>
    NOT?: Enumerable<itemsScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    uuid?: StringFilter | string
    name?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    tags?: StringNullableListFilter
    image_ids?: StringNullableListFilter
  }

  export type EnumCurrencyTypeFilter = {
    equals?: CurrencyType
    in?: Enumerable<CurrencyType>
    notIn?: Enumerable<CurrencyType>
    not?: NestedEnumCurrencyTypeFilter | CurrencyType
  }

  export type providersUpdateWithoutPlatformsInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    provider_key_ids?: providersUpdateprovider_key_idsInput | Enumerable<string>
    image?: imagesUpdateOneWithoutProvidersNestedInput
    provider_keys?: provider_keysUpdateManyWithoutProviderNestedInput
  }

  export type providersUncheckedUpdateWithoutPlatformsInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    platform_ids?: providersUpdateplatform_idsInput | Enumerable<string>
    provider_key_ids?: providersUpdateprovider_key_idsInput | Enumerable<string>
    provider_keys?: provider_keysUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type providersUncheckedUpdateManyWithoutProvidersInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    platform_ids?: providersUpdateplatform_idsInput | Enumerable<string>
    provider_key_ids?: providersUpdateprovider_key_idsInput | Enumerable<string>
  }

  export type provider_keysUpdateWithoutPlatformsInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    public_key?: StringFieldUpdateOperationsInput | string
    private_key?: StringFieldUpdateOperationsInput | string
    secret?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: providersUpdateOneRequiredWithoutProvider_keysNestedInput
  }

  export type provider_keysUncheckedUpdateWithoutPlatformsInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    public_key?: StringFieldUpdateOperationsInput | string
    private_key?: StringFieldUpdateOperationsInput | string
    secret?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    provider_id?: StringFieldUpdateOperationsInput | string
    platform_ids?: provider_keysUpdateplatform_idsInput | Enumerable<string>
  }

  export type provider_keysUncheckedUpdateManyWithoutProvider_keysInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    public_key?: StringFieldUpdateOperationsInput | string
    private_key?: StringFieldUpdateOperationsInput | string
    secret?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    provider_id?: StringFieldUpdateOperationsInput | string
    platform_ids?: provider_keysUpdateplatform_idsInput | Enumerable<string>
  }

  export type usersUpdateWithoutPlatformsInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    image?: imagesUpdateOneWithoutUsersNestedInput
    prefered_location?: locationsUpdateOneWithoutUsers_preferedNestedInput
    locations?: locationsUpdateManyWithoutUsersNestedInput
    organizations?: organizationsUpdateManyWithoutUsersNestedInput
    stores?: storesUpdateManyWithoutUsersNestedInput
    payments_created?: paymentUpdateManyWithoutUser_creatorNestedInput
    payments_confirmed?: paymentUpdateManyWithoutUser_confirmNestedInput
    session?: sessionsUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutPlatformsInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    prefered_location_id?: NullableStringFieldUpdateOperationsInput | string | null
    location_ids?: usersUpdatelocation_idsInput | Enumerable<string>
    platform_ids?: usersUpdateplatform_idsInput | Enumerable<string>
    organization_ids?: usersUpdateorganization_idsInput | Enumerable<string>
    store_ids?: usersUpdatestore_idsInput | Enumerable<string>
    locations?: locationsUncheckedUpdateManyWithoutUsersNestedInput
    organizations?: organizationsUncheckedUpdateManyWithoutUsersNestedInput
    stores?: storesUncheckedUpdateManyWithoutUsersNestedInput
    payments_created?: paymentUncheckedUpdateManyWithoutUser_creatorNestedInput
    payments_confirmed?: paymentUncheckedUpdateManyWithoutUser_confirmNestedInput
    session?: sessionsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateManyWithoutUsersInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    prefered_location_id?: NullableStringFieldUpdateOperationsInput | string | null
    location_ids?: usersUpdatelocation_idsInput | Enumerable<string>
    platform_ids?: usersUpdateplatform_idsInput | Enumerable<string>
    organization_ids?: usersUpdateorganization_idsInput | Enumerable<string>
    store_ids?: usersUpdatestore_idsInput | Enumerable<string>
  }

  export type organizationsUpdateWithoutPlatformsInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: imagesUpdateOneWithoutOrganizationsNestedInput
    users?: usersUpdateManyWithoutOrganizationsNestedInput
    locations?: locationsUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsUncheckedUpdateWithoutPlatformsInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    platform_ids?: organizationsUpdateplatform_idsInput | Enumerable<string>
    user_ids?: organizationsUpdateuser_idsInput | Enumerable<string>
    location_ids?: organizationsUpdatelocation_idsInput | Enumerable<string>
    users?: usersUncheckedUpdateManyWithoutOrganizationsNestedInput
    locations?: locationsUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsUncheckedUpdateManyWithoutOrganizationsInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    platform_ids?: organizationsUpdateplatform_idsInput | Enumerable<string>
    user_ids?: organizationsUpdateuser_idsInput | Enumerable<string>
    location_ids?: organizationsUpdatelocation_idsInput | Enumerable<string>
  }

  export type provider_keysCreateManyProviderInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    public_key: string
    private_key: string
    secret: boolean
    description?: string | null
    platform_ids?: provider_keysCreateplatform_idsInput | Enumerable<string>
  }

  export type platformsUpdateWithoutProvidersInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    key?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: imagesUpdateOneWithoutPlatformsNestedInput
    provider_keys?: provider_keysUpdateManyWithoutPlatformsNestedInput
    users?: usersUpdateManyWithoutPlatformsNestedInput
    organizations?: organizationsUpdateManyWithoutPlatformsNestedInput
  }

  export type platformsUncheckedUpdateWithoutProvidersInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    key?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_ids?: platformsUpdateprovider_idsInput | Enumerable<string>
    provider_key_ids?: platformsUpdateprovider_key_idsInput | Enumerable<string>
    user_ids?: platformsUpdateuser_idsInput | Enumerable<string>
    organization_ids?: platformsUpdateorganization_idsInput | Enumerable<string>
    provider_keys?: provider_keysUncheckedUpdateManyWithoutPlatformsNestedInput
    users?: usersUncheckedUpdateManyWithoutPlatformsNestedInput
    organizations?: organizationsUncheckedUpdateManyWithoutPlatformsNestedInput
  }

  export type platformsUncheckedUpdateManyWithoutPlatformsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    key?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_ids?: platformsUpdateprovider_idsInput | Enumerable<string>
    provider_key_ids?: platformsUpdateprovider_key_idsInput | Enumerable<string>
    user_ids?: platformsUpdateuser_idsInput | Enumerable<string>
    organization_ids?: platformsUpdateorganization_idsInput | Enumerable<string>
  }

  export type provider_keysUpdateWithoutProviderInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    public_key?: StringFieldUpdateOperationsInput | string
    private_key?: StringFieldUpdateOperationsInput | string
    secret?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    platforms?: platformsUpdateManyWithoutProvider_keysNestedInput
  }

  export type provider_keysUncheckedUpdateWithoutProviderInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    public_key?: StringFieldUpdateOperationsInput | string
    private_key?: StringFieldUpdateOperationsInput | string
    secret?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    platform_ids?: provider_keysUpdateplatform_idsInput | Enumerable<string>
    platforms?: platformsUncheckedUpdateManyWithoutProvider_keysNestedInput
  }

  export type platformsUpdateWithoutProvider_keysInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    key?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: imagesUpdateOneWithoutPlatformsNestedInput
    providers?: providersUpdateManyWithoutPlatformsNestedInput
    users?: usersUpdateManyWithoutPlatformsNestedInput
    organizations?: organizationsUpdateManyWithoutPlatformsNestedInput
  }

  export type platformsUncheckedUpdateWithoutProvider_keysInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    key?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_ids?: platformsUpdateprovider_idsInput | Enumerable<string>
    provider_key_ids?: platformsUpdateprovider_key_idsInput | Enumerable<string>
    user_ids?: platformsUpdateuser_idsInput | Enumerable<string>
    organization_ids?: platformsUpdateorganization_idsInput | Enumerable<string>
    providers?: providersUncheckedUpdateManyWithoutPlatformsNestedInput
    users?: usersUncheckedUpdateManyWithoutPlatformsNestedInput
    organizations?: organizationsUncheckedUpdateManyWithoutPlatformsNestedInput
  }

  export type paymentCreateManyUser_creatorInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    title?: string | null
    description?: string | null
    payment_type_id: string
    user_confirm_id: string
    receiver_account_id: string
    sender_account_id: string
    amount: XOR<CurrencyCreateEnvelopeInput, CurrencyCreateInput>
  }

  export type paymentCreateManyUser_confirmInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    title?: string | null
    description?: string | null
    payment_type_id: string
    user_creator_id: string
    receiver_account_id: string
    sender_account_id: string
    amount: XOR<CurrencyCreateEnvelopeInput, CurrencyCreateInput>
  }

  export type sessionsCreateManyUserInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    jwt: string
    user_uuid: string
  }

  export type locationsUpdateWithoutUsersInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    store_ids?: locationsUpdatestore_idsInput | Enumerable<string>
    organizations?: organizationsUpdateManyWithoutLocationsNestedInput
    stores?: storesUpdateManyWithoutLocationsNestedInput
    users_prefered?: usersUpdateManyWithoutPrefered_locationNestedInput
  }

  export type locationsUncheckedUpdateWithoutUsersInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    user_ids?: locationsUpdateuser_idsInput | Enumerable<string>
    organizations_ids?: locationsUpdateorganizations_idsInput | Enumerable<string>
    store_ids?: locationsUpdatestore_idsInput | Enumerable<string>
    organizations?: organizationsUncheckedUpdateManyWithoutLocationsNestedInput
    stores?: storesUncheckedUpdateManyWithoutLocationsNestedInput
    users_prefered?: usersUncheckedUpdateManyWithoutPrefered_locationNestedInput
  }

  export type locationsUncheckedUpdateManyWithoutLocationsInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    user_ids?: locationsUpdateuser_idsInput | Enumerable<string>
    organizations_ids?: locationsUpdateorganizations_idsInput | Enumerable<string>
    store_ids?: locationsUpdatestore_idsInput | Enumerable<string>
  }

  export type platformsUpdateWithoutUsersInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    key?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: imagesUpdateOneWithoutPlatformsNestedInput
    providers?: providersUpdateManyWithoutPlatformsNestedInput
    provider_keys?: provider_keysUpdateManyWithoutPlatformsNestedInput
    organizations?: organizationsUpdateManyWithoutPlatformsNestedInput
  }

  export type platformsUncheckedUpdateWithoutUsersInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    key?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_ids?: platformsUpdateprovider_idsInput | Enumerable<string>
    provider_key_ids?: platformsUpdateprovider_key_idsInput | Enumerable<string>
    user_ids?: platformsUpdateuser_idsInput | Enumerable<string>
    organization_ids?: platformsUpdateorganization_idsInput | Enumerable<string>
    providers?: providersUncheckedUpdateManyWithoutPlatformsNestedInput
    provider_keys?: provider_keysUncheckedUpdateManyWithoutPlatformsNestedInput
    organizations?: organizationsUncheckedUpdateManyWithoutPlatformsNestedInput
  }

  export type organizationsUpdateWithoutUsersInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: imagesUpdateOneWithoutOrganizationsNestedInput
    platforms?: platformsUpdateManyWithoutOrganizationsNestedInput
    locations?: locationsUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsUncheckedUpdateWithoutUsersInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    platform_ids?: organizationsUpdateplatform_idsInput | Enumerable<string>
    user_ids?: organizationsUpdateuser_idsInput | Enumerable<string>
    location_ids?: organizationsUpdatelocation_idsInput | Enumerable<string>
    platforms?: platformsUncheckedUpdateManyWithoutOrganizationsNestedInput
    locations?: locationsUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type storesUpdateWithoutUsersInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: imagesUpdateOneWithoutStoresNestedInput
    locations?: locationsUpdateManyWithoutStoresNestedInput
    inventories?: inventoriesUpdateManyWithoutStoresNestedInput
  }

  export type storesUncheckedUpdateWithoutUsersInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_ids?: storesUpdateuser_idsInput | Enumerable<string>
    location_ids?: storesUpdatelocation_idsInput | Enumerable<string>
    inventory_ids?: storesUpdateinventory_idsInput | Enumerable<string>
    locations?: locationsUncheckedUpdateManyWithoutStoresNestedInput
    inventories?: inventoriesUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type storesUncheckedUpdateManyWithoutStoresInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_ids?: storesUpdateuser_idsInput | Enumerable<string>
    location_ids?: storesUpdatelocation_idsInput | Enumerable<string>
    inventory_ids?: storesUpdateinventory_idsInput | Enumerable<string>
  }

  export type paymentUpdateWithoutUser_creatorInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: XOR<CurrencyUpdateEnvelopeInput, CurrencyCreateInput>
    payment_type?: PaymentTypeUpdateOneRequiredWithoutPaymentsNestedInput
    user_confirm?: usersUpdateOneRequiredWithoutPayments_confirmedNestedInput
    recever_account?: PaymentAccountUpdateOneRequiredWithoutPayments_receivedNestedInput
    sender_account?: PaymentAccountUpdateOneRequiredWithoutPayments_sendedNestedInput
  }

  export type paymentUncheckedUpdateWithoutUser_creatorInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    payment_type_id?: StringFieldUpdateOperationsInput | string
    user_confirm_id?: StringFieldUpdateOperationsInput | string
    receiver_account_id?: StringFieldUpdateOperationsInput | string
    sender_account_id?: StringFieldUpdateOperationsInput | string
    amount?: XOR<CurrencyUpdateEnvelopeInput, CurrencyCreateInput>
  }

  export type paymentUncheckedUpdateManyWithoutPayments_createdInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    payment_type_id?: StringFieldUpdateOperationsInput | string
    user_confirm_id?: StringFieldUpdateOperationsInput | string
    receiver_account_id?: StringFieldUpdateOperationsInput | string
    sender_account_id?: StringFieldUpdateOperationsInput | string
    amount?: XOR<CurrencyUpdateEnvelopeInput, CurrencyCreateInput>
  }

  export type paymentUpdateWithoutUser_confirmInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: XOR<CurrencyUpdateEnvelopeInput, CurrencyCreateInput>
    payment_type?: PaymentTypeUpdateOneRequiredWithoutPaymentsNestedInput
    user_creator?: usersUpdateOneRequiredWithoutPayments_createdNestedInput
    recever_account?: PaymentAccountUpdateOneRequiredWithoutPayments_receivedNestedInput
    sender_account?: PaymentAccountUpdateOneRequiredWithoutPayments_sendedNestedInput
  }

  export type paymentUncheckedUpdateWithoutUser_confirmInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    payment_type_id?: StringFieldUpdateOperationsInput | string
    user_creator_id?: StringFieldUpdateOperationsInput | string
    receiver_account_id?: StringFieldUpdateOperationsInput | string
    sender_account_id?: StringFieldUpdateOperationsInput | string
    amount?: XOR<CurrencyUpdateEnvelopeInput, CurrencyCreateInput>
  }

  export type paymentUncheckedUpdateManyWithoutPayments_confirmedInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    payment_type_id?: StringFieldUpdateOperationsInput | string
    user_creator_id?: StringFieldUpdateOperationsInput | string
    receiver_account_id?: StringFieldUpdateOperationsInput | string
    sender_account_id?: StringFieldUpdateOperationsInput | string
    amount?: XOR<CurrencyUpdateEnvelopeInput, CurrencyCreateInput>
  }

  export type sessionsUpdateWithoutUserInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    jwt?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
  }

  export type sessionsUncheckedUpdateWithoutUserInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    jwt?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
  }

  export type sessionsUncheckedUpdateManyWithoutSessionInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    jwt?: StringFieldUpdateOperationsInput | string
    user_uuid?: StringFieldUpdateOperationsInput | string
  }

  export type platformsUpdateWithoutOrganizationsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    key?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: imagesUpdateOneWithoutPlatformsNestedInput
    providers?: providersUpdateManyWithoutPlatformsNestedInput
    provider_keys?: provider_keysUpdateManyWithoutPlatformsNestedInput
    users?: usersUpdateManyWithoutPlatformsNestedInput
  }

  export type platformsUncheckedUpdateWithoutOrganizationsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    key?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_ids?: platformsUpdateprovider_idsInput | Enumerable<string>
    provider_key_ids?: platformsUpdateprovider_key_idsInput | Enumerable<string>
    user_ids?: platformsUpdateuser_idsInput | Enumerable<string>
    organization_ids?: platformsUpdateorganization_idsInput | Enumerable<string>
    providers?: providersUncheckedUpdateManyWithoutPlatformsNestedInput
    provider_keys?: provider_keysUncheckedUpdateManyWithoutPlatformsNestedInput
    users?: usersUncheckedUpdateManyWithoutPlatformsNestedInput
  }

  export type usersUpdateWithoutOrganizationsInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    image?: imagesUpdateOneWithoutUsersNestedInput
    prefered_location?: locationsUpdateOneWithoutUsers_preferedNestedInput
    locations?: locationsUpdateManyWithoutUsersNestedInput
    platforms?: platformsUpdateManyWithoutUsersNestedInput
    stores?: storesUpdateManyWithoutUsersNestedInput
    payments_created?: paymentUpdateManyWithoutUser_creatorNestedInput
    payments_confirmed?: paymentUpdateManyWithoutUser_confirmNestedInput
    session?: sessionsUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutOrganizationsInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    prefered_location_id?: NullableStringFieldUpdateOperationsInput | string | null
    location_ids?: usersUpdatelocation_idsInput | Enumerable<string>
    platform_ids?: usersUpdateplatform_idsInput | Enumerable<string>
    organization_ids?: usersUpdateorganization_idsInput | Enumerable<string>
    store_ids?: usersUpdatestore_idsInput | Enumerable<string>
    locations?: locationsUncheckedUpdateManyWithoutUsersNestedInput
    platforms?: platformsUncheckedUpdateManyWithoutUsersNestedInput
    stores?: storesUncheckedUpdateManyWithoutUsersNestedInput
    payments_created?: paymentUncheckedUpdateManyWithoutUser_creatorNestedInput
    payments_confirmed?: paymentUncheckedUpdateManyWithoutUser_confirmNestedInput
    session?: sessionsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type locationsUpdateWithoutOrganizationsInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    store_ids?: locationsUpdatestore_idsInput | Enumerable<string>
    users?: usersUpdateManyWithoutLocationsNestedInput
    stores?: storesUpdateManyWithoutLocationsNestedInput
    users_prefered?: usersUpdateManyWithoutPrefered_locationNestedInput
  }

  export type locationsUncheckedUpdateWithoutOrganizationsInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    user_ids?: locationsUpdateuser_idsInput | Enumerable<string>
    organizations_ids?: locationsUpdateorganizations_idsInput | Enumerable<string>
    store_ids?: locationsUpdatestore_idsInput | Enumerable<string>
    users?: usersUncheckedUpdateManyWithoutLocationsNestedInput
    stores?: storesUncheckedUpdateManyWithoutLocationsNestedInput
    users_prefered?: usersUncheckedUpdateManyWithoutPrefered_locationNestedInput
  }

  export type usersUpdateWithoutStoresInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    image?: imagesUpdateOneWithoutUsersNestedInput
    prefered_location?: locationsUpdateOneWithoutUsers_preferedNestedInput
    locations?: locationsUpdateManyWithoutUsersNestedInput
    platforms?: platformsUpdateManyWithoutUsersNestedInput
    organizations?: organizationsUpdateManyWithoutUsersNestedInput
    payments_created?: paymentUpdateManyWithoutUser_creatorNestedInput
    payments_confirmed?: paymentUpdateManyWithoutUser_confirmNestedInput
    session?: sessionsUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutStoresInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    prefered_location_id?: NullableStringFieldUpdateOperationsInput | string | null
    location_ids?: usersUpdatelocation_idsInput | Enumerable<string>
    platform_ids?: usersUpdateplatform_idsInput | Enumerable<string>
    organization_ids?: usersUpdateorganization_idsInput | Enumerable<string>
    store_ids?: usersUpdatestore_idsInput | Enumerable<string>
    locations?: locationsUncheckedUpdateManyWithoutUsersNestedInput
    platforms?: platformsUncheckedUpdateManyWithoutUsersNestedInput
    organizations?: organizationsUncheckedUpdateManyWithoutUsersNestedInput
    payments_created?: paymentUncheckedUpdateManyWithoutUser_creatorNestedInput
    payments_confirmed?: paymentUncheckedUpdateManyWithoutUser_confirmNestedInput
    session?: sessionsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type locationsUpdateWithoutStoresInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    store_ids?: locationsUpdatestore_idsInput | Enumerable<string>
    users?: usersUpdateManyWithoutLocationsNestedInput
    organizations?: organizationsUpdateManyWithoutLocationsNestedInput
    users_prefered?: usersUpdateManyWithoutPrefered_locationNestedInput
  }

  export type locationsUncheckedUpdateWithoutStoresInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    user_ids?: locationsUpdateuser_idsInput | Enumerable<string>
    organizations_ids?: locationsUpdateorganizations_idsInput | Enumerable<string>
    store_ids?: locationsUpdatestore_idsInput | Enumerable<string>
    users?: usersUncheckedUpdateManyWithoutLocationsNestedInput
    organizations?: organizationsUncheckedUpdateManyWithoutLocationsNestedInput
    users_prefered?: usersUncheckedUpdateManyWithoutPrefered_locationNestedInput
  }

  export type inventoriesUpdateWithoutStoresInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    item_inventories?: item_inventoriesUpdateManyWithoutInventoriesNestedInput
  }

  export type inventoriesUncheckedUpdateWithoutStoresInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    item_iventory_ids?: inventoriesUpdateitem_iventory_idsInput | Enumerable<string>
    store_ids?: inventoriesUpdatestore_idsInput | Enumerable<string>
    item_inventories?: item_inventoriesUncheckedUpdateManyWithoutInventoriesNestedInput
  }

  export type inventoriesUncheckedUpdateManyWithoutInventoriesInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    item_iventory_ids?: inventoriesUpdateitem_iventory_idsInput | Enumerable<string>
    store_ids?: inventoriesUpdatestore_idsInput | Enumerable<string>
  }

  export type item_inventoriesUpdateWithoutInventoriesInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumItemQualitativeTypeFieldUpdateOperationsInput | ItemQualitativeType
    value?: FloatFieldUpdateOperationsInput | number
    item?: itemsUpdateOneRequiredWithoutItem_inventoriesNestedInput
  }

  export type item_inventoriesUncheckedUpdateWithoutInventoriesInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    type?: EnumItemQualitativeTypeFieldUpdateOperationsInput | ItemQualitativeType
    value?: FloatFieldUpdateOperationsInput | number
    iventory_ids?: item_inventoriesUpdateiventory_idsInput | Enumerable<string>
  }

  export type item_inventoriesUncheckedUpdateManyWithoutItem_inventoriesInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    type?: EnumItemQualitativeTypeFieldUpdateOperationsInput | ItemQualitativeType
    value?: FloatFieldUpdateOperationsInput | number
    iventory_ids?: item_inventoriesUpdateiventory_idsInput | Enumerable<string>
  }

  export type storesUpdateWithoutInventoriesInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: imagesUpdateOneWithoutStoresNestedInput
    users?: usersUpdateManyWithoutStoresNestedInput
    locations?: locationsUpdateManyWithoutStoresNestedInput
  }

  export type storesUncheckedUpdateWithoutInventoriesInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_ids?: storesUpdateuser_idsInput | Enumerable<string>
    location_ids?: storesUpdatelocation_idsInput | Enumerable<string>
    inventory_ids?: storesUpdateinventory_idsInput | Enumerable<string>
    users?: usersUncheckedUpdateManyWithoutStoresNestedInput
    locations?: locationsUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type inventoriesUpdateWithoutItem_inventoriesInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stores?: storesUpdateManyWithoutInventoriesNestedInput
  }

  export type inventoriesUncheckedUpdateWithoutItem_inventoriesInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    item_iventory_ids?: inventoriesUpdateitem_iventory_idsInput | Enumerable<string>
    store_ids?: inventoriesUpdatestore_idsInput | Enumerable<string>
    stores?: storesUncheckedUpdateManyWithoutInventoriesNestedInput
  }

  export type item_ordersUpdateWithoutOrdersInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumItemQualitativeTypeFieldUpdateOperationsInput | ItemQualitativeType
    value?: FloatFieldUpdateOperationsInput | number
    item?: itemsUpdateOneRequiredWithoutItem_ordersNestedInput
  }

  export type item_ordersUncheckedUpdateWithoutOrdersInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    type?: EnumItemQualitativeTypeFieldUpdateOperationsInput | ItemQualitativeType
    value?: FloatFieldUpdateOperationsInput | number
    order_ids?: item_ordersUpdateorder_idsInput | Enumerable<string>
  }

  export type item_ordersUncheckedUpdateManyWithoutItem_ordersInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    type?: EnumItemQualitativeTypeFieldUpdateOperationsInput | ItemQualitativeType
    value?: FloatFieldUpdateOperationsInput | number
    order_ids?: item_ordersUpdateorder_idsInput | Enumerable<string>
  }

  export type odersUpdateWithoutItem_ordersInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
  }

  export type odersUncheckedUpdateWithoutItem_ordersInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    item_order_ids?: odersUpdateitem_order_idsInput | Enumerable<string>
  }

  export type odersUncheckedUpdateManyWithoutOrdersInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    item_order_ids?: odersUpdateitem_order_idsInput | Enumerable<string>
  }

  export type paymentCreateManyPayment_typeInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    title?: string | null
    description?: string | null
    user_creator_id: string
    user_confirm_id: string
    receiver_account_id: string
    sender_account_id: string
    amount: XOR<CurrencyCreateEnvelopeInput, CurrencyCreateInput>
  }

  export type paymentUpdateWithoutPayment_typeInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: XOR<CurrencyUpdateEnvelopeInput, CurrencyCreateInput>
    user_creator?: usersUpdateOneRequiredWithoutPayments_createdNestedInput
    user_confirm?: usersUpdateOneRequiredWithoutPayments_confirmedNestedInput
    recever_account?: PaymentAccountUpdateOneRequiredWithoutPayments_receivedNestedInput
    sender_account?: PaymentAccountUpdateOneRequiredWithoutPayments_sendedNestedInput
  }

  export type paymentUncheckedUpdateWithoutPayment_typeInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    user_creator_id?: StringFieldUpdateOperationsInput | string
    user_confirm_id?: StringFieldUpdateOperationsInput | string
    receiver_account_id?: StringFieldUpdateOperationsInput | string
    sender_account_id?: StringFieldUpdateOperationsInput | string
    amount?: XOR<CurrencyUpdateEnvelopeInput, CurrencyCreateInput>
  }

  export type paymentUncheckedUpdateManyWithoutPaymentsInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    user_creator_id?: StringFieldUpdateOperationsInput | string
    user_confirm_id?: StringFieldUpdateOperationsInput | string
    receiver_account_id?: StringFieldUpdateOperationsInput | string
    sender_account_id?: StringFieldUpdateOperationsInput | string
    amount?: XOR<CurrencyUpdateEnvelopeInput, CurrencyCreateInput>
  }

  export type EnumCurrencyTypeFieldUpdateOperationsInput = {
    set?: CurrencyType
  }

  export type paymentCreateManyRecever_accountInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    title?: string | null
    description?: string | null
    payment_type_id: string
    user_creator_id: string
    user_confirm_id: string
    sender_account_id: string
    amount: XOR<CurrencyCreateEnvelopeInput, CurrencyCreateInput>
  }

  export type paymentCreateManySender_accountInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    title?: string | null
    description?: string | null
    payment_type_id: string
    user_creator_id: string
    user_confirm_id: string
    receiver_account_id: string
    amount: XOR<CurrencyCreateEnvelopeInput, CurrencyCreateInput>
  }

  export type paymentUpdateWithoutRecever_accountInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: XOR<CurrencyUpdateEnvelopeInput, CurrencyCreateInput>
    payment_type?: PaymentTypeUpdateOneRequiredWithoutPaymentsNestedInput
    user_creator?: usersUpdateOneRequiredWithoutPayments_createdNestedInput
    user_confirm?: usersUpdateOneRequiredWithoutPayments_confirmedNestedInput
    sender_account?: PaymentAccountUpdateOneRequiredWithoutPayments_sendedNestedInput
  }

  export type paymentUncheckedUpdateWithoutRecever_accountInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    payment_type_id?: StringFieldUpdateOperationsInput | string
    user_creator_id?: StringFieldUpdateOperationsInput | string
    user_confirm_id?: StringFieldUpdateOperationsInput | string
    sender_account_id?: StringFieldUpdateOperationsInput | string
    amount?: XOR<CurrencyUpdateEnvelopeInput, CurrencyCreateInput>
  }

  export type paymentUncheckedUpdateManyWithoutPayments_receivedInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    payment_type_id?: StringFieldUpdateOperationsInput | string
    user_creator_id?: StringFieldUpdateOperationsInput | string
    user_confirm_id?: StringFieldUpdateOperationsInput | string
    sender_account_id?: StringFieldUpdateOperationsInput | string
    amount?: XOR<CurrencyUpdateEnvelopeInput, CurrencyCreateInput>
  }

  export type paymentUpdateWithoutSender_accountInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: XOR<CurrencyUpdateEnvelopeInput, CurrencyCreateInput>
    payment_type?: PaymentTypeUpdateOneRequiredWithoutPaymentsNestedInput
    user_creator?: usersUpdateOneRequiredWithoutPayments_createdNestedInput
    user_confirm?: usersUpdateOneRequiredWithoutPayments_confirmedNestedInput
    recever_account?: PaymentAccountUpdateOneRequiredWithoutPayments_receivedNestedInput
  }

  export type paymentUncheckedUpdateWithoutSender_accountInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    payment_type_id?: StringFieldUpdateOperationsInput | string
    user_creator_id?: StringFieldUpdateOperationsInput | string
    user_confirm_id?: StringFieldUpdateOperationsInput | string
    receiver_account_id?: StringFieldUpdateOperationsInput | string
    amount?: XOR<CurrencyUpdateEnvelopeInput, CurrencyCreateInput>
  }

  export type paymentUncheckedUpdateManyWithoutPayments_sendedInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    payment_type_id?: StringFieldUpdateOperationsInput | string
    user_creator_id?: StringFieldUpdateOperationsInput | string
    user_confirm_id?: StringFieldUpdateOperationsInput | string
    receiver_account_id?: StringFieldUpdateOperationsInput | string
    amount?: XOR<CurrencyUpdateEnvelopeInput, CurrencyCreateInput>
  }

  export type item_inventoriesCreateManyItemInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    type: ItemQualitativeType
    value: number
    iventory_ids?: item_inventoriesCreateiventory_idsInput | Enumerable<string>
  }

  export type item_ordersCreateManyItemInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    type: ItemQualitativeType
    value: number
    order_ids?: item_ordersCreateorder_idsInput | Enumerable<string>
  }

  export type imagesUpdateWithoutItemsInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_key?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_url?: NullableStringFieldUpdateOperationsInput | string | null
    platforms?: platformsUpdateManyWithoutImageNestedInput
    providers?: providersUpdateManyWithoutImageNestedInput
    organizations?: organizationsUpdateManyWithoutImageNestedInput
    stores?: storesUpdateManyWithoutImageNestedInput
    users?: usersUpdateManyWithoutImageNestedInput
  }

  export type imagesUncheckedUpdateWithoutItemsInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_key?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_url?: NullableStringFieldUpdateOperationsInput | string | null
    item_ids?: imagesUpdateitem_idsInput | Enumerable<string>
    platforms?: platformsUncheckedUpdateManyWithoutImageNestedInput
    providers?: providersUncheckedUpdateManyWithoutImageNestedInput
    organizations?: organizationsUncheckedUpdateManyWithoutImageNestedInput
    stores?: storesUncheckedUpdateManyWithoutImageNestedInput
    users?: usersUncheckedUpdateManyWithoutImageNestedInput
  }

  export type imagesUncheckedUpdateManyWithoutImagesInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_key?: NullableStringFieldUpdateOperationsInput | string | null
    clipped_url?: NullableStringFieldUpdateOperationsInput | string | null
    item_ids?: imagesUpdateitem_idsInput | Enumerable<string>
  }

  export type item_inventoriesUpdateWithoutItemInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumItemQualitativeTypeFieldUpdateOperationsInput | ItemQualitativeType
    value?: FloatFieldUpdateOperationsInput | number
    inventories?: inventoriesUpdateManyWithoutItem_inventoriesNestedInput
  }

  export type item_inventoriesUncheckedUpdateWithoutItemInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumItemQualitativeTypeFieldUpdateOperationsInput | ItemQualitativeType
    value?: FloatFieldUpdateOperationsInput | number
    iventory_ids?: item_inventoriesUpdateiventory_idsInput | Enumerable<string>
    inventories?: inventoriesUncheckedUpdateManyWithoutItem_inventoriesNestedInput
  }

  export type item_ordersUpdateWithoutItemInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumItemQualitativeTypeFieldUpdateOperationsInput | ItemQualitativeType
    value?: FloatFieldUpdateOperationsInput | number
    orders?: odersUpdateManyWithoutItem_ordersNestedInput
  }

  export type item_ordersUncheckedUpdateWithoutItemInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    type?: EnumItemQualitativeTypeFieldUpdateOperationsInput | ItemQualitativeType
    value?: FloatFieldUpdateOperationsInput | number
    order_ids?: item_ordersUpdateorder_idsInput | Enumerable<string>
    orders?: odersUncheckedUpdateManyWithoutItem_ordersNestedInput
  }

  export type usersCreateManyPrefered_locationInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    email?: string | null
    phone?: string | null
    name?: string | null
    birthDate?: Date | string | null
    gender?: GenderType | null
    image_id?: string | null
    location_ids?: usersCreatelocation_idsInput | Enumerable<string>
    platform_ids?: usersCreateplatform_idsInput | Enumerable<string>
    organization_ids?: usersCreateorganization_idsInput | Enumerable<string>
    store_ids?: usersCreatestore_idsInput | Enumerable<string>
  }

  export type usersUpdateWithoutLocationsInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    image?: imagesUpdateOneWithoutUsersNestedInput
    prefered_location?: locationsUpdateOneWithoutUsers_preferedNestedInput
    platforms?: platformsUpdateManyWithoutUsersNestedInput
    organizations?: organizationsUpdateManyWithoutUsersNestedInput
    stores?: storesUpdateManyWithoutUsersNestedInput
    payments_created?: paymentUpdateManyWithoutUser_creatorNestedInput
    payments_confirmed?: paymentUpdateManyWithoutUser_confirmNestedInput
    session?: sessionsUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutLocationsInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    prefered_location_id?: NullableStringFieldUpdateOperationsInput | string | null
    location_ids?: usersUpdatelocation_idsInput | Enumerable<string>
    platform_ids?: usersUpdateplatform_idsInput | Enumerable<string>
    organization_ids?: usersUpdateorganization_idsInput | Enumerable<string>
    store_ids?: usersUpdatestore_idsInput | Enumerable<string>
    platforms?: platformsUncheckedUpdateManyWithoutUsersNestedInput
    organizations?: organizationsUncheckedUpdateManyWithoutUsersNestedInput
    stores?: storesUncheckedUpdateManyWithoutUsersNestedInput
    payments_created?: paymentUncheckedUpdateManyWithoutUser_creatorNestedInput
    payments_confirmed?: paymentUncheckedUpdateManyWithoutUser_confirmNestedInput
    session?: sessionsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type organizationsUpdateWithoutLocationsInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: imagesUpdateOneWithoutOrganizationsNestedInput
    platforms?: platformsUpdateManyWithoutOrganizationsNestedInput
    users?: usersUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsUncheckedUpdateWithoutLocationsInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    platform_ids?: organizationsUpdateplatform_idsInput | Enumerable<string>
    user_ids?: organizationsUpdateuser_idsInput | Enumerable<string>
    location_ids?: organizationsUpdatelocation_idsInput | Enumerable<string>
    platforms?: platformsUncheckedUpdateManyWithoutOrganizationsNestedInput
    users?: usersUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type storesUpdateWithoutLocationsInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: imagesUpdateOneWithoutStoresNestedInput
    users?: usersUpdateManyWithoutStoresNestedInput
    inventories?: inventoriesUpdateManyWithoutStoresNestedInput
  }

  export type storesUncheckedUpdateWithoutLocationsInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_ids?: storesUpdateuser_idsInput | Enumerable<string>
    location_ids?: storesUpdatelocation_idsInput | Enumerable<string>
    inventory_ids?: storesUpdateinventory_idsInput | Enumerable<string>
    users?: usersUncheckedUpdateManyWithoutStoresNestedInput
    inventories?: inventoriesUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type usersUpdateWithoutPrefered_locationInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    image?: imagesUpdateOneWithoutUsersNestedInput
    locations?: locationsUpdateManyWithoutUsersNestedInput
    platforms?: platformsUpdateManyWithoutUsersNestedInput
    organizations?: organizationsUpdateManyWithoutUsersNestedInput
    stores?: storesUpdateManyWithoutUsersNestedInput
    payments_created?: paymentUpdateManyWithoutUser_creatorNestedInput
    payments_confirmed?: paymentUpdateManyWithoutUser_confirmNestedInput
    session?: sessionsUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutPrefered_locationInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    location_ids?: usersUpdatelocation_idsInput | Enumerable<string>
    platform_ids?: usersUpdateplatform_idsInput | Enumerable<string>
    organization_ids?: usersUpdateorganization_idsInput | Enumerable<string>
    store_ids?: usersUpdatestore_idsInput | Enumerable<string>
    locations?: locationsUncheckedUpdateManyWithoutUsersNestedInput
    platforms?: platformsUncheckedUpdateManyWithoutUsersNestedInput
    organizations?: organizationsUncheckedUpdateManyWithoutUsersNestedInput
    stores?: storesUncheckedUpdateManyWithoutUsersNestedInput
    payments_created?: paymentUncheckedUpdateManyWithoutUser_creatorNestedInput
    payments_confirmed?: paymentUncheckedUpdateManyWithoutUser_confirmNestedInput
    session?: sessionsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateManyWithoutUsers_preferedInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    location_ids?: usersUpdatelocation_idsInput | Enumerable<string>
    platform_ids?: usersUpdateplatform_idsInput | Enumerable<string>
    organization_ids?: usersUpdateorganization_idsInput | Enumerable<string>
    store_ids?: usersUpdatestore_idsInput | Enumerable<string>
  }

  export type platformsCreateManyImageInput = {
    id?: string
    uuid?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    key: string
    username?: string | null
    name?: string | null
    provider_ids?: platformsCreateprovider_idsInput | Enumerable<string>
    provider_key_ids?: platformsCreateprovider_key_idsInput | Enumerable<string>
    user_ids?: platformsCreateuser_idsInput | Enumerable<string>
    organization_ids?: platformsCreateorganization_idsInput | Enumerable<string>
  }

  export type providersCreateManyImageInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    key: string
    name?: string | null
    platform_ids?: providersCreateplatform_idsInput | Enumerable<string>
    provider_key_ids?: providersCreateprovider_key_idsInput | Enumerable<string>
  }

  export type organizationsCreateManyImageInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    name?: string | null
    platform_ids?: organizationsCreateplatform_idsInput | Enumerable<string>
    user_ids?: organizationsCreateuser_idsInput | Enumerable<string>
    location_ids?: organizationsCreatelocation_idsInput | Enumerable<string>
  }

  export type storesCreateManyImageInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    name?: string | null
    user_ids?: storesCreateuser_idsInput | Enumerable<string>
    location_ids?: storesCreatelocation_idsInput | Enumerable<string>
    inventory_ids?: storesCreateinventory_idsInput | Enumerable<string>
  }

  export type usersCreateManyImageInput = {
    id?: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    uuid?: string
    username?: string | null
    email?: string | null
    phone?: string | null
    name?: string | null
    birthDate?: Date | string | null
    gender?: GenderType | null
    prefered_location_id?: string | null
    location_ids?: usersCreatelocation_idsInput | Enumerable<string>
    platform_ids?: usersCreateplatform_idsInput | Enumerable<string>
    organization_ids?: usersCreateorganization_idsInput | Enumerable<string>
    store_ids?: usersCreatestore_idsInput | Enumerable<string>
  }

  export type platformsUpdateWithoutImageInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    key?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    providers?: providersUpdateManyWithoutPlatformsNestedInput
    provider_keys?: provider_keysUpdateManyWithoutPlatformsNestedInput
    users?: usersUpdateManyWithoutPlatformsNestedInput
    organizations?: organizationsUpdateManyWithoutPlatformsNestedInput
  }

  export type platformsUncheckedUpdateWithoutImageInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    key?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    provider_ids?: platformsUpdateprovider_idsInput | Enumerable<string>
    provider_key_ids?: platformsUpdateprovider_key_idsInput | Enumerable<string>
    user_ids?: platformsUpdateuser_idsInput | Enumerable<string>
    organization_ids?: platformsUpdateorganization_idsInput | Enumerable<string>
    providers?: providersUncheckedUpdateManyWithoutPlatformsNestedInput
    provider_keys?: provider_keysUncheckedUpdateManyWithoutPlatformsNestedInput
    users?: usersUncheckedUpdateManyWithoutPlatformsNestedInput
    organizations?: organizationsUncheckedUpdateManyWithoutPlatformsNestedInput
  }

  export type providersUpdateWithoutImageInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    provider_key_ids?: providersUpdateprovider_key_idsInput | Enumerable<string>
    platforms?: platformsUpdateManyWithoutProvidersNestedInput
    provider_keys?: provider_keysUpdateManyWithoutProviderNestedInput
  }

  export type providersUncheckedUpdateWithoutImageInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    platform_ids?: providersUpdateplatform_idsInput | Enumerable<string>
    provider_key_ids?: providersUpdateprovider_key_idsInput | Enumerable<string>
    platforms?: platformsUncheckedUpdateManyWithoutProvidersNestedInput
    provider_keys?: provider_keysUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type organizationsUpdateWithoutImageInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    platforms?: platformsUpdateManyWithoutOrganizationsNestedInput
    users?: usersUpdateManyWithoutOrganizationsNestedInput
    locations?: locationsUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsUncheckedUpdateWithoutImageInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    platform_ids?: organizationsUpdateplatform_idsInput | Enumerable<string>
    user_ids?: organizationsUpdateuser_idsInput | Enumerable<string>
    location_ids?: organizationsUpdatelocation_idsInput | Enumerable<string>
    platforms?: platformsUncheckedUpdateManyWithoutOrganizationsNestedInput
    users?: usersUncheckedUpdateManyWithoutOrganizationsNestedInput
    locations?: locationsUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type storesUpdateWithoutImageInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    users?: usersUpdateManyWithoutStoresNestedInput
    locations?: locationsUpdateManyWithoutStoresNestedInput
    inventories?: inventoriesUpdateManyWithoutStoresNestedInput
  }

  export type storesUncheckedUpdateWithoutImageInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    user_ids?: storesUpdateuser_idsInput | Enumerable<string>
    location_ids?: storesUpdatelocation_idsInput | Enumerable<string>
    inventory_ids?: storesUpdateinventory_idsInput | Enumerable<string>
    users?: usersUncheckedUpdateManyWithoutStoresNestedInput
    locations?: locationsUncheckedUpdateManyWithoutStoresNestedInput
    inventories?: inventoriesUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type usersUpdateWithoutImageInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    prefered_location?: locationsUpdateOneWithoutUsers_preferedNestedInput
    locations?: locationsUpdateManyWithoutUsersNestedInput
    platforms?: platformsUpdateManyWithoutUsersNestedInput
    organizations?: organizationsUpdateManyWithoutUsersNestedInput
    stores?: storesUpdateManyWithoutUsersNestedInput
    payments_created?: paymentUpdateManyWithoutUser_creatorNestedInput
    payments_confirmed?: paymentUpdateManyWithoutUser_confirmNestedInput
    session?: sessionsUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutImageInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    prefered_location_id?: NullableStringFieldUpdateOperationsInput | string | null
    location_ids?: usersUpdatelocation_idsInput | Enumerable<string>
    platform_ids?: usersUpdateplatform_idsInput | Enumerable<string>
    organization_ids?: usersUpdateorganization_idsInput | Enumerable<string>
    store_ids?: usersUpdatestore_idsInput | Enumerable<string>
    locations?: locationsUncheckedUpdateManyWithoutUsersNestedInput
    platforms?: platformsUncheckedUpdateManyWithoutUsersNestedInput
    organizations?: organizationsUncheckedUpdateManyWithoutUsersNestedInput
    stores?: storesUncheckedUpdateManyWithoutUsersNestedInput
    payments_created?: paymentUncheckedUpdateManyWithoutUser_creatorNestedInput
    payments_confirmed?: paymentUncheckedUpdateManyWithoutUser_confirmNestedInput
    session?: sessionsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type itemsUpdateWithoutImagesInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: itemsUpdatetagsInput | Enumerable<string>
    prices?: XOR<CurrencyListUpdateEnvelopeInput, Enumerable<CurrencyCreateInput>>
    item_inventories?: item_inventoriesUpdateManyWithoutItemNestedInput
    item_orders?: item_ordersUpdateManyWithoutItemNestedInput
  }

  export type itemsUncheckedUpdateWithoutImagesInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: itemsUpdatetagsInput | Enumerable<string>
    image_ids?: itemsUpdateimage_idsInput | Enumerable<string>
    prices?: XOR<CurrencyListUpdateEnvelopeInput, Enumerable<CurrencyCreateInput>>
    item_inventories?: item_inventoriesUncheckedUpdateManyWithoutItemNestedInput
    item_orders?: item_ordersUncheckedUpdateManyWithoutItemNestedInput
  }

  export type itemsUncheckedUpdateManyWithoutItemsInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: itemsUpdatetagsInput | Enumerable<string>
    image_ids?: itemsUpdateimage_idsInput | Enumerable<string>
    prices?: XOR<CurrencyListUpdateEnvelopeInput, Enumerable<CurrencyCreateInput>>
  }

  export type NestedEnumCurrencyTypeFilter = {
    equals?: CurrencyType
    in?: Enumerable<CurrencyType>
    notIn?: Enumerable<CurrencyType>
    not?: NestedEnumCurrencyTypeFilter | CurrencyType
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}